{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/user/Desktop/angular/BBW_front_Angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, Directive, Inject, Input, Output, NgModule } from '@angular/core';\nimport { ReplaySubject, Subscription, Subject, asyncScheduler, Observable } from 'rxjs';\nimport { throttleTime, switchMap } from 'rxjs/operators';\nclass ChangeFilterV2 {\n  constructor() {\n    this.subject = new ReplaySubject(1);\n    this.subscriptions = new Subscription();\n  }\n  doFilter(changes) {\n    this.subject.next(changes);\n  }\n  dispose() {\n    this.subscriptions.unsubscribe();\n  }\n  notEmpty(key, handler) {\n    this.subscriptions.add(this.subject.subscribe(changes => {\n      if (changes[key]) {\n        const value = changes[key].currentValue;\n        if (value !== undefined && value !== null) {\n          handler(value);\n        }\n      }\n    }));\n  }\n  has(key, handler) {\n    this.subscriptions.add(this.subject.subscribe(changes => {\n      if (changes[key]) {\n        const value = changes[key].currentValue;\n        handler(value);\n      }\n    }));\n  }\n  notFirst(key, handler) {\n    this.subscriptions.add(this.subject.subscribe(changes => {\n      if (changes[key] && !changes[key].isFirstChange()) {\n        const value = changes[key].currentValue;\n        handler(value);\n      }\n    }));\n  }\n  notFirstAndEmpty(key, handler) {\n    this.subscriptions.add(this.subject.subscribe(changes => {\n      if (changes[key] && !changes[key].isFirstChange()) {\n        const value = changes[key].currentValue;\n        if (value !== undefined && value !== null) {\n          handler(value);\n        }\n      }\n    }));\n  }\n}\nconst NGX_ECHARTS_CONFIG = new InjectionToken('NGX_ECHARTS_CONFIG');\nclass NgxEchartsDirective {\n  constructor(config, el, ngZone) {\n    this.el = el;\n    this.ngZone = ngZone;\n    this.options = null;\n    this.theme = null;\n    this.initOpts = null;\n    this.merge = null;\n    this.autoResize = true;\n    this.loading = false;\n    this.loadingType = 'default';\n    this.loadingOpts = null;\n    // ngx-echarts events\n    this.chartInit = new EventEmitter();\n    this.optionsError = new EventEmitter();\n    // echarts mouse events\n    this.chartClick = this.createLazyEvent('click');\n    this.chartDblClick = this.createLazyEvent('dblclick');\n    this.chartMouseDown = this.createLazyEvent('mousedown');\n    this.chartMouseMove = this.createLazyEvent('mousemove');\n    this.chartMouseUp = this.createLazyEvent('mouseup');\n    this.chartMouseOver = this.createLazyEvent('mouseover');\n    this.chartMouseOut = this.createLazyEvent('mouseout');\n    this.chartGlobalOut = this.createLazyEvent('globalout');\n    this.chartContextMenu = this.createLazyEvent('contextmenu');\n    // echarts events\n    this.chartHighlight = this.createLazyEvent('highlight');\n    this.chartDownplay = this.createLazyEvent('downplay');\n    this.chartSelectChanged = this.createLazyEvent('selectchanged');\n    this.chartLegendSelectChanged = this.createLazyEvent('legendselectchanged');\n    this.chartLegendSelected = this.createLazyEvent('legendselected');\n    this.chartLegendUnselected = this.createLazyEvent('legendunselected');\n    this.chartLegendLegendSelectAll = this.createLazyEvent('legendselectall');\n    this.chartLegendLegendInverseSelect = this.createLazyEvent('legendinverseselect');\n    this.chartLegendScroll = this.createLazyEvent('legendscroll');\n    this.chartDataZoom = this.createLazyEvent('datazoom');\n    this.chartDataRangeSelected = this.createLazyEvent('datarangeselected');\n    this.chartGraphRoam = this.createLazyEvent('graphroam');\n    this.chartGeoRoam = this.createLazyEvent('georoam');\n    this.chartTreeRoam = this.createLazyEvent('treeroam');\n    this.chartTimelineChanged = this.createLazyEvent('timelinechanged');\n    this.chartTimelinePlayChanged = this.createLazyEvent('timelineplaychanged');\n    this.chartRestore = this.createLazyEvent('restore');\n    this.chartDataViewChanged = this.createLazyEvent('dataviewchanged');\n    this.chartMagicTypeChanged = this.createLazyEvent('magictypechanged');\n    this.chartGeoSelectChanged = this.createLazyEvent('geoselectchanged');\n    this.chartGeoSelected = this.createLazyEvent('geoselected');\n    this.chartGeoUnselected = this.createLazyEvent('geounselected');\n    this.chartAxisAreaSelected = this.createLazyEvent('axisareaselected');\n    this.chartBrush = this.createLazyEvent('brush');\n    this.chartBrushEnd = this.createLazyEvent('brushend');\n    this.chartBrushSelected = this.createLazyEvent('brushselected');\n    this.chartGlobalCursorTaken = this.createLazyEvent('globalcursortaken');\n    this.chartRendered = this.createLazyEvent('rendered');\n    this.chartFinished = this.createLazyEvent('finished');\n    this.animationFrameID = null;\n    this.chart$ = new ReplaySubject(1);\n    this.resize$ = new Subject();\n    this.changeFilter = new ChangeFilterV2();\n    this.resizeObFired = false;\n    this.echarts = config.echarts;\n    this.theme = config.theme || null;\n  }\n  ngOnChanges(changes) {\n    this.changeFilter.doFilter(changes);\n  }\n  ngOnInit() {\n    if (!window.ResizeObserver) {\n      throw new Error('please install a polyfill for ResizeObserver');\n    }\n    this.resizeSub = this.resize$.pipe(throttleTime(100, asyncScheduler, {\n      leading: false,\n      trailing: true\n    })).subscribe(() => this.resize());\n    if (this.autoResize) {\n      // https://github.com/xieziyu/ngx-echarts/issues/413\n      this.resizeOb = this.ngZone.runOutsideAngular(() => new window.ResizeObserver(entries => {\n        for (const entry of entries) {\n          if (entry.target === this.el.nativeElement) {\n            // Ignore first fire on insertion, no resize actually happened\n            if (!this.resizeObFired) {\n              this.resizeObFired = true;\n            } else {\n              this.animationFrameID = window.requestAnimationFrame(() => {\n                this.resize$.next();\n              });\n            }\n          }\n        }\n      }));\n      this.resizeOb.observe(this.el.nativeElement);\n    }\n    this.changeFilter.notFirstAndEmpty('options', opt => this.onOptionsChange(opt));\n    this.changeFilter.notFirstAndEmpty('merge', opt => this.setOption(opt));\n    this.changeFilter.has('loading', v => this.toggleLoading(!!v));\n    this.changeFilter.notFirst('theme', () => this.refreshChart());\n  }\n  ngOnDestroy() {\n    window.clearTimeout(this.initChartTimer);\n    if (this.resizeSub) {\n      this.resizeSub.unsubscribe();\n    }\n    if (this.animationFrameID) {\n      window.cancelAnimationFrame(this.animationFrameID);\n    }\n    if (this.resizeOb) {\n      this.resizeOb.unobserve(this.el.nativeElement);\n    }\n    if (this.loadingSub) {\n      this.loadingSub.unsubscribe();\n    }\n    this.changeFilter.dispose();\n    this.dispose();\n  }\n  ngAfterViewInit() {\n    this.initChartTimer = window.setTimeout(() => this.initChart());\n  }\n  dispose() {\n    if (this.chart) {\n      if (!this.chart.isDisposed()) {\n        this.chart.dispose();\n      }\n      this.chart = null;\n    }\n  }\n  /**\n   * resize chart\n   */\n  resize() {\n    if (this.chart) {\n      this.chart.resize();\n    }\n  }\n  toggleLoading(loading) {\n    if (this.chart) {\n      loading ? this.chart.showLoading(this.loadingType, this.loadingOpts) : this.chart.hideLoading();\n    } else {\n      this.loadingSub = this.chart$.subscribe(chart => loading ? chart.showLoading(this.loadingType, this.loadingOpts) : chart.hideLoading());\n    }\n  }\n  setOption(option, opts) {\n    if (this.chart) {\n      try {\n        this.chart.setOption(option, opts);\n      } catch (e) {\n        console.error(e);\n        this.optionsError.emit(e);\n      }\n    }\n  }\n  /**\n   * dispose old chart and create a new one.\n   */\n  refreshChart() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.dispose();\n      yield _this.initChart();\n    })();\n  }\n  createChart() {\n    const dom = this.el.nativeElement;\n    if (window && window.getComputedStyle) {\n      const prop = window.getComputedStyle(dom, null).getPropertyValue('height');\n      if ((!prop || prop === '0px') && (!dom.style.height || dom.style.height === '0px')) {\n        dom.style.height = '400px';\n      }\n    }\n    // here a bit tricky: we check if the echarts module is provided as function returning native import('...') then use the promise\n    // otherwise create the function that imitates behaviour above with a provided as is module\n    return this.ngZone.runOutsideAngular(() => {\n      const load = typeof this.echarts === 'function' ? this.echarts : () => Promise.resolve(this.echarts);\n      return load().then(({\n        init\n      }) => init(dom, this.theme, this.initOpts));\n    });\n  }\n  initChart() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2.onOptionsChange(_this2.options);\n      if (_this2.merge && _this2.chart) {\n        _this2.setOption(_this2.merge);\n      }\n    })();\n  }\n  onOptionsChange(opt) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!opt) {\n        return;\n      }\n      if (_this3.chart) {\n        _this3.setOption(_this3.options, true);\n      } else {\n        _this3.chart = yield _this3.createChart();\n        _this3.chart$.next(_this3.chart);\n        _this3.chartInit.emit(_this3.chart);\n        _this3.setOption(_this3.options, true);\n      }\n    })();\n  }\n  // allows to lazily bind to only those events that are requested through the `@Output` by parent components\n  // see https://stackoverflow.com/questions/51787972/optimal-reentering-the-ngzone-from-eventemitter-event for more info\n  createLazyEvent(eventName) {\n    return this.chartInit.pipe(switchMap(chart => new Observable(observer => {\n      chart.on(eventName, data => this.ngZone.run(() => observer.next(data)));\n      return () => {\n        if (this.chart) {\n          if (!this.chart.isDisposed()) {\n            chart.off(eventName);\n          }\n        }\n      };\n    })));\n  }\n  static #_ = this.ɵfac = function NgxEchartsDirective_Factory(t) {\n    return new (t || NgxEchartsDirective)(i0.ɵɵdirectiveInject(NGX_ECHARTS_CONFIG), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxEchartsDirective,\n    selectors: [[\"echarts\"], [\"\", \"echarts\", \"\"]],\n    inputs: {\n      options: \"options\",\n      theme: \"theme\",\n      initOpts: \"initOpts\",\n      merge: \"merge\",\n      autoResize: \"autoResize\",\n      loading: \"loading\",\n      loadingType: \"loadingType\",\n      loadingOpts: \"loadingOpts\"\n    },\n    outputs: {\n      chartInit: \"chartInit\",\n      optionsError: \"optionsError\",\n      chartClick: \"chartClick\",\n      chartDblClick: \"chartDblClick\",\n      chartMouseDown: \"chartMouseDown\",\n      chartMouseMove: \"chartMouseMove\",\n      chartMouseUp: \"chartMouseUp\",\n      chartMouseOver: \"chartMouseOver\",\n      chartMouseOut: \"chartMouseOut\",\n      chartGlobalOut: \"chartGlobalOut\",\n      chartContextMenu: \"chartContextMenu\",\n      chartHighlight: \"chartHighlight\",\n      chartDownplay: \"chartDownplay\",\n      chartSelectChanged: \"chartSelectChanged\",\n      chartLegendSelectChanged: \"chartLegendSelectChanged\",\n      chartLegendSelected: \"chartLegendSelected\",\n      chartLegendUnselected: \"chartLegendUnselected\",\n      chartLegendLegendSelectAll: \"chartLegendLegendSelectAll\",\n      chartLegendLegendInverseSelect: \"chartLegendLegendInverseSelect\",\n      chartLegendScroll: \"chartLegendScroll\",\n      chartDataZoom: \"chartDataZoom\",\n      chartDataRangeSelected: \"chartDataRangeSelected\",\n      chartGraphRoam: \"chartGraphRoam\",\n      chartGeoRoam: \"chartGeoRoam\",\n      chartTreeRoam: \"chartTreeRoam\",\n      chartTimelineChanged: \"chartTimelineChanged\",\n      chartTimelinePlayChanged: \"chartTimelinePlayChanged\",\n      chartRestore: \"chartRestore\",\n      chartDataViewChanged: \"chartDataViewChanged\",\n      chartMagicTypeChanged: \"chartMagicTypeChanged\",\n      chartGeoSelectChanged: \"chartGeoSelectChanged\",\n      chartGeoSelected: \"chartGeoSelected\",\n      chartGeoUnselected: \"chartGeoUnselected\",\n      chartAxisAreaSelected: \"chartAxisAreaSelected\",\n      chartBrush: \"chartBrush\",\n      chartBrushEnd: \"chartBrushEnd\",\n      chartBrushSelected: \"chartBrushSelected\",\n      chartGlobalCursorTaken: \"chartGlobalCursorTaken\",\n      chartRendered: \"chartRendered\",\n      chartFinished: \"chartFinished\"\n    },\n    exportAs: [\"echarts\"],\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxEchartsDirective, [{\n    type: Directive,\n    args: [{\n      standalone: true,\n      selector: 'echarts, [echarts]',\n      exportAs: 'echarts'\n    }]\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [NGX_ECHARTS_CONFIG]\n    }]\n  }, {\n    type: i0.ElementRef\n  }, {\n    type: i0.NgZone\n  }], {\n    options: [{\n      type: Input\n    }],\n    theme: [{\n      type: Input\n    }],\n    initOpts: [{\n      type: Input\n    }],\n    merge: [{\n      type: Input\n    }],\n    autoResize: [{\n      type: Input\n    }],\n    loading: [{\n      type: Input\n    }],\n    loadingType: [{\n      type: Input\n    }],\n    loadingOpts: [{\n      type: Input\n    }],\n    chartInit: [{\n      type: Output\n    }],\n    optionsError: [{\n      type: Output\n    }],\n    chartClick: [{\n      type: Output\n    }],\n    chartDblClick: [{\n      type: Output\n    }],\n    chartMouseDown: [{\n      type: Output\n    }],\n    chartMouseMove: [{\n      type: Output\n    }],\n    chartMouseUp: [{\n      type: Output\n    }],\n    chartMouseOver: [{\n      type: Output\n    }],\n    chartMouseOut: [{\n      type: Output\n    }],\n    chartGlobalOut: [{\n      type: Output\n    }],\n    chartContextMenu: [{\n      type: Output\n    }],\n    chartHighlight: [{\n      type: Output\n    }],\n    chartDownplay: [{\n      type: Output\n    }],\n    chartSelectChanged: [{\n      type: Output\n    }],\n    chartLegendSelectChanged: [{\n      type: Output\n    }],\n    chartLegendSelected: [{\n      type: Output\n    }],\n    chartLegendUnselected: [{\n      type: Output\n    }],\n    chartLegendLegendSelectAll: [{\n      type: Output\n    }],\n    chartLegendLegendInverseSelect: [{\n      type: Output\n    }],\n    chartLegendScroll: [{\n      type: Output\n    }],\n    chartDataZoom: [{\n      type: Output\n    }],\n    chartDataRangeSelected: [{\n      type: Output\n    }],\n    chartGraphRoam: [{\n      type: Output\n    }],\n    chartGeoRoam: [{\n      type: Output\n    }],\n    chartTreeRoam: [{\n      type: Output\n    }],\n    chartTimelineChanged: [{\n      type: Output\n    }],\n    chartTimelinePlayChanged: [{\n      type: Output\n    }],\n    chartRestore: [{\n      type: Output\n    }],\n    chartDataViewChanged: [{\n      type: Output\n    }],\n    chartMagicTypeChanged: [{\n      type: Output\n    }],\n    chartGeoSelectChanged: [{\n      type: Output\n    }],\n    chartGeoSelected: [{\n      type: Output\n    }],\n    chartGeoUnselected: [{\n      type: Output\n    }],\n    chartAxisAreaSelected: [{\n      type: Output\n    }],\n    chartBrush: [{\n      type: Output\n    }],\n    chartBrushEnd: [{\n      type: Output\n    }],\n    chartBrushSelected: [{\n      type: Output\n    }],\n    chartGlobalCursorTaken: [{\n      type: Output\n    }],\n    chartRendered: [{\n      type: Output\n    }],\n    chartFinished: [{\n      type: Output\n    }]\n  });\n})();\nconst provideEcharts = (config = {}) => {\n  return {\n    provide: NGX_ECHARTS_CONFIG,\n    useFactory: () => ({\n      ...config,\n      echarts: () => import('echarts')\n    })\n  };\n};\nconst provideEchartsCore = config => {\n  return {\n    provide: NGX_ECHARTS_CONFIG,\n    useValue: config\n  };\n};\nclass NgxEchartsModule {\n  static forRoot(config) {\n    return {\n      ngModule: NgxEchartsModule,\n      providers: [provideEchartsCore(config)]\n    };\n  }\n  static forChild() {\n    return {\n      ngModule: NgxEchartsModule\n    };\n  }\n  static #_ = this.ɵfac = function NgxEchartsModule_Factory(t) {\n    return new (t || NgxEchartsModule)();\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxEchartsModule\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxEchartsModule, [{\n    type: NgModule,\n    args: [{\n      imports: [NgxEchartsDirective],\n      exports: [NgxEchartsDirective]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of ngx-echarts\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGX_ECHARTS_CONFIG, NgxEchartsDirective, NgxEchartsModule, provideEcharts, provideEchartsCore };\n//# sourceMappingURL=ngx-echarts.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}