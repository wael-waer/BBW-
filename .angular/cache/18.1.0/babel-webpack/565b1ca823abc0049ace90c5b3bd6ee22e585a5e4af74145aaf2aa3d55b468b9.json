{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, inject, NgZone, Injectable, ElementRef, Directive } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { Subject, Observable, takeWhile, switchMap, merge, fromEvent, take, takeUntil, finalize } from 'rxjs';\n\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nconst NEWTON_ITERATIONS = 4;\nconst NEWTON_MIN_SLOPE = 0.001;\nconst SUBDIVISION_PRECISION = 0.0000001;\nconst SUBDIVISION_MAX_ITERATIONS = 10;\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nconst float32ArraySupported = typeof Float32Array === 'function';\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\nfunction C(aA1) {\n  return 3.0 * aA1;\n}\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n}\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  let currentX,\n    currentT,\n    i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nfunction LinearEasing(x) {\n  return x;\n}\nfunction bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  }\n  // Precompute samples table\n  const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  for (let i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n  function getTForX(aX) {\n    let intervalStart = 0.0;\n    let currentSample = 1;\n    const lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    // Interpolate to provide an initial guess for t\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n    const initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n  return function BezierEasing(x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n}\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS');\nfunction provideSmoothScrollOptions(options) {\n  return [{\n    provide: SMOOTH_SCROLL_OPTIONS,\n    useValue: options\n  }];\n}\nclass SmoothScrollManager {\n  constructor() {\n    this.document = inject(DOCUMENT);\n    this.zone = inject(NgZone);\n    // Default options\n    this._defaultOptions = {\n      duration: 468,\n      easing: {\n        x1: 0.42,\n        y1: 0,\n        x2: 0.58,\n        y2: 1\n      },\n      ...inject(SMOOTH_SCROLL_OPTIONS, {\n        optional: true\n      })\n    };\n    // Keeps track of the ongoing SmoothScroll functions, so they can be handled in case of duplication.\n    // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\n    // Purpose: If user called a scroll function again on the same element before the scrolls completes,\n    // it cancels the ongoing scroll and starts a new one\n    this.onGoingScrolls = new Map();\n  }\n  /**\n   * Timing method\n   */\n  get now() {\n    return this.document.defaultView.performance?.now?.bind(this.document.defaultView.performance) || Date.now;\n  }\n  /**\n   * changes scroll position inside an element\n   */\n  scrollElement(el, x, y) {\n    el.scrollLeft = x;\n    el.scrollTop = y;\n  }\n  /**\n   * Handles a given parameter of type HTMLElement, ElementRef or selector\n   */\n  getElement(el, parent) {\n    if (typeof el === 'string') {\n      return (parent || this.document).querySelector(el);\n    }\n    return coerceElement(el);\n  }\n  /**\n   * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\n   */\n  getScrollDestroyerRef(el) {\n    if (this.onGoingScrolls.has(el)) {\n      this.onGoingScrolls.get(el).next();\n    }\n    return this.onGoingScrolls.set(el, new Subject()).get(el);\n  }\n  /**\n   * A function called recursively that, given a context, steps through scrolling\n   */\n  step(context) {\n    return new Observable(subscriber => {\n      let elapsed = (this.now() - context.startTime) / context.duration;\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n      // apply easing to elapsed time\n      const value = context.easing(elapsed);\n      context.currentX = context.startX + (context.x - context.startX) * value;\n      context.currentY = context.startY + (context.y - context.startY) * value;\n      this.scrollElement(context.scrollable, context.currentX, context.currentY);\n      // Proceed to the step\n      requestAnimationFrame(() => {\n        subscriber.next();\n        subscriber.complete();\n      });\n    });\n  }\n  /**\n   * Checks if smooth scroll has reached, cleans up the smooth scroll stream\n   */\n  isReached(context, destroyed) {\n    if (context.currentX === context.x && context.currentY === context.y) {\n      // IMPORTANT: Destroy the stream when scroll is reached ASAP!\n      destroyed.next();\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Scroll recursively until coordinates are reached\n   * @param context\n   * @param destroyed\n   */\n  scrolling(context, destroyed) {\n    return this.step(context).pipe(\n    // Continue while target coordinates hasn't reached yet\n    takeWhile(() => !this.isReached(context, destroyed)), switchMap(() => this.scrolling(context, destroyed)));\n  }\n  /**\n   * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\n   */\n  onScrollReached(el, resolve, destroyed) {\n    destroyed.complete();\n    this.onGoingScrolls.delete(el);\n    this.zone.run(() => resolve());\n  }\n  /**\n   * Terminates an ongoing smooth scroll\n   */\n  interrupted(el, destroyed) {\n    return merge(fromEvent(el, 'wheel', {\n      passive: true,\n      capture: true\n    }), fromEvent(el, 'touchmove', {\n      passive: true,\n      capture: true\n    }), destroyed).pipe(take(1));\n  }\n  applyScrollToOptions(el, options) {\n    if (!options.duration) {\n      this.scrollElement(el, options.left, options.top);\n      return Promise.resolve();\n    }\n    return new Promise(resolve => {\n      this.zone.runOutsideAngular(() => {\n        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\n        const destroyed = this.getScrollDestroyerRef(el);\n        const context = {\n          scrollable: el,\n          startTime: this.now(),\n          startX: el.scrollLeft,\n          startY: el.scrollTop,\n          x: options.left == null ? el.scrollLeft : ~~options.left,\n          y: options.top == null ? el.scrollTop : ~~options.top,\n          duration: options.duration,\n          easing: bezier(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\n        };\n        this.scrolling(context, destroyed).pipe(\n        // Continue until interrupted by another scroll (new smooth scroll / wheel / touchmove)\n        takeUntil(this.interrupted(el, destroyed)),\n        // Once finished, clean up the destroyer stream and resolve the promise\n        finalize(() => this.onScrollReached(el, resolve, destroyed))).subscribe();\n      });\n    });\n  }\n  /**\n   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n   * left and right always refer to the left and right side of the scrolling container irrespective\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n   * in an RTL context.\n   * @param scrollable element\n   * @param customOptions specified the offsets to scroll to.\n   */\n  scrollTo(scrollable, customOptions) {\n    const el = this.getElement(scrollable);\n    const isRtl = getComputedStyle(el).direction === 'rtl';\n    const options = {\n      ...this._defaultOptions,\n      ...customOptions,\n      ...{\n        // Rewrite start & end offsets as right or left offsets.\n        left: customOptions.left == null ? isRtl ? customOptions.end : customOptions.start : customOptions.left,\n        right: customOptions.right == null ? isRtl ? customOptions.start : customOptions.end : customOptions.right\n      }\n    };\n    // Rewrite the bottom offset as a top offset.\n    if (options.bottom != null) {\n      options.top = el.scrollHeight - el.clientHeight - options.bottom;\n    }\n    // Rewrite the right offset as a left offset.\n    if (isRtl) {\n      if (options.left != null) {\n        options.right = el.scrollWidth - el.clientWidth - options.left;\n      }\n      options.left = options.right ? -options.right : options.right;\n    } else {\n      if (options.right != null) {\n        options.left = el.scrollWidth - el.clientWidth - options.right;\n      }\n    }\n    return this.applyScrollToOptions(el, options);\n  }\n  /**\n   * Scroll to element by reference or selector\n   */\n  scrollToElement(scrollable, target, customOptions = {}) {\n    const scrollableEl = this.getElement(scrollable);\n    const targetEl = this.getElement(target, scrollableEl);\n    if (targetEl && scrollableEl) {\n      const scrollableRect = scrollableEl.getBoundingClientRect();\n      const targetRect = targetEl.getBoundingClientRect();\n      const options = {\n        ...customOptions,\n        left: targetRect.left + scrollableEl.scrollLeft - scrollableRect.left + (customOptions.left || 0),\n        top: targetRect.top + scrollableEl.scrollTop - scrollableRect.top + (customOptions.top || 0)\n      };\n      return this.scrollTo(scrollableEl, options);\n    }\n    return Promise.resolve();\n  }\n  static #_ = this.ɵfac = function SmoothScrollManager_Factory(t) {\n    return new (t || SmoothScrollManager)();\n  };\n  static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SmoothScrollManager,\n    factory: SmoothScrollManager.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScrollManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nclass SmoothScroll {\n  constructor() {\n    this.smoothScroll = inject(SmoothScrollManager);\n    this.element = inject(ElementRef);\n  }\n  scrollTo(options) {\n    return this.smoothScroll.scrollTo(this.element, options);\n  }\n  scrollToElement(target, options) {\n    return this.smoothScroll.scrollToElement(this.element, target, options);\n  }\n  static #_ = this.ɵfac = function SmoothScroll_Factory(t) {\n    return new (t || SmoothScroll)();\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SmoothScroll,\n    selectors: [[\"\", \"smoothScroll\", \"\"]],\n    exportAs: [\"smoothScroll\"],\n    standalone: true\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScroll, [{\n    type: Directive,\n    args: [{\n      standalone: true,\n      selector: '[smoothScroll]',\n      exportAs: 'smoothScroll'\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager, provideSmoothScrollOptions };\n//# sourceMappingURL=ngx-scrollbar-smooth-scroll.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}