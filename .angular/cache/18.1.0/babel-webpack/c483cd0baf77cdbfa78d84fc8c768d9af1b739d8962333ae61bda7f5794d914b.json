{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, Input, InjectionToken, inject, LOCALE_ID, Optional, Inject, Injectable, EventEmitter, Component, ChangeDetectionStrategy, Output, ViewChild, TemplateRef, SkipSelf, forwardRef, Pipe, NgModule } from '@angular/core';\nimport * as i3 from '@angular/common';\nimport { getLocaleFirstDayOfWeek, DOCUMENT, CommonModule } from '@angular/common';\nimport * as i4 from '@angular/cdk/a11y';\nimport { A11yModule } from '@angular/cdk/a11y';\nimport * as i1 from '@angular/cdk/overlay';\nimport { NoopScrollStrategy, Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { Subscription, of, merge, Subject, filter, take as take$1, defer } from 'rxjs';\nimport * as i2 from '@angular/cdk/portal';\nimport { BasePortalOutlet, CdkPortalOutlet, ComponentPortal, PortalInjector, PortalModule } from '@angular/cdk/portal';\nimport { ENTER, PAGE_DOWN, PAGE_UP, END, HOME, DOWN_ARROW, UP_ARROW, RIGHT_ARROW, LEFT_ARROW, SPACE, ESCAPE } from '@angular/cdk/keycodes';\nimport { coerceBooleanProperty, coerceNumberProperty, coerceArray } from '@angular/cdk/coercion';\nimport { take, debounceTime, startWith, filter as filter$1 } from 'rxjs/operators';\nimport { trigger, state, style, transition, group, query, animateChild, animate, keyframes } from '@angular/animations';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS, Validators } from '@angular/forms';\nimport * as i1$1 from '@angular/cdk/platform';\nimport { PlatformModule } from '@angular/cdk/platform';\n\n/**\n * date-time-picker-trigger.directive\n */\nconst _c0 = [\"owl-date-time-calendar-body\", \"\"];\nconst _c1 = (a0, a1, a2) => ({\n  \"owl-dt-calendar-cell-out\": a0,\n  \"owl-dt-calendar-cell-today\": a1,\n  \"owl-dt-calendar-cell-selected\": a2\n});\nfunction OwlCalendarBodyComponent_tr_0_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"td\", 3);\n    i0.ɵɵlistener(\"click\", function OwlCalendarBodyComponent_tr_0_td_1_Template_td_click_0_listener() {\n      const item_r2 = i0.ɵɵrestoreView(_r1).$implicit;\n      const ctx_r2 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r2.selectCell(item_r2));\n    });\n    i0.ɵɵelementStart(1, \"span\", 4);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const item_r2 = ctx.$implicit;\n    const colIndex_r4 = ctx.index;\n    const rowIndex_r5 = i0.ɵɵnextContext().index;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassMapInterpolate1(\"owl-dt-calendar-cell \", item_r2.cellClass, \"\");\n    i0.ɵɵstyleProp(\"width\", 100 / ctx_r2.numCols, \"%\")(\"padding-top\", 50 * ctx_r2.cellRatio / ctx_r2.numCols, \"%\")(\"padding-bottom\", 50 * ctx_r2.cellRatio / ctx_r2.numCols, \"%\");\n    i0.ɵɵclassProp(\"owl-dt-calendar-cell-active\", ctx_r2.isActiveCell(rowIndex_r5, colIndex_r4))(\"owl-dt-calendar-cell-disabled\", !item_r2.enabled)(\"owl-dt-calendar-cell-in-range\", ctx_r2.isInRange(item_r2.value))(\"owl-dt-calendar-cell-range-from\", ctx_r2.isRangeFrom(item_r2.value))(\"owl-dt-calendar-cell-range-to\", ctx_r2.isRangeTo(item_r2.value));\n    i0.ɵɵproperty(\"tabindex\", ctx_r2.isActiveCell(rowIndex_r5, colIndex_r4) ? 0 : -1);\n    i0.ɵɵattribute(\"aria-label\", item_r2.ariaLabel)(\"aria-disabled\", !item_r2.enabled || null)(\"aria-current\", item_r2.value === ctx_r2.todayValue ? \"date\" : null)(\"aria-selected\", ctx_r2.isSelected(item_r2.value));\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction3(26, _c1, item_r2.out, item_r2.value === ctx_r2.todayValue, ctx_r2.isSelected(item_r2.value)));\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", item_r2.displayValue, \" \");\n  }\n}\nfunction OwlCalendarBodyComponent_tr_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 1);\n    i0.ɵɵtemplate(1, OwlCalendarBodyComponent_tr_0_td_1_Template, 3, 30, \"td\", 2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const row_r6 = ctx.$implicit;\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngForOf\", row_r6);\n  }\n}\nfunction OwlMonthViewComponent_th_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"th\", 6)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const weekday_r1 = ctx.$implicit;\n    i0.ɵɵattribute(\"aria-label\", weekday_r1.long);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(weekday_r1.short);\n  }\n}\nfunction OwlCalendarComponent_owl_date_time_month_view_18_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"owl-date-time-month-view\", 16);\n    i0.ɵɵlistener(\"pickerMomentChange\", function OwlCalendarComponent_owl_date_time_month_view_18_Template_owl_date_time_month_view_pickerMomentChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.handlePickerMomentChange($event));\n    })(\"selectedChange\", function OwlCalendarComponent_owl_date_time_month_view_18_Template_owl_date_time_month_view_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.dateSelected($event));\n    })(\"userSelection\", function OwlCalendarComponent_owl_date_time_month_view_18_Template_owl_date_time_month_view_userSelection_0_listener() {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.userSelected());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"pickerMoment\", ctx_r1.pickerMoment)(\"firstDayOfWeek\", ctx_r1.firstDayOfWeek)(\"selected\", ctx_r1.selected)(\"selecteds\", ctx_r1.selecteds)(\"selectMode\", ctx_r1.selectMode)(\"minDate\", ctx_r1.minDate)(\"maxDate\", ctx_r1.maxDate)(\"dateFilter\", ctx_r1.dateFilter)(\"hideOtherMonths\", ctx_r1.hideOtherMonths);\n  }\n}\nfunction OwlCalendarComponent_owl_date_time_year_view_19_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"owl-date-time-year-view\", 17);\n    i0.ɵɵlistener(\"keyboardEnter\", function OwlCalendarComponent_owl_date_time_year_view_19_Template_owl_date_time_year_view_keyboardEnter_0_listener() {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.focusActiveCell());\n    })(\"pickerMomentChange\", function OwlCalendarComponent_owl_date_time_year_view_19_Template_owl_date_time_year_view_pickerMomentChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.handlePickerMomentChange($event));\n    })(\"monthSelected\", function OwlCalendarComponent_owl_date_time_year_view_19_Template_owl_date_time_year_view_monthSelected_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.selectMonthInYearView($event));\n    })(\"change\", function OwlCalendarComponent_owl_date_time_year_view_19_Template_owl_date_time_year_view_change_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.goToDateInView($event, ctx_r1.DateView.MONTH));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"pickerMoment\", ctx_r1.pickerMoment)(\"selected\", ctx_r1.selected)(\"selecteds\", ctx_r1.selecteds)(\"selectMode\", ctx_r1.selectMode)(\"minDate\", ctx_r1.minDate)(\"maxDate\", ctx_r1.maxDate)(\"dateFilter\", ctx_r1.dateFilter);\n  }\n}\nfunction OwlCalendarComponent_owl_date_time_multi_year_view_20_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"owl-date-time-multi-year-view\", 18);\n    i0.ɵɵlistener(\"keyboardEnter\", function OwlCalendarComponent_owl_date_time_multi_year_view_20_Template_owl_date_time_multi_year_view_keyboardEnter_0_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.focusActiveCell());\n    })(\"pickerMomentChange\", function OwlCalendarComponent_owl_date_time_multi_year_view_20_Template_owl_date_time_multi_year_view_pickerMomentChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.handlePickerMomentChange($event));\n    })(\"yearSelected\", function OwlCalendarComponent_owl_date_time_multi_year_view_20_Template_owl_date_time_multi_year_view_yearSelected_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.selectYearInMultiYearView($event));\n    })(\"change\", function OwlCalendarComponent_owl_date_time_multi_year_view_20_Template_owl_date_time_multi_year_view_change_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.goToDateInView($event, ctx_r1.DateView.YEAR));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"pickerMoment\", ctx_r1.pickerMoment)(\"selected\", ctx_r1.selected)(\"selecteds\", ctx_r1.selecteds)(\"selectMode\", ctx_r1.selectMode)(\"minDate\", ctx_r1.minDate)(\"maxDate\", ctx_r1.maxDate)(\"dateFilter\", ctx_r1.dateFilter);\n  }\n}\nconst _c2 = [\"valueInput\"];\nfunction OwlTimerBoxComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 10);\n  }\n}\nfunction OwlTimerComponent_owl_date_time_timer_box_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"owl-date-time-timer-box\", 1);\n    i0.ɵɵlistener(\"inputChange\", function OwlTimerComponent_owl_date_time_timer_box_2_Template_owl_date_time_timer_box_inputChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.setSecondValue($event));\n    })(\"valueChange\", function OwlTimerComponent_owl_date_time_timer_box_2_Template_owl_date_time_timer_box_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.setSecondValue($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"showDivider\", true)(\"upBtnAriaLabel\", ctx_r1.upSecondButtonLabel)(\"downBtnAriaLabel\", ctx_r1.downSecondButtonLabel)(\"upBtnDisabled\", !ctx_r1.upSecondEnabled())(\"downBtnDisabled\", !ctx_r1.downSecondEnabled())(\"value\", ctx_r1.secondValue)(\"min\", 0)(\"max\", 59)(\"step\", ctx_r1.stepSecond)(\"inputLabel\", \"Second\");\n  }\n}\nfunction OwlTimerComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 4)(1, \"button\", 5);\n    i0.ɵɵlistener(\"click\", function OwlTimerComponent_div_3_Template_button_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.setMeridiem($event));\n    });\n    i0.ɵɵelementStart(2, \"span\", 6);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.hour12ButtonLabel, \" \");\n  }\n}\nconst _c3 = a0 => ({\n  \"owl-dt-container-info-active\": a0\n});\nfunction OwlDateTimeContainerComponent_owl_date_time_calendar_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"owl-date-time-calendar\", 7);\n    i0.ɵɵtwoWayListener(\"pickerMomentChange\", function OwlDateTimeContainerComponent_owl_date_time_calendar_1_Template_owl_date_time_calendar_pickerMomentChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      i0.ɵɵtwoWayBindingSet(ctx_r1.pickerMoment, $event) || (ctx_r1.pickerMoment = $event);\n      return i0.ɵɵresetView($event);\n    });\n    i0.ɵɵlistener(\"yearSelected\", function OwlDateTimeContainerComponent_owl_date_time_calendar_1_Template_owl_date_time_calendar_yearSelected_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.picker.selectYear($event));\n    })(\"monthSelected\", function OwlDateTimeContainerComponent_owl_date_time_calendar_1_Template_owl_date_time_calendar_monthSelected_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.picker.selectMonth($event));\n    })(\"dateClicked\", function OwlDateTimeContainerComponent_owl_date_time_calendar_1_Template_owl_date_time_calendar_dateClicked_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.picker.selectDate($event));\n    })(\"selectedChange\", function OwlDateTimeContainerComponent_owl_date_time_calendar_1_Template_owl_date_time_calendar_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.dateSelected($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"firstDayOfWeek\", ctx_r1.picker.firstDayOfWeek);\n    i0.ɵɵtwoWayProperty(\"pickerMoment\", ctx_r1.pickerMoment);\n    i0.ɵɵproperty(\"selected\", ctx_r1.picker.selected)(\"selecteds\", ctx_r1.picker.selecteds)(\"selectMode\", ctx_r1.picker.selectMode)(\"minDate\", ctx_r1.picker.minDateTime)(\"maxDate\", ctx_r1.picker.maxDateTime)(\"dateFilter\", ctx_r1.picker.dateTimeFilter)(\"startView\", ctx_r1.picker.startView)(\"yearOnly\", ctx_r1.picker.yearOnly)(\"multiyearOnly\", ctx_r1.picker.multiyearOnly)(\"hideOtherMonths\", ctx_r1.picker.hideOtherMonths);\n  }\n}\nfunction OwlDateTimeContainerComponent_owl_date_time_timer_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"owl-date-time-timer\", 8);\n    i0.ɵɵlistener(\"selectedChange\", function OwlDateTimeContainerComponent_owl_date_time_timer_2_Template_owl_date_time_timer_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.timeSelected($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"pickerMoment\", ctx_r1.pickerMoment)(\"minDateTime\", ctx_r1.picker.minDateTime)(\"maxDateTime\", ctx_r1.picker.maxDateTime)(\"showSecondsTimer\", ctx_r1.picker.showSecondsTimer)(\"hour12Timer\", ctx_r1.picker.hour12Timer)(\"stepHour\", ctx_r1.picker.stepHour)(\"stepMinute\", ctx_r1.picker.stepMinute)(\"stepSecond\", ctx_r1.picker.stepSecond);\n  }\n}\nfunction OwlDateTimeContainerComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 9)(1, \"div\", 10, 0);\n    i0.ɵɵlistener(\"click\", function OwlDateTimeContainerComponent_div_3_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.handleClickOnInfoGroup($event, 0));\n    })(\"keydown\", function OwlDateTimeContainerComponent_div_3_Template_div_keydown_1_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const to_r5 = i0.ɵɵreference(9);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.handleKeydownOnInfoGroup($event, to_r5, 0));\n    });\n    i0.ɵɵelementStart(3, \"span\", 11)(4, \"span\", 12);\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(6, \"span\", 13);\n    i0.ɵɵtext(7);\n    i0.ɵɵelementEnd()()();\n    i0.ɵɵelementStart(8, \"div\", 14, 1);\n    i0.ɵɵlistener(\"click\", function OwlDateTimeContainerComponent_div_3_Template_div_click_8_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.handleClickOnInfoGroup($event, 1));\n    })(\"keydown\", function OwlDateTimeContainerComponent_div_3_Template_div_keydown_8_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const from_r6 = i0.ɵɵreference(2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.handleKeydownOnInfoGroup($event, from_r6, 1));\n    });\n    i0.ɵɵelementStart(10, \"span\", 11)(11, \"span\", 12);\n    i0.ɵɵtext(12);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(13, \"span\", 13);\n    i0.ɵɵtext(14);\n    i0.ɵɵelementEnd()()()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"tabindex\", ctx_r1.activeSelectedIndex === 0 ? 0 : -1)(\"ngClass\", i0.ɵɵpureFunction1(10, _c3, ctx_r1.activeSelectedIndex === 0));\n    i0.ɵɵattribute(\"aria-checked\", ctx_r1.activeSelectedIndex === 0);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r1.fromLabel, \":\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r1.fromFormattedValue);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"tabindex\", ctx_r1.activeSelectedIndex === 1 ? 0 : -1)(\"ngClass\", i0.ɵɵpureFunction1(12, _c3, ctx_r1.activeSelectedIndex === 1));\n    i0.ɵɵattribute(\"aria-checked\", ctx_r1.activeSelectedIndex === 1);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r1.toLabel, \":\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r1.toFormattedValue);\n  }\n}\nfunction OwlDateTimeContainerComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 15)(1, \"button\", 16);\n    i0.ɵɵlistener(\"click\", function OwlDateTimeContainerComponent_div_4_Template_button_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.onCancelClicked($event));\n    });\n    i0.ɵɵelementStart(2, \"span\", 17);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(4, \"button\", 16);\n    i0.ɵɵlistener(\"click\", function OwlDateTimeContainerComponent_div_4_Template_button_click_4_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.onSetClicked($event));\n    });\n    i0.ɵɵelementStart(5, \"span\", 17);\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.cancelLabel, \" \");\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.setLabel, \" \");\n  }\n}\nfunction OwlDialogContainerComponent_ng_template_0_Template(rf, ctx) {}\nclass OwlDateTimeTriggerDirective {\n  get disabled() {\n    return this._disabled === undefined ? this.dtPicker.disabled : !!this._disabled;\n  }\n  set disabled(value) {\n    this._disabled = value;\n  }\n  get owlDTTriggerDisabledClass() {\n    return this.disabled;\n  }\n  constructor(changeDetector) {\n    this.changeDetector = changeDetector;\n    this.stateChanges = Subscription.EMPTY;\n  }\n  ngOnInit() {}\n  ngOnChanges(changes) {\n    if (changes.datepicker) {\n      this.watchStateChanges();\n    }\n  }\n  ngAfterContentInit() {\n    this.watchStateChanges();\n  }\n  ngOnDestroy() {\n    this.stateChanges.unsubscribe();\n  }\n  handleClickOnHost(event) {\n    if (this.dtPicker) {\n      this.dtPicker.open();\n      event.stopPropagation();\n    }\n  }\n  watchStateChanges() {\n    this.stateChanges.unsubscribe();\n    const inputDisabled = this.dtPicker && this.dtPicker.dtInput ? this.dtPicker.dtInput.disabledChange : of();\n    const pickerDisabled = this.dtPicker ? this.dtPicker.disabledChange : of();\n    this.stateChanges = merge([pickerDisabled, inputDisabled]).subscribe(() => {\n      this.changeDetector.markForCheck();\n    });\n  }\n  static #_ = this.ɵfac = function OwlDateTimeTriggerDirective_Factory(t) {\n    return new (t || OwlDateTimeTriggerDirective)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OwlDateTimeTriggerDirective,\n    selectors: [[\"\", \"owlDateTimeTrigger\", \"\"]],\n    hostVars: 2,\n    hostBindings: function OwlDateTimeTriggerDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function OwlDateTimeTriggerDirective_click_HostBindingHandler($event) {\n          return ctx.handleClickOnHost($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"owl-dt-trigger-disabled\", ctx.owlDTTriggerDisabledClass);\n      }\n    },\n    inputs: {\n      dtPicker: [0, \"owlDateTimeTrigger\", \"dtPicker\"],\n      disabled: \"disabled\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlDateTimeTriggerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[owlDateTimeTrigger]',\n      host: {\n        '(click)': 'handleClickOnHost($event)',\n        '[class.owl-dt-trigger-disabled]': 'owlDTTriggerDisabledClass'\n      }\n    }]\n  }], () => [{\n    type: i0.ChangeDetectorRef\n  }], {\n    dtPicker: [{\n      type: Input,\n      args: ['owlDateTimeTrigger']\n    }],\n    disabled: [{\n      type: Input\n    }]\n  });\n})();\n\n/**\n * date-time-format.class\n */\n/** InjectionToken for date time picker that can be used to override default format. */\nconst OWL_DATE_TIME_FORMATS = new InjectionToken('OWL_DATE_TIME_FORMATS');\n\n/**\n * date-time-adapter.class\n */\n/** InjectionToken for date time picker that can be used to override default locale code. */\nconst OWL_DATE_TIME_LOCALE = new InjectionToken('OWL_DATE_TIME_LOCALE', {\n  providedIn: 'root',\n  factory: OWL_DATE_TIME_LOCALE_FACTORY\n});\n/** @docs-private */\nfunction OWL_DATE_TIME_LOCALE_FACTORY() {\n  return inject(LOCALE_ID);\n}\n/** Provider for OWL_DATE_TIME_LOCALE injection token. */\nconst OWL_DATE_TIME_LOCALE_PROVIDER = {\n  provide: OWL_DATE_TIME_LOCALE,\n  useExisting: LOCALE_ID\n};\nclass DateTimeAdapter {\n  constructor() {\n    /** A stream that emits when the locale changes. */\n    this._localeChanges = new Subject();\n    /** total milliseconds in a day. */\n    this.millisecondsInDay = 86400000;\n    /** total milliseconds in a minute. */\n    this.milliseondsInMinute = 60000;\n  }\n  get localeChanges() {\n    return this._localeChanges;\n  }\n  /**\n   * Compare two given dates\n   * 1 if the first date is after the second,\n   * -1 if the first date is before the second\n   * 0 if dates are equal.\n   * */\n  compare(first, second) {\n    if (!this.isValid(first) || !this.isValid(second)) {\n      throw Error('JSNativeDate: Cannot compare invalid dates.');\n    }\n    const dateFirst = this.clone(first);\n    const dateSecond = this.clone(second);\n    const diff = this.getTime(dateFirst) - this.getTime(dateSecond);\n    if (diff < 0) {\n      return -1;\n    } else if (diff > 0) {\n      return 1;\n    } else {\n      // Return 0 if diff is 0; return NaN if diff is NaN\n      return diff;\n    }\n  }\n  /**\n   * Check if two given dates are in the same year\n   * 1 if the first date's year is after the second,\n   * -1 if the first date's year is before the second\n   * 0 if two given dates are in the same year\n   * */\n  compareYear(first, second) {\n    if (!this.isValid(first) || !this.isValid(second)) {\n      throw Error('JSNativeDate: Cannot compare invalid dates.');\n    }\n    const yearLeft = this.getYear(first);\n    const yearRight = this.getYear(second);\n    const diff = yearLeft - yearRight;\n    if (diff < 0) {\n      return -1;\n    } else if (diff > 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Attempts to deserialize a value to a valid date object. This is different from parsing in that\n   * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601\n   * string). The default implementation does not allow any deserialization, it simply checks that\n   * the given value is already a valid date object or null. The `<mat-datepicker>` will call this\n   * method on all of it's `@Input()` properties that accept dates. It is therefore possible to\n   * support passing values from your backend directly to these properties by overriding this method\n   * to also deserialize the format used by your backend.\n   */\n  deserialize(value) {\n    if (value == null || this.isDateInstance(value) && this.isValid(value)) {\n      return value;\n    }\n    return this.invalid();\n  }\n  /**\n   * Sets the locale used for all dates.\n   */\n  setLocale(locale) {\n    this.locale = locale;\n    this._localeChanges.next(locale);\n  }\n  /**\n  * Get the locale used for all dates.\n  * */\n  getLocale() {\n    return this.locale;\n  }\n  /**\n   * Clamp the given date between min and max dates.\n   */\n  clampDate(date, min, max) {\n    if (min && this.compare(date, min) < 0) {\n      return min;\n    }\n    if (max && this.compare(date, max) > 0) {\n      return max;\n    }\n    return date;\n  }\n}\n\n/**\n * date-time.class\n */\nlet nextUniqueId = 0;\nvar DateView;\n(function (DateView) {\n  DateView[\"MONTH\"] = \"month\";\n  DateView[\"YEAR\"] = \"year\";\n  DateView[\"MULTI_YEARS\"] = \"multi-years\";\n})(DateView || (DateView = {}));\nclass OwlDateTime {\n  get showSecondsTimer() {\n    return this._showSecondsTimer;\n  }\n  set showSecondsTimer(val) {\n    this._showSecondsTimer = coerceBooleanProperty(val);\n  }\n  get hour12Timer() {\n    return this._hour12Timer;\n  }\n  set hour12Timer(val) {\n    this._hour12Timer = coerceBooleanProperty(val);\n  }\n  get stepHour() {\n    return this._stepHour;\n  }\n  set stepHour(val) {\n    this._stepHour = coerceNumberProperty(val, 1);\n  }\n  get stepMinute() {\n    return this._stepMinute;\n  }\n  set stepMinute(val) {\n    this._stepMinute = coerceNumberProperty(val, 1);\n  }\n  get stepSecond() {\n    return this._stepSecond;\n  }\n  set stepSecond(val) {\n    this._stepSecond = coerceNumberProperty(val, 1);\n  }\n  get firstDayOfWeek() {\n    return this._firstDayOfWeek;\n  }\n  set firstDayOfWeek(value) {\n    value = coerceNumberProperty(value);\n    if (value > 6 || value < 0) {\n      this._firstDayOfWeek = undefined;\n    } else {\n      this._firstDayOfWeek = value;\n    }\n  }\n  get hideOtherMonths() {\n    return this._hideOtherMonths;\n  }\n  set hideOtherMonths(val) {\n    this._hideOtherMonths = coerceBooleanProperty(val);\n  }\n  get id() {\n    return this._id;\n  }\n  get formatString() {\n    return this.pickerType === 'both' ? this.dateTimeFormats.fullPickerInput : this.pickerType === 'calendar' ? this.dateTimeFormats.datePickerInput : this.dateTimeFormats.timePickerInput;\n  }\n  get disabled() {\n    return false;\n  }\n  constructor(dateTimeAdapter, dateTimeFormats) {\n    this.dateTimeAdapter = dateTimeAdapter;\n    this.dateTimeFormats = dateTimeFormats;\n    /**\n     * Whether to show the second's timer\n     */\n    this._showSecondsTimer = false;\n    /**\n     * Whether the timer is in hour12 format\n     */\n    this._hour12Timer = false;\n    /**\n     * The view that the calendar should start in.\n     */\n    this.startView = DateView.MONTH;\n    /**\n     * Whether to should only the year and multi-year views.\n     */\n    this.yearOnly = false;\n    /**\n     * Whether to should only the multi-year view.\n     */\n    this.multiyearOnly = false;\n    /**\n     * Hours to change per step\n     */\n    this._stepHour = 1;\n    /**\n     * Minutes to change per step\n     */\n    this._stepMinute = 1;\n    /**\n     * Seconds to change per step\n     */\n    this._stepSecond = 1;\n    /**\n     * Whether to hide dates in other months at the start or end of the current month.\n     */\n    this._hideOtherMonths = false;\n    /**\n     * Date Time Checker to check if the give dateTime is selectable\n     */\n    this.dateTimeChecker = dateTime => {\n      return !!dateTime && (!this.dateTimeFilter || this.dateTimeFilter(dateTime)) && (!this.minDateTime || this.dateTimeAdapter.compare(dateTime, this.minDateTime) >= 0) && (!this.maxDateTime || this.dateTimeAdapter.compare(dateTime, this.maxDateTime) <= 0);\n    };\n    if (!this.dateTimeAdapter) {\n      throw Error(`OwlDateTimePicker: No provider found for DateTimeAdapter. You must import one of the following ` + `modules at your application root: OwlNativeDateTimeModule, OwlMomentDateTimeModule, or provide a ` + `custom implementation.`);\n    }\n    if (!this.dateTimeFormats) {\n      throw Error(`OwlDateTimePicker: No provider found for OWL_DATE_TIME_FORMATS. You must import one of the following ` + `modules at your application root: OwlNativeDateTimeModule, OwlMomentDateTimeModule, or provide a ` + `custom implementation.`);\n    }\n    this._id = `owl-dt-picker-${nextUniqueId++}`;\n  }\n  getValidDate(obj) {\n    return this.dateTimeAdapter.isDateInstance(obj) && this.dateTimeAdapter.isValid(obj) ? obj : null;\n  }\n  static #_ = this.ɵfac = function OwlDateTime_Factory(t) {\n    return new (t || OwlDateTime)(i0.ɵɵdirectiveInject(DateTimeAdapter, 8), i0.ɵɵdirectiveInject(OWL_DATE_TIME_FORMATS, 8));\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OwlDateTime,\n    inputs: {\n      showSecondsTimer: \"showSecondsTimer\",\n      hour12Timer: \"hour12Timer\",\n      startView: \"startView\",\n      yearOnly: \"yearOnly\",\n      multiyearOnly: \"multiyearOnly\",\n      stepHour: \"stepHour\",\n      stepMinute: \"stepMinute\",\n      stepSecond: \"stepSecond\",\n      firstDayOfWeek: \"firstDayOfWeek\",\n      hideOtherMonths: \"hideOtherMonths\"\n    }\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlDateTime, [{\n    type: Directive\n  }], () => [{\n    type: DateTimeAdapter,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [OWL_DATE_TIME_FORMATS]\n    }]\n  }], {\n    showSecondsTimer: [{\n      type: Input\n    }],\n    hour12Timer: [{\n      type: Input\n    }],\n    startView: [{\n      type: Input\n    }],\n    yearOnly: [{\n      type: Input\n    }],\n    multiyearOnly: [{\n      type: Input\n    }],\n    stepHour: [{\n      type: Input\n    }],\n    stepMinute: [{\n      type: Input\n    }],\n    stepSecond: [{\n      type: Input\n    }],\n    firstDayOfWeek: [{\n      type: Input\n    }],\n    hideOtherMonths: [{\n      type: Input\n    }]\n  });\n})();\n\n/**\n * date-time-picker-intl.service\n */\nclass OwlDateTimeIntl {\n  constructor() {\n    /**\n     * Stream that emits whenever the labels here are changed. Use this to notify\n     * components if the labels have changed after initialization.\n     */\n    this.changes = new Subject();\n    /** A label for the up second button (used by screen readers).  */\n    this.upSecondLabel = 'Add a second';\n    /** A label for the down second button (used by screen readers).  */\n    this.downSecondLabel = 'Minus a second';\n    /** A label for the up minute button (used by screen readers).  */\n    this.upMinuteLabel = 'Add a minute';\n    /** A label for the down minute button (used by screen readers).  */\n    this.downMinuteLabel = 'Minus a minute';\n    /** A label for the up hour button (used by screen readers).  */\n    this.upHourLabel = 'Add a hour';\n    /** A label for the down hour button (used by screen readers).  */\n    this.downHourLabel = 'Minus a hour';\n    /** A label for the previous month button (used by screen readers). */\n    this.prevMonthLabel = 'Previous month';\n    /** A label for the next month button (used by screen readers). */\n    this.nextMonthLabel = 'Next month';\n    /** A label for the previous year button (used by screen readers). */\n    this.prevYearLabel = 'Previous year';\n    /** A label for the next year button (used by screen readers). */\n    this.nextYearLabel = 'Next year';\n    /** A label for the previous multi-year button (used by screen readers). */\n    this.prevMultiYearLabel = 'Previous 21 years';\n    /** A label for the next multi-year button (used by screen readers). */\n    this.nextMultiYearLabel = 'Next 21 years';\n    /** A label for the 'switch to month view' button (used by screen readers). */\n    this.switchToMonthViewLabel = 'Change to month view';\n    /** A label for the 'switch to year view' button (used by screen readers). */\n    this.switchToMultiYearViewLabel = 'Choose month and year';\n    /** A label for the cancel button */\n    this.cancelBtnLabel = 'Cancel';\n    /** A label for the set button */\n    this.setBtnLabel = 'Set';\n    /** A label for the range 'from' in picker info */\n    this.rangeFromLabel = 'From';\n    /** A label for the range 'to' in picker info */\n    this.rangeToLabel = 'To';\n    /** A label for the hour12 button (AM) */\n    this.hour12AMLabel = 'AM';\n    /** A label for the hour12 button (PM) */\n    this.hour12PMLabel = 'PM';\n  }\n  static #_ = this.ɵfac = function OwlDateTimeIntl_Factory(t) {\n    return new (t || OwlDateTimeIntl)();\n  };\n  static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OwlDateTimeIntl,\n    factory: OwlDateTimeIntl.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlDateTimeIntl, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * calendar-body.component\n */\nclass CalendarCell {\n  constructor(value, displayValue, ariaLabel, enabled, out = false, cellClass = '') {\n    this.value = value;\n    this.displayValue = displayValue;\n    this.ariaLabel = ariaLabel;\n    this.enabled = enabled;\n    this.out = out;\n    this.cellClass = cellClass;\n  }\n}\nclass OwlCalendarBodyComponent {\n  get owlDTCalendarBodyClass() {\n    return true;\n  }\n  get isInSingleMode() {\n    return this.selectMode === 'single';\n  }\n  get isInRangeMode() {\n    return this.selectMode === 'range' || this.selectMode === 'rangeFrom' || this.selectMode === 'rangeTo';\n  }\n  constructor(elmRef, ngZone) {\n    this.elmRef = elmRef;\n    this.ngZone = ngZone;\n    /**\n     * The cell number of the active cell in the table.\n     */\n    this.activeCell = 0;\n    /**\n     * The number of columns in the table.\n     * */\n    this.numCols = 7;\n    /**\n     * The ratio (width / height) to use for the cells in the table.\n     */\n    this.cellRatio = 1;\n    /**\n     * Emit when a calendar cell is selected\n     * */\n    this.select = new EventEmitter();\n  }\n  ngOnInit() {}\n  selectCell(cell) {\n    this.select.emit(cell);\n  }\n  isActiveCell(rowIndex, colIndex) {\n    const cellNumber = rowIndex * this.numCols + colIndex;\n    return cellNumber === this.activeCell;\n  }\n  /**\n   * Check if the cell is selected\n   */\n  isSelected(value) {\n    if (!this.selectedValues || this.selectedValues.length === 0) {\n      return false;\n    }\n    if (this.isInSingleMode) {\n      return value === this.selectedValues[0];\n    }\n    if (this.isInRangeMode) {\n      const fromValue = this.selectedValues[0];\n      const toValue = this.selectedValues[1];\n      return value === fromValue || value === toValue;\n    }\n  }\n  /**\n   * Check if the cell in the range\n   * */\n  isInRange(value) {\n    if (this.isInRangeMode) {\n      const fromValue = this.selectedValues[0];\n      const toValue = this.selectedValues[1];\n      if (fromValue !== null && toValue !== null) {\n        return value >= fromValue && value <= toValue;\n      } else {\n        return value === fromValue || value === toValue;\n      }\n    }\n  }\n  /**\n   * Check if the cell is the range from\n   * */\n  isRangeFrom(value) {\n    if (this.isInRangeMode) {\n      const fromValue = this.selectedValues[0];\n      return fromValue !== null && value === fromValue;\n    }\n  }\n  /**\n   * Check if the cell is the range to\n   * */\n  isRangeTo(value) {\n    if (this.isInRangeMode) {\n      const toValue = this.selectedValues[1];\n      return toValue !== null && value === toValue;\n    }\n  }\n  /**\n   * Focus to a active cell\n   * */\n  focusActiveCell() {\n    this.ngZone.runOutsideAngular(() => {\n      this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n        this.elmRef.nativeElement.querySelector('.owl-dt-calendar-cell-active').focus();\n      });\n    });\n  }\n  static #_ = this.ɵfac = function OwlCalendarBodyComponent_Factory(t) {\n    return new (t || OwlCalendarBodyComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OwlCalendarBodyComponent,\n    selectors: [[\"\", \"owl-date-time-calendar-body\", \"\"]],\n    hostVars: 2,\n    hostBindings: function OwlCalendarBodyComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"owl-dt-calendar-body\", ctx.owlDTCalendarBodyClass);\n      }\n    },\n    inputs: {\n      activeCell: \"activeCell\",\n      rows: \"rows\",\n      numCols: \"numCols\",\n      cellRatio: \"cellRatio\",\n      todayValue: \"todayValue\",\n      selectedValues: \"selectedValues\",\n      selectMode: \"selectMode\"\n    },\n    outputs: {\n      select: \"select\"\n    },\n    exportAs: [\"owlDateTimeCalendarBody\"],\n    attrs: _c0,\n    decls: 1,\n    vars: 1,\n    consts: [[\"role\", \"row\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"row\"], [3, \"class\", \"tabindex\", \"owl-dt-calendar-cell-active\", \"owl-dt-calendar-cell-disabled\", \"owl-dt-calendar-cell-in-range\", \"owl-dt-calendar-cell-range-from\", \"owl-dt-calendar-cell-range-to\", \"width\", \"paddingTop\", \"paddingBottom\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\", \"tabindex\"], [1, \"owl-dt-calendar-cell-content\", 3, \"ngClass\"]],\n    template: function OwlCalendarBodyComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, OwlCalendarBodyComponent_tr_0_Template, 2, 1, \"tr\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.rows);\n      }\n    },\n    dependencies: [i3.NgClass, i3.NgForOf],\n    changeDetection: 0\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlCalendarBodyComponent, [{\n    type: Component,\n    args: [{\n      selector: '[owl-date-time-calendar-body]',\n      exportAs: 'owlDateTimeCalendarBody',\n      host: {\n        '[class.owl-dt-calendar-body]': 'owlDTCalendarBodyClass'\n      },\n      preserveWhitespaces: false,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: \"<tr *ngFor=\\\"let row of rows; let rowIndex = index\\\" role=\\\"row\\\">\\n    <td *ngFor=\\\"let item of row; let colIndex = index\\\"\\n        class=\\\"owl-dt-calendar-cell {{item.cellClass}}\\\"\\n        [tabindex]=\\\"isActiveCell(rowIndex, colIndex) ? 0 : -1\\\"\\n        [class.owl-dt-calendar-cell-active]=\\\"isActiveCell(rowIndex, colIndex)\\\"\\n        [class.owl-dt-calendar-cell-disabled]=\\\"!item.enabled\\\"\\n        [class.owl-dt-calendar-cell-in-range]=\\\"isInRange(item.value)\\\"\\n        [class.owl-dt-calendar-cell-range-from]=\\\"isRangeFrom(item.value)\\\"\\n        [class.owl-dt-calendar-cell-range-to]=\\\"isRangeTo(item.value)\\\"\\n        [attr.aria-label]=\\\"item.ariaLabel\\\"\\n        [attr.aria-disabled]=\\\"!item.enabled || null\\\"\\n        [attr.aria-current]=\\\"item.value === todayValue ? 'date' : null\\\"\\n        [attr.aria-selected]=\\\"isSelected(item.value)\\\"\\n        [style.width.%]=\\\"100 / numCols\\\"\\n        [style.paddingTop.%]=\\\"50 * cellRatio / numCols\\\"\\n        [style.paddingBottom.%]=\\\"50 * cellRatio / numCols\\\"\\n        (click)=\\\"selectCell(item)\\\">\\n        <span class=\\\"owl-dt-calendar-cell-content\\\"\\n              [ngClass]=\\\"{\\n                'owl-dt-calendar-cell-out': item.out,\\n                'owl-dt-calendar-cell-today': item.value === todayValue,\\n                'owl-dt-calendar-cell-selected': isSelected(item.value)\\n              }\\\">\\n            {{item.displayValue}}\\n        </span>\\n    </td>\\n</tr>\\n\"\n    }]\n  }], () => [{\n    type: i0.ElementRef\n  }, {\n    type: i0.NgZone\n  }], {\n    activeCell: [{\n      type: Input\n    }],\n    rows: [{\n      type: Input\n    }],\n    numCols: [{\n      type: Input\n    }],\n    cellRatio: [{\n      type: Input\n    }],\n    todayValue: [{\n      type: Input\n    }],\n    selectedValues: [{\n      type: Input\n    }],\n    selectMode: [{\n      type: Input\n    }],\n    select: [{\n      type: Output\n    }]\n  });\n})();\nfunction defaultOptionsFactory() {\n  return DefaultOptions.create();\n}\nfunction multiYearOptionsFactory(options) {\n  return options.multiYear;\n}\nclass DefaultOptions {\n  static create() {\n    // Always return new instance\n    return {\n      multiYear: {\n        yearRows: 7,\n        yearsPerRow: 3\n      }\n    };\n  }\n}\nclass OptionsTokens {\n  static #_ = this.all = new InjectionToken('All options token');\n  static #_2 = this.multiYear = new InjectionToken('Grid view options token');\n}\nconst optionsProviders = [{\n  provide: OptionsTokens.all,\n  useFactory: defaultOptionsFactory\n}, {\n  provide: OptionsTokens.multiYear,\n  useFactory: multiYearOptionsFactory,\n  deps: [OptionsTokens.all]\n}];\n\n/**\n * calendar-multi-year-view.component\n */\nclass OwlMultiYearViewComponent {\n  get selectMode() {\n    return this._selectMode;\n  }\n  set selectMode(val) {\n    this._selectMode = val;\n    if (this.initiated) {\n      this.setSelectedYears();\n      this.cdRef.markForCheck();\n    }\n  }\n  get selected() {\n    return this._selected;\n  }\n  set selected(value) {\n    const oldSelected = this._selected;\n    value = this.dateTimeAdapter.deserialize(value);\n    this._selected = this.getValidDate(value);\n    if (!this.dateTimeAdapter.isSameDay(oldSelected, this._selected)) {\n      this.setSelectedYears();\n    }\n  }\n  get selecteds() {\n    return this._selecteds;\n  }\n  set selecteds(values) {\n    this._selecteds = values.map(v => {\n      v = this.dateTimeAdapter.deserialize(v);\n      return this.getValidDate(v);\n    });\n    this.setSelectedYears();\n  }\n  get pickerMoment() {\n    return this._pickerMoment;\n  }\n  set pickerMoment(value) {\n    const oldMoment = this._pickerMoment;\n    value = this.dateTimeAdapter.deserialize(value);\n    this._pickerMoment = this.getValidDate(value) || this.dateTimeAdapter.now();\n    if (oldMoment && this._pickerMoment && !this.isSameYearList(oldMoment, this._pickerMoment)) {\n      this.generateYearList();\n    }\n  }\n  get dateFilter() {\n    return this._dateFilter;\n  }\n  set dateFilter(filter) {\n    this._dateFilter = filter;\n    if (this.initiated) {\n      this.generateYearList();\n    }\n  }\n  get minDate() {\n    return this._minDate;\n  }\n  set minDate(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this._minDate = this.getValidDate(value);\n    if (this.initiated) {\n      this.generateYearList();\n    }\n  }\n  get maxDate() {\n    return this._maxDate;\n  }\n  set maxDate(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this._maxDate = this.getValidDate(value);\n    if (this.initiated) {\n      this.generateYearList();\n    }\n  }\n  get todayYear() {\n    return this._todayYear;\n  }\n  get years() {\n    return this._years;\n  }\n  get selectedYears() {\n    return this._selectedYears;\n  }\n  get isInSingleMode() {\n    return this.selectMode === 'single';\n  }\n  get isInRangeMode() {\n    return this.selectMode === 'range' || this.selectMode === 'rangeFrom' || this.selectMode === 'rangeTo';\n  }\n  get activeCell() {\n    if (this._pickerMoment) {\n      return this.dateTimeAdapter.getYear(this._pickerMoment) % (this.options.yearsPerRow * this.options.yearRows);\n    }\n  }\n  get tableHeader() {\n    if (this._years && this._years.length > 0) {\n      return `${this._years[0][0].displayValue} - ${this._years[this.options.yearRows - 1][this.options.yearsPerRow - 1].displayValue}`;\n    }\n  }\n  get prevButtonLabel() {\n    return this.pickerIntl.prevMultiYearLabel;\n  }\n  get nextButtonLabel() {\n    return this.pickerIntl.nextMultiYearLabel;\n  }\n  get owlDTCalendarView() {\n    return true;\n  }\n  get owlDTCalendarMultiYearView() {\n    return true;\n  }\n  constructor(cdRef, pickerIntl, dateTimeAdapter, options) {\n    this.cdRef = cdRef;\n    this.pickerIntl = pickerIntl;\n    this.dateTimeAdapter = dateTimeAdapter;\n    this.options = options;\n    /**\n     * The select mode of the picker;\n     * */\n    this._selectMode = 'single';\n    this._selecteds = [];\n    this.initiated = false;\n    /**\n     * Callback to invoke when a new month is selected\n     * */\n    this.change = new EventEmitter();\n    /**\n     * Emits the selected year. This doesn't imply a change on the selected date\n     * */\n    this.yearSelected = new EventEmitter();\n    /** Emits when any date is activated. */\n    this.pickerMomentChange = new EventEmitter();\n    /** Emits when use keyboard enter to select a calendar cell */\n    this.keyboardEnter = new EventEmitter();\n  }\n  ngOnInit() {}\n  ngAfterContentInit() {\n    this._todayYear = this.dateTimeAdapter.getYear(this.dateTimeAdapter.now());\n    this.generateYearList();\n    this.initiated = true;\n  }\n  /**\n   * Handle a calendarCell selected\n   */\n  selectCalendarCell(cell) {\n    this.selectYear(cell.value);\n  }\n  selectYear(year) {\n    this.yearSelected.emit(this.dateTimeAdapter.createDate(year, 0, 1));\n    const firstDateOfMonth = this.dateTimeAdapter.createDate(year, this.dateTimeAdapter.getMonth(this.pickerMoment), 1);\n    const daysInMonth = this.dateTimeAdapter.getNumDaysInMonth(firstDateOfMonth);\n    const selected = this.dateTimeAdapter.createDate(year, this.dateTimeAdapter.getMonth(this.pickerMoment), Math.min(daysInMonth, this.dateTimeAdapter.getDate(this.pickerMoment)), this.dateTimeAdapter.getHours(this.pickerMoment), this.dateTimeAdapter.getMinutes(this.pickerMoment), this.dateTimeAdapter.getSeconds(this.pickerMoment));\n    this.change.emit(selected);\n  }\n  /**\n   * Generate the previous year list\n   * */\n  prevYearList(event) {\n    this._pickerMoment = this.dateTimeAdapter.addCalendarYears(this.pickerMoment, -1 * this.options.yearsPerRow * this.options.yearRows);\n    this.generateYearList();\n    event.preventDefault();\n  }\n  /**\n   * Generate the next year list\n   * */\n  nextYearList(event) {\n    this._pickerMoment = this.dateTimeAdapter.addCalendarYears(this.pickerMoment, this.options.yearsPerRow * this.options.yearRows);\n    this.generateYearList();\n    event.preventDefault();\n  }\n  generateYearList() {\n    this._years = [];\n    const pickerMomentYear = this.dateTimeAdapter.getYear(this._pickerMoment);\n    const offset = pickerMomentYear % (this.options.yearsPerRow * this.options.yearRows);\n    for (let i = 0; i < this.options.yearRows; i++) {\n      const row = [];\n      for (let j = 0; j < this.options.yearsPerRow; j++) {\n        const year = pickerMomentYear - offset + (j + i * this.options.yearsPerRow);\n        const yearCell = this.createYearCell(year);\n        row.push(yearCell);\n      }\n      this._years.push(row);\n    }\n    return;\n  }\n  /** Whether the previous period button is enabled. */\n  previousEnabled() {\n    if (!this.minDate) {\n      return true;\n    }\n    return !this.minDate || !this.isSameYearList(this._pickerMoment, this.minDate);\n  }\n  /** Whether the next period button is enabled. */\n  nextEnabled() {\n    return !this.maxDate || !this.isSameYearList(this._pickerMoment, this.maxDate);\n  }\n  handleCalendarKeydown(event) {\n    let moment;\n    switch (event.keyCode) {\n      // minus 1 year\n      case LEFT_ARROW:\n        moment = this.dateTimeAdapter.addCalendarYears(this._pickerMoment, -1);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // add 1 year\n      case RIGHT_ARROW:\n        moment = this.dateTimeAdapter.addCalendarYears(this._pickerMoment, 1);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // minus 3 years\n      case UP_ARROW:\n        moment = this.dateTimeAdapter.addCalendarYears(this._pickerMoment, -1 * this.options.yearsPerRow);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // add 3 years\n      case DOWN_ARROW:\n        moment = this.dateTimeAdapter.addCalendarYears(this._pickerMoment, this.options.yearsPerRow);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // go to the first year of the year page\n      case HOME:\n        moment = this.dateTimeAdapter.addCalendarYears(this._pickerMoment, -this.dateTimeAdapter.getYear(this._pickerMoment) % (this.options.yearsPerRow * this.options.yearRows));\n        this.pickerMomentChange.emit(moment);\n        break;\n      // go to the last year of the year page\n      case END:\n        moment = this.dateTimeAdapter.addCalendarYears(this._pickerMoment, this.options.yearsPerRow * this.options.yearRows - this.dateTimeAdapter.getYear(this._pickerMoment) % (this.options.yearsPerRow * this.options.yearRows) - 1);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // minus 1 year page (or 10 year pages)\n      case PAGE_UP:\n        moment = this.dateTimeAdapter.addCalendarYears(this.pickerMoment, event.altKey ? -10 * (this.options.yearsPerRow * this.options.yearRows) : -1 * (this.options.yearsPerRow * this.options.yearRows));\n        this.pickerMomentChange.emit(moment);\n        break;\n      // add 1 year page (or 10 year pages)\n      case PAGE_DOWN:\n        moment = this.dateTimeAdapter.addCalendarYears(this.pickerMoment, event.altKey ? 10 * (this.options.yearsPerRow * this.options.yearRows) : this.options.yearsPerRow * this.options.yearRows);\n        this.pickerMomentChange.emit(moment);\n        break;\n      case ENTER:\n        this.selectYear(this.dateTimeAdapter.getYear(this._pickerMoment));\n        this.keyboardEnter.emit();\n        break;\n      default:\n        return;\n    }\n    this.focusActiveCell();\n    event.preventDefault();\n  }\n  /**\n   * Creates an CalendarCell for the given year.\n   */\n  createYearCell(year) {\n    const startDateOfYear = this.dateTimeAdapter.createDate(year, 0, 1);\n    const ariaLabel = this.dateTimeAdapter.getYearName(startDateOfYear);\n    const cellClass = 'owl-dt-year-' + year;\n    return new CalendarCell(year, year.toString(), ariaLabel, this.isYearEnabled(year), false, cellClass);\n  }\n  setSelectedYears() {\n    this._selectedYears = [];\n    if (this.isInSingleMode && this.selected) {\n      this._selectedYears[0] = this.dateTimeAdapter.getYear(this.selected);\n    }\n    if (this.isInRangeMode && this.selecteds) {\n      this._selectedYears = this.selecteds.map(selected => {\n        if (this.dateTimeAdapter.isValid(selected)) {\n          return this.dateTimeAdapter.getYear(selected);\n        } else {\n          return null;\n        }\n      });\n    }\n  }\n  /** Whether the given year is enabled. */\n  isYearEnabled(year) {\n    // disable if the year is greater than maxDate lower than minDate\n    if (year === undefined || year === null || this.maxDate && year > this.dateTimeAdapter.getYear(this.maxDate) || this.minDate && year < this.dateTimeAdapter.getYear(this.minDate)) {\n      return false;\n    }\n    // enable if it reaches here and there's no filter defined\n    if (!this.dateFilter) {\n      return true;\n    }\n    const firstOfYear = this.dateTimeAdapter.createDate(year, 0, 1);\n    // If any date in the year is enabled count the year as enabled.\n    for (let date = firstOfYear; this.dateTimeAdapter.getYear(date) === year; date = this.dateTimeAdapter.addCalendarDays(date, 1)) {\n      if (this.dateFilter(date)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isSameYearList(date1, date2) {\n    return Math.floor(this.dateTimeAdapter.getYear(date1) / (this.options.yearsPerRow * this.options.yearRows)) === Math.floor(this.dateTimeAdapter.getYear(date2) / (this.options.yearsPerRow * this.options.yearRows));\n  }\n  /**\n   * Get a valid date object\n   */\n  getValidDate(obj) {\n    return this.dateTimeAdapter.isDateInstance(obj) && this.dateTimeAdapter.isValid(obj) ? obj : null;\n  }\n  focusActiveCell() {\n    this.calendarBodyElm.focusActiveCell();\n  }\n  static #_ = this.ɵfac = function OwlMultiYearViewComponent_Factory(t) {\n    return new (t || OwlMultiYearViewComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(OwlDateTimeIntl), i0.ɵɵdirectiveInject(DateTimeAdapter, 8), i0.ɵɵdirectiveInject(OptionsTokens.multiYear));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OwlMultiYearViewComponent,\n    selectors: [[\"owl-date-time-multi-year-view\"]],\n    viewQuery: function OwlMultiYearViewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(OwlCalendarBodyComponent, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calendarBodyElm = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function OwlMultiYearViewComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"owl-dt-calendar-view\", ctx.owlDTCalendarView)(\"owl-dt-calendar-multi-year-view\", ctx.owlDTCalendarMultiYearView);\n      }\n    },\n    inputs: {\n      selectMode: \"selectMode\",\n      selected: \"selected\",\n      selecteds: \"selecteds\",\n      pickerMoment: \"pickerMoment\",\n      dateFilter: \"dateFilter\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\"\n    },\n    outputs: {\n      change: \"change\",\n      yearSelected: \"yearSelected\",\n      pickerMomentChange: \"pickerMomentChange\",\n      keyboardEnter: \"keyboardEnter\"\n    },\n    decls: 14,\n    vars: 12,\n    consts: [[\"type\", \"button\", \"tabindex\", \"0\", 1, \"owl-dt-control-button\", \"owl-dt-control-arrow-button\", 3, \"click\", \"disabled\"], [\"tabindex\", \"-1\", 1, \"owl-dt-control-button-content\"], [\"xmlns\", \"http://www.w3.org/2000/svg\", 0, \"xmlns\", \"xlink\", \"http://www.w3.org/1999/xlink\", \"version\", \"1.1\", \"x\", \"0px\", \"y\", \"0px\", \"viewBox\", \"0 0 250.738 250.738\", 0, \"xml\", \"space\", \"preserve\", \"width\", \"100%\", \"height\", \"100%\", 2, \"enable-background\", \"new 0 0 250.738 250.738\"], [\"d\", \"M96.633,125.369l95.053-94.533c7.101-7.055,7.101-18.492,0-25.546   c-7.1-7.054-18.613-7.054-25.714,0L58.989,111.689c-3.784,3.759-5.487,8.759-5.238,13.68c-0.249,4.922,1.454,9.921,5.238,13.681   l106.983,106.398c7.101,7.055,18.613,7.055,25.714,0c7.101-7.054,7.101-18.491,0-25.544L96.633,125.369z\", 2, \"fill-rule\", \"evenodd\", \"clip-rule\", \"evenodd\"], [1, \"owl-dt-calendar-table\", \"owl-dt-calendar-multi-year-table\"], [1, \"owl-dt-calendar-header\"], [\"colspan\", \"3\"], [\"owl-date-time-calendar-body\", \"\", \"role\", \"grid\", 3, \"keydown\", \"select\", \"rows\", \"numCols\", \"cellRatio\", \"activeCell\", \"todayValue\", \"selectedValues\", \"selectMode\"], [\"version\", \"1.1\", \"xmlns\", \"http://www.w3.org/2000/svg\", 0, \"xmlns\", \"xlink\", \"http://www.w3.org/1999/xlink\", \"x\", \"0px\", \"y\", \"0px\", \"viewBox\", \"0 0 250.738 250.738\", 0, \"xml\", \"space\", \"preserve\", 2, \"enable-background\", \"new 0 0 250.738 250.738\"], [\"d\", \"M191.75,111.689L84.766,5.291c-7.1-7.055-18.613-7.055-25.713,0\\n                c-7.101,7.054-7.101,18.49,0,25.544l95.053,94.534l-95.053,94.533c-7.101,7.054-7.101,18.491,0,25.545\\n                c7.1,7.054,18.613,7.054,25.713,0L191.75,139.05c3.784-3.759,5.487-8.759,5.238-13.681\\n                C197.237,120.447,195.534,115.448,191.75,111.689z\", 2, \"fill-rule\", \"evenodd\", \"clip-rule\", \"evenodd\"]],\n    template: function OwlMultiYearViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"button\", 0);\n        i0.ɵɵlistener(\"click\", function OwlMultiYearViewComponent_Template_button_click_0_listener($event) {\n          return ctx.prevYearList($event);\n        });\n        i0.ɵɵelementStart(1, \"span\", 1);\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(2, \"svg\", 2);\n        i0.ɵɵelement(3, \"path\", 3);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵnamespaceHTML();\n        i0.ɵɵelementStart(4, \"table\", 4)(5, \"thead\", 5)(6, \"tr\")(7, \"th\", 6);\n        i0.ɵɵtext(8);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(9, \"tbody\", 7);\n        i0.ɵɵlistener(\"keydown\", function OwlMultiYearViewComponent_Template_tbody_keydown_9_listener($event) {\n          return ctx.handleCalendarKeydown($event);\n        })(\"select\", function OwlMultiYearViewComponent_Template_tbody_select_9_listener($event) {\n          return ctx.selectCalendarCell($event);\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(10, \"button\", 0);\n        i0.ɵɵlistener(\"click\", function OwlMultiYearViewComponent_Template_button_click_10_listener($event) {\n          return ctx.nextYearList($event);\n        });\n        i0.ɵɵelementStart(11, \"span\", 1);\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(12, \"svg\", 8);\n        i0.ɵɵelement(13, \"path\", 9);\n        i0.ɵɵelementEnd()()();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"disabled\", !ctx.previousEnabled());\n        i0.ɵɵattribute(\"aria-label\", ctx.prevButtonLabel);\n        i0.ɵɵadvance(8);\n        i0.ɵɵtextInterpolate(ctx.tableHeader);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"rows\", ctx.years)(\"numCols\", 3)(\"cellRatio\", 3 / 7)(\"activeCell\", ctx.activeCell)(\"todayValue\", ctx.todayYear)(\"selectedValues\", ctx.selectedYears)(\"selectMode\", ctx.selectMode);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"disabled\", !ctx.nextEnabled());\n        i0.ɵɵattribute(\"aria-label\", ctx.nextButtonLabel);\n      }\n    },\n    dependencies: [OwlCalendarBodyComponent],\n    changeDetection: 0\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlMultiYearViewComponent, [{\n    type: Component,\n    args: [{\n      selector: 'owl-date-time-multi-year-view',\n      host: {\n        '[class.owl-dt-calendar-view]': 'owlDTCalendarView',\n        '[class.owl-dt-calendar-multi-year-view]': 'owlDTCalendarMultiYearView'\n      },\n      preserveWhitespaces: false,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: \"<button class=\\\"owl-dt-control-button owl-dt-control-arrow-button\\\"\\n        [disabled]=\\\"!previousEnabled()\\\" [attr.aria-label]=\\\"prevButtonLabel\\\"\\n        type=\\\"button\\\" tabindex=\\\"0\\\" (click)=\\\"prevYearList($event)\\\">\\n    <span class=\\\"owl-dt-control-button-content\\\" tabindex=\\\"-1\\\">\\n        <!-- <editor-fold desc=\\\"SVG Arrow Left\\\"> -->\\n    <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\\n             version=\\\"1.1\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 250.738 250.738\\\"\\n             style=\\\"enable-background:new 0 0 250.738 250.738;\\\" xml:space=\\\"preserve\\\"\\n             width=\\\"100%\\\" height=\\\"100%\\\">\\n            <path style=\\\"fill-rule: evenodd; clip-rule: evenodd;\\\" d=\\\"M96.633,125.369l95.053-94.533c7.101-7.055,7.101-18.492,0-25.546   c-7.1-7.054-18.613-7.054-25.714,0L58.989,111.689c-3.784,3.759-5.487,8.759-5.238,13.68c-0.249,4.922,1.454,9.921,5.238,13.681   l106.983,106.398c7.101,7.055,18.613,7.055,25.714,0c7.101-7.054,7.101-18.491,0-25.544L96.633,125.369z\\\"/>\\n        </svg>\\n        <!-- </editor-fold> -->\\n    </span>\\n</button>\\n<table class=\\\"owl-dt-calendar-table owl-dt-calendar-multi-year-table\\\">\\n    <thead class=\\\"owl-dt-calendar-header\\\">\\n    <tr>\\n        <th colspan=\\\"3\\\">{{tableHeader}}</th>\\n    </tr>\\n    </thead>\\n    <tbody owl-date-time-calendar-body role=\\\"grid\\\"\\n           [rows]=\\\"years\\\" [numCols]=\\\"3\\\" [cellRatio]=\\\"3 / 7\\\"\\n           [activeCell]=\\\"activeCell\\\"\\n           [todayValue]=\\\"todayYear\\\"\\n           [selectedValues]=\\\"selectedYears\\\"\\n           [selectMode]=\\\"selectMode\\\"\\n           (keydown)=\\\"handleCalendarKeydown($event)\\\"\\n           (select)=\\\"selectCalendarCell($event)\\\"></tbody>\\n</table>\\n<button class=\\\"owl-dt-control-button owl-dt-control-arrow-button\\\"\\n        [disabled]=\\\"!nextEnabled()\\\" [attr.aria-label]=\\\"nextButtonLabel\\\"\\n        type=\\\"button\\\" tabindex=\\\"0\\\" (click)=\\\"nextYearList($event)\\\">\\n    <span class=\\\"owl-dt-control-button-content\\\" tabindex=\\\"-1\\\">\\n        <!-- <editor-fold desc=\\\"SVG Arrow Right\\\"> -->\\n    <svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\"\\n             viewBox=\\\"0 0 250.738 250.738\\\" style=\\\"enable-background:new 0 0 250.738 250.738;\\\" xml:space=\\\"preserve\\\">\\n            <path style=\\\"fill-rule:evenodd;clip-rule:evenodd;\\\" d=\\\"M191.75,111.689L84.766,5.291c-7.1-7.055-18.613-7.055-25.713,0\\n                c-7.101,7.054-7.101,18.49,0,25.544l95.053,94.534l-95.053,94.533c-7.101,7.054-7.101,18.491,0,25.545\\n                c7.1,7.054,18.613,7.054,25.713,0L191.75,139.05c3.784-3.759,5.487-8.759,5.238-13.681\\n                C197.237,120.447,195.534,115.448,191.75,111.689z\\\"/>\\n        </svg>\\n        <!-- </editor-fold> -->\\n    </span>\\n</button>\\n\"\n    }]\n  }], () => [{\n    type: i0.ChangeDetectorRef\n  }, {\n    type: OwlDateTimeIntl\n  }, {\n    type: DateTimeAdapter,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [OptionsTokens.multiYear]\n    }]\n  }], {\n    selectMode: [{\n      type: Input\n    }],\n    selected: [{\n      type: Input\n    }],\n    selecteds: [{\n      type: Input\n    }],\n    pickerMoment: [{\n      type: Input\n    }],\n    dateFilter: [{\n      type: Input\n    }],\n    minDate: [{\n      type: Input\n    }],\n    maxDate: [{\n      type: Input\n    }],\n    change: [{\n      type: Output\n    }],\n    yearSelected: [{\n      type: Output\n    }],\n    pickerMomentChange: [{\n      type: Output\n    }],\n    keyboardEnter: [{\n      type: Output\n    }],\n    calendarBodyElm: [{\n      type: ViewChild,\n      args: [OwlCalendarBodyComponent, {\n        static: true\n      }]\n    }]\n  });\n})();\n\n/**\n * calendar-year-view.component\n */\nconst MONTHS_PER_YEAR = 12;\nconst MONTHS_PER_ROW = 3;\nclass OwlYearViewComponent {\n  get selectMode() {\n    return this._selectMode;\n  }\n  set selectMode(val) {\n    this._selectMode = val;\n    if (this.initiated) {\n      this.generateMonthList();\n      this.cdRef.markForCheck();\n    }\n  }\n  get selected() {\n    return this._selected;\n  }\n  set selected(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this._selected = this.getValidDate(value);\n    this.setSelectedMonths();\n  }\n  get selecteds() {\n    return this._selecteds;\n  }\n  set selecteds(values) {\n    this._selecteds = [];\n    for (let i = 0; i < values.length; i++) {\n      const value = this.dateTimeAdapter.deserialize(values[i]);\n      this._selecteds.push(this.getValidDate(value));\n    }\n    this.setSelectedMonths();\n  }\n  get pickerMoment() {\n    return this._pickerMoment;\n  }\n  set pickerMoment(value) {\n    const oldMoment = this._pickerMoment;\n    value = this.dateTimeAdapter.deserialize(value);\n    this._pickerMoment = this.getValidDate(value) || this.dateTimeAdapter.now();\n    if (!this.hasSameYear(oldMoment, this._pickerMoment) && this.initiated) {\n      this.generateMonthList();\n    }\n  }\n  get dateFilter() {\n    return this._dateFilter;\n  }\n  set dateFilter(filter) {\n    this._dateFilter = filter;\n    if (this.initiated) {\n      this.generateMonthList();\n    }\n  }\n  get minDate() {\n    return this._minDate;\n  }\n  set minDate(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this._minDate = this.getValidDate(value);\n    if (this.initiated) {\n      this.generateMonthList();\n    }\n  }\n  get maxDate() {\n    return this._maxDate;\n  }\n  set maxDate(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this._maxDate = this.getValidDate(value);\n    if (this.initiated) {\n      this.generateMonthList();\n    }\n  }\n  get months() {\n    return this._months;\n  }\n  get activeCell() {\n    if (this._pickerMoment) {\n      return this.dateTimeAdapter.getMonth(this._pickerMoment);\n    }\n  }\n  get isInSingleMode() {\n    return this.selectMode === 'single';\n  }\n  get isInRangeMode() {\n    return this.selectMode === 'range' || this.selectMode === 'rangeFrom' || this.selectMode === 'rangeTo';\n  }\n  get owlDTCalendarView() {\n    return true;\n  }\n  constructor(cdRef, dateTimeAdapter, dateTimeFormats) {\n    this.cdRef = cdRef;\n    this.dateTimeAdapter = dateTimeAdapter;\n    this.dateTimeFormats = dateTimeFormats;\n    /**\n     * The select mode of the picker;\n     * */\n    this._selectMode = 'single';\n    this._selecteds = [];\n    this.localeSub = Subscription.EMPTY;\n    this.initiated = false;\n    /**\n     * An array to hold all selectedDates' month value\n     * the value is the month number in current year\n     * */\n    this.selectedMonths = [];\n    /**\n     * Callback to invoke when a new month is selected\n     * */\n    this.change = new EventEmitter();\n    /**\n     * Emits the selected year. This doesn't imply a change on the selected date\n     * */\n    this.monthSelected = new EventEmitter();\n    /** Emits when any date is activated. */\n    this.pickerMomentChange = new EventEmitter();\n    /** Emits when use keyboard enter to select a calendar cell */\n    this.keyboardEnter = new EventEmitter();\n    this.monthNames = this.dateTimeAdapter.getMonthNames('short');\n  }\n  ngOnInit() {\n    this.localeSub = this.dateTimeAdapter.localeChanges.subscribe(() => {\n      this.generateMonthList();\n      this.cdRef.markForCheck();\n    });\n  }\n  ngAfterContentInit() {\n    this.generateMonthList();\n    this.initiated = true;\n  }\n  ngOnDestroy() {\n    this.localeSub.unsubscribe();\n  }\n  /**\n   * Handle a calendarCell selected\n   */\n  selectCalendarCell(cell) {\n    this.selectMonth(cell.value);\n  }\n  /**\n   * Handle a new month selected\n   */\n  selectMonth(month) {\n    const firstDateOfMonth = this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(this.pickerMoment), month, 1);\n    this.monthSelected.emit(firstDateOfMonth);\n    const daysInMonth = this.dateTimeAdapter.getNumDaysInMonth(firstDateOfMonth);\n    const result = this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(this.pickerMoment), month, Math.min(daysInMonth, this.dateTimeAdapter.getDate(this.pickerMoment)), this.dateTimeAdapter.getHours(this.pickerMoment), this.dateTimeAdapter.getMinutes(this.pickerMoment), this.dateTimeAdapter.getSeconds(this.pickerMoment));\n    this.change.emit(result);\n  }\n  /**\n   * Handle keydown event on calendar body\n   */\n  handleCalendarKeydown(event) {\n    let moment;\n    switch (event.keyCode) {\n      // minus 1 month\n      case LEFT_ARROW:\n        moment = this.dateTimeAdapter.addCalendarMonths(this.pickerMoment, -1);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // add 1 month\n      case RIGHT_ARROW:\n        moment = this.dateTimeAdapter.addCalendarMonths(this.pickerMoment, 1);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // minus 3 months\n      case UP_ARROW:\n        moment = this.dateTimeAdapter.addCalendarMonths(this.pickerMoment, -3);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // add 3 months\n      case DOWN_ARROW:\n        moment = this.dateTimeAdapter.addCalendarMonths(this.pickerMoment, 3);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // move to first month of current year\n      case HOME:\n        moment = this.dateTimeAdapter.addCalendarMonths(this.pickerMoment, -this.dateTimeAdapter.getMonth(this.pickerMoment));\n        this.pickerMomentChange.emit(moment);\n        break;\n      // move to last month of current year\n      case END:\n        moment = this.dateTimeAdapter.addCalendarMonths(this.pickerMoment, 11 - this.dateTimeAdapter.getMonth(this.pickerMoment));\n        this.pickerMomentChange.emit(moment);\n        break;\n      // minus 1 year (or 10 year)\n      case PAGE_UP:\n        moment = this.dateTimeAdapter.addCalendarYears(this.pickerMoment, event.altKey ? -10 : -1);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // add 1 year (or 10 year)\n      case PAGE_DOWN:\n        moment = this.dateTimeAdapter.addCalendarYears(this.pickerMoment, event.altKey ? 10 : 1);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // Select current month\n      case ENTER:\n        this.selectMonth(this.dateTimeAdapter.getMonth(this.pickerMoment));\n        this.keyboardEnter.emit();\n        break;\n      default:\n        return;\n    }\n    this.focusActiveCell();\n    event.preventDefault();\n  }\n  /**\n   * Generate the calendar month list\n   * */\n  generateMonthList() {\n    if (!this.pickerMoment) {\n      return;\n    }\n    this.setSelectedMonths();\n    this.todayMonth = this.getMonthInCurrentYear(this.dateTimeAdapter.now());\n    this._months = [];\n    for (let i = 0; i < MONTHS_PER_YEAR / MONTHS_PER_ROW; i++) {\n      const row = [];\n      for (let j = 0; j < MONTHS_PER_ROW; j++) {\n        const month = j + i * MONTHS_PER_ROW;\n        const monthCell = this.createMonthCell(month);\n        row.push(monthCell);\n      }\n      this._months.push(row);\n    }\n    return;\n  }\n  /**\n   * Creates an CalendarCell for the given month.\n   */\n  createMonthCell(month) {\n    const startDateOfMonth = this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(this.pickerMoment), month, 1);\n    const ariaLabel = this.dateTimeAdapter.format(startDateOfMonth, this.dateTimeFormats.monthYearA11yLabel);\n    const cellClass = 'owl-dt-month-' + month;\n    return new CalendarCell(month, this.monthNames[month], ariaLabel, this.isMonthEnabled(month), false, cellClass);\n  }\n  /**\n   * Check if the given month is enable\n   */\n  isMonthEnabled(month) {\n    const firstDateOfMonth = this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(this.pickerMoment), month, 1);\n    // If any date in the month is selectable,\n    // we count the month as enable\n    for (let date = firstDateOfMonth; this.dateTimeAdapter.getMonth(date) === month; date = this.dateTimeAdapter.addCalendarDays(date, 1)) {\n      if (!!date && (!this.dateFilter || this.dateFilter(date)) && (!this.minDate || this.dateTimeAdapter.compare(date, this.minDate) >= 0) && (!this.maxDate || this.dateTimeAdapter.compare(date, this.maxDate) <= 0)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Gets the month in this year that the given Date falls on.\n   * Returns null if the given Date is in another year.\n   */\n  getMonthInCurrentYear(date) {\n    if (this.getValidDate(date) && this.getValidDate(this._pickerMoment)) {\n      const result = this.dateTimeAdapter.compareYear(date, this._pickerMoment);\n      // < 0 : the given date's year is before pickerMoment's year, we return -1 as selected month value.\n      // > 0 : the given date's year is after pickerMoment's year, we return 12 as selected month value.\n      // 0 : the give date's year is same as the pickerMoment's year, we return the actual month value.\n      if (result < 0) {\n        return -1;\n      } else if (result > 0) {\n        return 12;\n      } else {\n        return this.dateTimeAdapter.getMonth(date);\n      }\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Set the selectedMonths value\n   * In single mode, it has only one value which represent the month the selected date in\n   * In range mode, it would has two values, one for the month the fromValue in and the other for the month the toValue in\n   * */\n  setSelectedMonths() {\n    this.selectedMonths = [];\n    if (this.isInSingleMode && this.selected) {\n      this.selectedMonths[0] = this.getMonthInCurrentYear(this.selected);\n    }\n    if (this.isInRangeMode && this.selecteds) {\n      this.selectedMonths[0] = this.getMonthInCurrentYear(this.selecteds[0]);\n      this.selectedMonths[1] = this.getMonthInCurrentYear(this.selecteds[1]);\n    }\n  }\n  /**\n   * Check the given dates are in the same year\n   */\n  hasSameYear(dateLeft, dateRight) {\n    return !!(dateLeft && dateRight && this.dateTimeAdapter.getYear(dateLeft) === this.dateTimeAdapter.getYear(dateRight));\n  }\n  /**\n   * Get a valid date object\n   */\n  getValidDate(obj) {\n    return this.dateTimeAdapter.isDateInstance(obj) && this.dateTimeAdapter.isValid(obj) ? obj : null;\n  }\n  focusActiveCell() {\n    this.calendarBodyElm.focusActiveCell();\n  }\n  static #_ = this.ɵfac = function OwlYearViewComponent_Factory(t) {\n    return new (t || OwlYearViewComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(DateTimeAdapter, 8), i0.ɵɵdirectiveInject(OWL_DATE_TIME_FORMATS, 8));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OwlYearViewComponent,\n    selectors: [[\"owl-date-time-year-view\"]],\n    viewQuery: function OwlYearViewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(OwlCalendarBodyComponent, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calendarBodyElm = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function OwlYearViewComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"owl-dt-calendar-view\", ctx.owlDTCalendarView);\n      }\n    },\n    inputs: {\n      selectMode: \"selectMode\",\n      selected: \"selected\",\n      selecteds: \"selecteds\",\n      pickerMoment: \"pickerMoment\",\n      dateFilter: \"dateFilter\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\"\n    },\n    outputs: {\n      change: \"change\",\n      monthSelected: \"monthSelected\",\n      pickerMomentChange: \"pickerMomentChange\",\n      keyboardEnter: \"keyboardEnter\"\n    },\n    exportAs: [\"owlMonthView\"],\n    decls: 5,\n    vars: 7,\n    consts: [[1, \"owl-dt-calendar-table\", \"owl-dt-calendar-year-table\"], [1, \"owl-dt-calendar-header\"], [\"aria-hidden\", \"true\", \"colspan\", \"3\", 1, \"owl-dt-calendar-table-divider\"], [\"owl-date-time-calendar-body\", \"\", \"role\", \"grid\", 3, \"keydown\", \"select\", \"rows\", \"numCols\", \"cellRatio\", \"activeCell\", \"todayValue\", \"selectedValues\", \"selectMode\"]],\n    template: function OwlYearViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"table\", 0)(1, \"thead\", 1)(2, \"tr\");\n        i0.ɵɵelement(3, \"th\", 2);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(4, \"tbody\", 3);\n        i0.ɵɵlistener(\"keydown\", function OwlYearViewComponent_Template_tbody_keydown_4_listener($event) {\n          return ctx.handleCalendarKeydown($event);\n        })(\"select\", function OwlYearViewComponent_Template_tbody_select_4_listener($event) {\n          return ctx.selectCalendarCell($event);\n        });\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"rows\", ctx.months)(\"numCols\", 3)(\"cellRatio\", 3 / 7)(\"activeCell\", ctx.activeCell)(\"todayValue\", ctx.todayMonth)(\"selectedValues\", ctx.selectedMonths)(\"selectMode\", ctx.selectMode);\n      }\n    },\n    dependencies: [OwlCalendarBodyComponent],\n    changeDetection: 0\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlYearViewComponent, [{\n    type: Component,\n    args: [{\n      selector: 'owl-date-time-year-view',\n      exportAs: 'owlMonthView',\n      host: {\n        '[class.owl-dt-calendar-view]': 'owlDTCalendarView'\n      },\n      preserveWhitespaces: false,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: \"<table class=\\\"owl-dt-calendar-table owl-dt-calendar-year-table\\\">\\n    <thead class=\\\"owl-dt-calendar-header\\\">\\n    <tr>\\n        <th class=\\\"owl-dt-calendar-table-divider\\\" aria-hidden=\\\"true\\\" colspan=\\\"3\\\"></th>\\n    </tr>\\n    </thead>\\n    <tbody owl-date-time-calendar-body role=\\\"grid\\\"\\n           [rows]=\\\"months\\\" [numCols]=\\\"3\\\" [cellRatio]=\\\"3 / 7\\\"\\n           [activeCell]=\\\"activeCell\\\"\\n           [todayValue]=\\\"todayMonth\\\"\\n           [selectedValues]=\\\"selectedMonths\\\"\\n           [selectMode]=\\\"selectMode\\\"\\n           (keydown)=\\\"handleCalendarKeydown($event)\\\"\\n           (select)=\\\"selectCalendarCell($event)\\\">\\n    </tbody>\\n</table>\\n\"\n    }]\n  }], () => [{\n    type: i0.ChangeDetectorRef\n  }, {\n    type: DateTimeAdapter,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [OWL_DATE_TIME_FORMATS]\n    }]\n  }], {\n    selectMode: [{\n      type: Input\n    }],\n    selected: [{\n      type: Input\n    }],\n    selecteds: [{\n      type: Input\n    }],\n    pickerMoment: [{\n      type: Input\n    }],\n    dateFilter: [{\n      type: Input\n    }],\n    minDate: [{\n      type: Input\n    }],\n    maxDate: [{\n      type: Input\n    }],\n    change: [{\n      type: Output\n    }],\n    monthSelected: [{\n      type: Output\n    }],\n    pickerMomentChange: [{\n      type: Output\n    }],\n    keyboardEnter: [{\n      type: Output\n    }],\n    calendarBodyElm: [{\n      type: ViewChild,\n      args: [OwlCalendarBodyComponent, {\n        static: true\n      }]\n    }]\n  });\n})();\n\n/**\n * calendar-month-view.component\n */\nconst DAYS_PER_WEEK = 7;\nconst WEEKS_PER_VIEW = 6;\nclass OwlMonthViewComponent {\n  get firstDayOfWeek() {\n    return this._firstDayOfWeek;\n  }\n  set firstDayOfWeek(val) {\n    if (val >= 0 && val <= 6 && val !== this._firstDayOfWeek) {\n      this._firstDayOfWeek = val;\n      this.isDefaultFirstDayOfWeek = false;\n      if (this.initiated) {\n        this.generateWeekDays();\n        this.generateCalendar();\n        this.cdRef.markForCheck();\n      }\n    }\n  }\n  get selectMode() {\n    return this._selectMode;\n  }\n  set selectMode(val) {\n    this._selectMode = val;\n    if (this.initiated) {\n      this.generateCalendar();\n      this.cdRef.markForCheck();\n    }\n  }\n  get selected() {\n    return this._selected;\n  }\n  set selected(value) {\n    const oldSelected = this._selected;\n    value = this.dateTimeAdapter.deserialize(value);\n    this._selected = this.getValidDate(value);\n    if (!this.dateTimeAdapter.isSameDay(oldSelected, this._selected)) {\n      this.setSelectedDates();\n    }\n  }\n  get selecteds() {\n    return this._selecteds;\n  }\n  set selecteds(values) {\n    this._selecteds = values.map(v => {\n      v = this.dateTimeAdapter.deserialize(v);\n      return this.getValidDate(v);\n    });\n    this.setSelectedDates();\n  }\n  get pickerMoment() {\n    return this._pickerMoment;\n  }\n  set pickerMoment(value) {\n    const oldMoment = this._pickerMoment;\n    value = this.dateTimeAdapter.deserialize(value);\n    this._pickerMoment = this.getValidDate(value) || this.dateTimeAdapter.now();\n    this.firstDateOfMonth = this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(this._pickerMoment), this.dateTimeAdapter.getMonth(this._pickerMoment), 1);\n    if (!this.isSameMonth(oldMoment, this._pickerMoment) && this.initiated) {\n      this.generateCalendar();\n    }\n  }\n  get dateFilter() {\n    return this._dateFilter;\n  }\n  set dateFilter(filter) {\n    this._dateFilter = filter;\n    if (this.initiated) {\n      this.generateCalendar();\n      this.cdRef.markForCheck();\n    }\n  }\n  get minDate() {\n    return this._minDate;\n  }\n  set minDate(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this._minDate = this.getValidDate(value);\n    if (this.initiated) {\n      this.generateCalendar();\n      this.cdRef.markForCheck();\n    }\n  }\n  get maxDate() {\n    return this._maxDate;\n  }\n  set maxDate(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this._maxDate = this.getValidDate(value);\n    if (this.initiated) {\n      this.generateCalendar();\n      this.cdRef.markForCheck();\n    }\n  }\n  get weekdays() {\n    return this._weekdays;\n  }\n  get days() {\n    return this._days;\n  }\n  get activeCell() {\n    if (this.pickerMoment) {\n      return this.dateTimeAdapter.getDate(this.pickerMoment) + this.firstRowOffset - 1;\n    }\n  }\n  get isInSingleMode() {\n    return this.selectMode === 'single';\n  }\n  get isInRangeMode() {\n    return this.selectMode === 'range' || this.selectMode === 'rangeFrom' || this.selectMode === 'rangeTo';\n  }\n  get owlDTCalendarView() {\n    return true;\n  }\n  constructor(cdRef, dateTimeAdapter, dateTimeFormats) {\n    this.cdRef = cdRef;\n    this.dateTimeAdapter = dateTimeAdapter;\n    this.dateTimeFormats = dateTimeFormats;\n    /**\n     * Whether to hide dates in other months at the start or end of the current month.\n     * */\n    this.hideOtherMonths = false;\n    this.isDefaultFirstDayOfWeek = true;\n    /**\n     * The select mode of the picker;\n     * */\n    this._selectMode = 'single';\n    this._selecteds = [];\n    this.localeSub = Subscription.EMPTY;\n    this.initiated = false;\n    /**\n     * An array to hold all selectedDates' value\n     * the value is the day number in current month\n     * */\n    this.selectedDates = [];\n    /**\n     * Callback to invoke when a new date is selected\n     * */\n    this.selectedChange = new EventEmitter();\n    /**\n     * Callback to invoke when any date is selected.\n     * */\n    this.userSelection = new EventEmitter();\n    /** Emits when any date is activated. */\n    this.pickerMomentChange = new EventEmitter();\n  }\n  ngOnInit() {\n    this.updateFirstDayOfWeek(this.dateTimeAdapter.getLocale());\n    this.generateWeekDays();\n    this.localeSub = this.dateTimeAdapter.localeChanges.subscribe(locale => {\n      this.updateFirstDayOfWeek(locale);\n      this.generateWeekDays();\n      this.generateCalendar();\n      this.cdRef.markForCheck();\n    });\n  }\n  ngAfterContentInit() {\n    this.generateCalendar();\n    this.initiated = true;\n  }\n  ngOnDestroy() {\n    this.localeSub.unsubscribe();\n  }\n  /**\n   * Handle a calendarCell selected\n   */\n  selectCalendarCell(cell) {\n    // Cases in which the date would not be selected\n    // 1, the calendar cell is NOT enabled (is NOT valid)\n    // 2, the selected date is NOT in current picker's month and the hideOtherMonths is enabled\n    if (!cell.enabled || this.hideOtherMonths && cell.out) {\n      return;\n    }\n    this.selectDate(cell.value);\n  }\n  /**\n   * Handle a new date selected\n   */\n  selectDate(date) {\n    const daysDiff = date - 1;\n    const selected = this.dateTimeAdapter.addCalendarDays(this.firstDateOfMonth, daysDiff);\n    this.selectedChange.emit(selected);\n    this.userSelection.emit();\n  }\n  /**\n   * Handle keydown event on calendar body\n   */\n  handleCalendarKeydown(event) {\n    let moment;\n    switch (event.keyCode) {\n      // minus 1 day\n      case LEFT_ARROW:\n        moment = this.dateTimeAdapter.addCalendarDays(this.pickerMoment, -1);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // add 1 day\n      case RIGHT_ARROW:\n        moment = this.dateTimeAdapter.addCalendarDays(this.pickerMoment, 1);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // minus 1 week\n      case UP_ARROW:\n        moment = this.dateTimeAdapter.addCalendarDays(this.pickerMoment, -7);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // add 1 week\n      case DOWN_ARROW:\n        moment = this.dateTimeAdapter.addCalendarDays(this.pickerMoment, 7);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // move to first day of current month\n      case HOME:\n        moment = this.dateTimeAdapter.addCalendarDays(this.pickerMoment, 1 - this.dateTimeAdapter.getDate(this.pickerMoment));\n        this.pickerMomentChange.emit(moment);\n        break;\n      // move to last day of current month\n      case END:\n        moment = this.dateTimeAdapter.addCalendarDays(this.pickerMoment, this.dateTimeAdapter.getNumDaysInMonth(this.pickerMoment) - this.dateTimeAdapter.getDate(this.pickerMoment));\n        this.pickerMomentChange.emit(moment);\n        break;\n      // minus 1 month (or 1 year)\n      case PAGE_UP:\n        moment = event.altKey ? this.dateTimeAdapter.addCalendarYears(this.pickerMoment, -1) : this.dateTimeAdapter.addCalendarMonths(this.pickerMoment, -1);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // add 1 month (or 1 year)\n      case PAGE_DOWN:\n        moment = event.altKey ? this.dateTimeAdapter.addCalendarYears(this.pickerMoment, 1) : this.dateTimeAdapter.addCalendarMonths(this.pickerMoment, 1);\n        this.pickerMomentChange.emit(moment);\n        break;\n      // select the pickerMoment\n      case ENTER:\n        if (!this.dateFilter || this.dateFilter(this.pickerMoment)) {\n          this.selectDate(this.dateTimeAdapter.getDate(this.pickerMoment));\n        }\n        break;\n      default:\n        return;\n    }\n    this.focusActiveCell();\n    event.preventDefault();\n  }\n  /**\n   * Generate the calendar weekdays array\n   * */\n  generateWeekDays() {\n    const longWeekdays = this.dateTimeAdapter.getDayOfWeekNames('long');\n    const shortWeekdays = this.dateTimeAdapter.getDayOfWeekNames('short');\n    const narrowWeekdays = this.dateTimeAdapter.getDayOfWeekNames('narrow');\n    const firstDayOfWeek = this.firstDayOfWeek;\n    const weekdays = longWeekdays.map((long, i) => {\n      return {\n        long,\n        short: shortWeekdays[i],\n        narrow: narrowWeekdays[i]\n      };\n    });\n    this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));\n    this.dateNames = this.dateTimeAdapter.getDateNames();\n    return;\n  }\n  /**\n   * Generate the calendar days array\n   * */\n  generateCalendar() {\n    if (!this.pickerMoment) {\n      return;\n    }\n    this.todayDate = null;\n    // the first weekday of the month\n    const startWeekdayOfMonth = this.dateTimeAdapter.getDay(this.firstDateOfMonth);\n    const firstDayOfWeek = this.firstDayOfWeek;\n    // the amount of days from the first date of the month\n    // if it is < 0, it means the date is in previous month\n    let daysDiff = 0 - (startWeekdayOfMonth + (DAYS_PER_WEEK - firstDayOfWeek)) % DAYS_PER_WEEK;\n    // the index of cell that contains the first date of the month\n    this.firstRowOffset = Math.abs(daysDiff);\n    this._days = [];\n    for (let i = 0; i < WEEKS_PER_VIEW; i++) {\n      const week = [];\n      for (let j = 0; j < DAYS_PER_WEEK; j++) {\n        const date = this.dateTimeAdapter.addCalendarDays(this.firstDateOfMonth, daysDiff);\n        const dateCell = this.createDateCell(date, daysDiff);\n        // check if the date is today\n        if (this.dateTimeAdapter.isSameDay(this.dateTimeAdapter.now(), date)) {\n          this.todayDate = daysDiff + 1;\n        }\n        week.push(dateCell);\n        daysDiff += 1;\n      }\n      this._days.push(week);\n    }\n    this.setSelectedDates();\n  }\n  updateFirstDayOfWeek(locale) {\n    if (this.isDefaultFirstDayOfWeek) {\n      try {\n        this._firstDayOfWeek = getLocaleFirstDayOfWeek(locale);\n      } catch {\n        this._firstDayOfWeek = 0;\n      }\n    }\n  }\n  /**\n   * Creates CalendarCell for days.\n   */\n  createDateCell(date, daysDiff) {\n    // total days of the month\n    const daysInMonth = this.dateTimeAdapter.getNumDaysInMonth(this.pickerMoment);\n    const dateNum = this.dateTimeAdapter.getDate(date);\n    // const dateName = this.dateNames[dateNum - 1];\n    const dateName = dateNum.toString();\n    const ariaLabel = this.dateTimeAdapter.format(date, this.dateTimeFormats.dateA11yLabel);\n    // check if the date if selectable\n    const enabled = this.isDateEnabled(date);\n    // check if date is not in current month\n    const dayValue = daysDiff + 1;\n    const out = dayValue < 1 || dayValue > daysInMonth;\n    const cellClass = 'owl-dt-day-' + this.dateTimeAdapter.getDay(date);\n    return new CalendarCell(dayValue, dateName, ariaLabel, enabled, out, cellClass);\n  }\n  /**\n   * Check if the date is valid\n   */\n  isDateEnabled(date) {\n    return !!date && (!this.dateFilter || this.dateFilter(date)) && (!this.minDate || this.dateTimeAdapter.compare(date, this.minDate) >= 0) && (!this.maxDate || this.dateTimeAdapter.compare(date, this.maxDate) <= 0);\n  }\n  /**\n   * Get a valid date object\n   */\n  getValidDate(obj) {\n    return this.dateTimeAdapter.isDateInstance(obj) && this.dateTimeAdapter.isValid(obj) ? obj : null;\n  }\n  /**\n   * Check if the give dates are none-null and in the same month\n   */\n  isSameMonth(dateLeft, dateRight) {\n    return !!(dateLeft && dateRight && this.dateTimeAdapter.isValid(dateLeft) && this.dateTimeAdapter.isValid(dateRight) && this.dateTimeAdapter.getYear(dateLeft) === this.dateTimeAdapter.getYear(dateRight) && this.dateTimeAdapter.getMonth(dateLeft) === this.dateTimeAdapter.getMonth(dateRight));\n  }\n  /**\n   * Set the selectedDates value.\n   * In single mode, it has only one value which represent the selected date\n   * In range mode, it would has two values, one for the fromValue and the other for the toValue\n   * */\n  setSelectedDates() {\n    this.selectedDates = [];\n    if (!this.firstDateOfMonth) {\n      return;\n    }\n    if (this.isInSingleMode && this.selected) {\n      const dayDiff = this.dateTimeAdapter.differenceInCalendarDays(this.selected, this.firstDateOfMonth);\n      this.selectedDates[0] = dayDiff + 1;\n      return;\n    }\n    if (this.isInRangeMode && this.selecteds) {\n      this.selectedDates = this.selecteds.map(selected => {\n        if (this.dateTimeAdapter.isValid(selected)) {\n          const dayDiff = this.dateTimeAdapter.differenceInCalendarDays(selected, this.firstDateOfMonth);\n          return dayDiff + 1;\n        } else {\n          return null;\n        }\n      });\n    }\n  }\n  focusActiveCell() {\n    this.calendarBodyElm.focusActiveCell();\n  }\n  static #_ = this.ɵfac = function OwlMonthViewComponent_Factory(t) {\n    return new (t || OwlMonthViewComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(DateTimeAdapter, 8), i0.ɵɵdirectiveInject(OWL_DATE_TIME_FORMATS, 8));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OwlMonthViewComponent,\n    selectors: [[\"owl-date-time-month-view\"]],\n    viewQuery: function OwlMonthViewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(OwlCalendarBodyComponent, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calendarBodyElm = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function OwlMonthViewComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"owl-dt-calendar-view\", ctx.owlDTCalendarView);\n      }\n    },\n    inputs: {\n      hideOtherMonths: \"hideOtherMonths\",\n      firstDayOfWeek: \"firstDayOfWeek\",\n      selectMode: \"selectMode\",\n      selected: \"selected\",\n      selecteds: \"selecteds\",\n      pickerMoment: \"pickerMoment\",\n      dateFilter: \"dateFilter\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      userSelection: \"userSelection\",\n      pickerMomentChange: \"pickerMomentChange\"\n    },\n    exportAs: [\"owlYearView\"],\n    decls: 7,\n    vars: 8,\n    consts: [[1, \"owl-dt-calendar-table\", \"owl-dt-calendar-month-table\"], [1, \"owl-dt-calendar-header\"], [1, \"owl-dt-weekdays\"], [\"class\", \"owl-dt-weekday\", \"scope\", \"col\", 4, \"ngFor\", \"ngForOf\"], [\"aria-hidden\", \"true\", \"colspan\", \"7\", 1, \"owl-dt-calendar-table-divider\"], [\"owl-date-time-calendar-body\", \"\", \"role\", \"grid\", 3, \"keydown\", \"select\", \"rows\", \"todayValue\", \"selectedValues\", \"selectMode\", \"activeCell\"], [\"scope\", \"col\", 1, \"owl-dt-weekday\"]],\n    template: function OwlMonthViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"table\", 0)(1, \"thead\", 1)(2, \"tr\", 2);\n        i0.ɵɵtemplate(3, OwlMonthViewComponent_th_3_Template, 3, 2, \"th\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"tr\");\n        i0.ɵɵelement(5, \"th\", 4);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(6, \"tbody\", 5);\n        i0.ɵɵlistener(\"keydown\", function OwlMonthViewComponent_Template_tbody_keydown_6_listener($event) {\n          return ctx.handleCalendarKeydown($event);\n        })(\"select\", function OwlMonthViewComponent_Template_tbody_select_6_listener($event) {\n          return ctx.selectCalendarCell($event);\n        });\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"owl-dt-calendar-only-current-month\", ctx.hideOtherMonths);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx.weekdays);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"rows\", ctx.days)(\"todayValue\", ctx.todayDate)(\"selectedValues\", ctx.selectedDates)(\"selectMode\", ctx.selectMode)(\"activeCell\", ctx.activeCell);\n      }\n    },\n    dependencies: [i3.NgForOf, OwlCalendarBodyComponent],\n    changeDetection: 0\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlMonthViewComponent, [{\n    type: Component,\n    args: [{\n      selector: 'owl-date-time-month-view',\n      exportAs: 'owlYearView',\n      host: {\n        '[class.owl-dt-calendar-view]': 'owlDTCalendarView'\n      },\n      preserveWhitespaces: false,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: \"<table class=\\\"owl-dt-calendar-table owl-dt-calendar-month-table\\\"\\n       [class.owl-dt-calendar-only-current-month]=\\\"hideOtherMonths\\\">\\n    <thead class=\\\"owl-dt-calendar-header\\\">\\n    <tr class=\\\"owl-dt-weekdays\\\">\\n        <th *ngFor=\\\"let weekday of weekdays\\\"\\n            [attr.aria-label]=\\\"weekday.long\\\"\\n            class=\\\"owl-dt-weekday\\\" scope=\\\"col\\\">\\n            <span>{{weekday.short}}</span>\\n        </th>\\n    </tr>\\n    <tr>\\n        <th class=\\\"owl-dt-calendar-table-divider\\\" aria-hidden=\\\"true\\\" colspan=\\\"7\\\"></th>\\n    </tr>\\n    </thead>\\n    <tbody owl-date-time-calendar-body role=\\\"grid\\\"\\n           [rows]=\\\"days\\\" [todayValue]=\\\"todayDate\\\"\\n           [selectedValues]=\\\"selectedDates\\\"\\n           [selectMode]=\\\"selectMode\\\"\\n           [activeCell]=\\\"activeCell\\\"\\n           (keydown)=\\\"handleCalendarKeydown($event)\\\"\\n           (select)=\\\"selectCalendarCell($event)\\\">\\n    </tbody>\\n</table>\\n\"\n    }]\n  }], () => [{\n    type: i0.ChangeDetectorRef\n  }, {\n    type: DateTimeAdapter,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [OWL_DATE_TIME_FORMATS]\n    }]\n  }], {\n    hideOtherMonths: [{\n      type: Input\n    }],\n    firstDayOfWeek: [{\n      type: Input\n    }],\n    selectMode: [{\n      type: Input\n    }],\n    selected: [{\n      type: Input\n    }],\n    selecteds: [{\n      type: Input\n    }],\n    pickerMoment: [{\n      type: Input\n    }],\n    dateFilter: [{\n      type: Input\n    }],\n    minDate: [{\n      type: Input\n    }],\n    maxDate: [{\n      type: Input\n    }],\n    selectedChange: [{\n      type: Output\n    }],\n    userSelection: [{\n      type: Output\n    }],\n    pickerMomentChange: [{\n      type: Output\n    }],\n    calendarBodyElm: [{\n      type: ViewChild,\n      args: [OwlCalendarBodyComponent, {\n        static: true\n      }]\n    }]\n  });\n})();\n\n/**\n * calendar.component\n */\nclass OwlCalendarComponent {\n  get minDate() {\n    return this._minDate;\n  }\n  set minDate(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    value = this.getValidDate(value);\n    this._minDate = value ? this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(value), this.dateTimeAdapter.getMonth(value), this.dateTimeAdapter.getDate(value)) : null;\n  }\n  get maxDate() {\n    return this._maxDate;\n  }\n  set maxDate(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    value = this.getValidDate(value);\n    this._maxDate = value ? this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(value), this.dateTimeAdapter.getMonth(value), this.dateTimeAdapter.getDate(value)) : null;\n  }\n  get pickerMoment() {\n    return this._pickerMoment;\n  }\n  set pickerMoment(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this._pickerMoment = this.getValidDate(value) || this.dateTimeAdapter.now();\n  }\n  get selected() {\n    return this._selected;\n  }\n  set selected(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this._selected = this.getValidDate(value);\n  }\n  get selecteds() {\n    return this._selecteds;\n  }\n  set selecteds(values) {\n    this._selecteds = values.map(v => {\n      v = this.dateTimeAdapter.deserialize(v);\n      return this.getValidDate(v);\n    });\n  }\n  get periodButtonText() {\n    return this.isMonthView ? this.dateTimeAdapter.format(this.pickerMoment, this.dateTimeFormats.monthYearLabel) : this.dateTimeAdapter.getYearName(this.pickerMoment);\n  }\n  get periodButtonLabel() {\n    return this.isMonthView ? this.pickerIntl.switchToMultiYearViewLabel : this.pickerIntl.switchToMonthViewLabel;\n  }\n  get prevButtonLabel() {\n    if (this._currentView === DateView.MONTH) {\n      return this.pickerIntl.prevMonthLabel;\n    } else if (this._currentView === DateView.YEAR) {\n      return this.pickerIntl.prevYearLabel;\n    } else {\n      return null;\n    }\n  }\n  get nextButtonLabel() {\n    if (this._currentView === DateView.MONTH) {\n      return this.pickerIntl.nextMonthLabel;\n    } else if (this._currentView === DateView.YEAR) {\n      return this.pickerIntl.nextYearLabel;\n    } else {\n      return null;\n    }\n  }\n  get currentView() {\n    return this._currentView;\n  }\n  set currentView(view) {\n    this._currentView = view;\n    this.moveFocusOnNextTick = true;\n  }\n  get isInSingleMode() {\n    return this.selectMode === 'single';\n  }\n  get isInRangeMode() {\n    return this.selectMode === 'range' || this.selectMode === 'rangeFrom' || this.selectMode === 'rangeTo';\n  }\n  get showControlArrows() {\n    return this._currentView !== DateView.MULTI_YEARS;\n  }\n  get isMonthView() {\n    return this._currentView === DateView.MONTH;\n  }\n  /**\n   * Bind class 'owl-dt-calendar' to host\n   * */\n  get owlDTCalendarClass() {\n    return true;\n  }\n  constructor(elmRef, pickerIntl, ngZone, cdRef, dateTimeAdapter, dateTimeFormats) {\n    this.elmRef = elmRef;\n    this.pickerIntl = pickerIntl;\n    this.ngZone = ngZone;\n    this.cdRef = cdRef;\n    this.dateTimeAdapter = dateTimeAdapter;\n    this.dateTimeFormats = dateTimeFormats;\n    this.DateView = DateView;\n    this._selecteds = [];\n    /**\n     * The view that the calendar should start in.\n     */\n    this.startView = DateView.MONTH;\n    /**\n     * Whether to should only the year and multi-year views.\n     */\n    this.yearOnly = false;\n    /**\n     * Whether to should only the multi-year view.\n     */\n    this.multiyearOnly = false;\n    /** Emits when the currently picker moment changes. */\n    this.pickerMomentChange = new EventEmitter();\n    /** Emits when the selected date changes. */\n    this.dateClicked = new EventEmitter();\n    /** Emits when the currently selected date changes. */\n    this.selectedChange = new EventEmitter();\n    /** Emits when any date is selected. */\n    this.userSelection = new EventEmitter();\n    /**\n     * Emits the selected year. This doesn't imply a change on the selected date\n     * */\n    this.yearSelected = new EventEmitter();\n    /**\n     * Emits the selected month. This doesn't imply a change on the selected date\n     * */\n    this.monthSelected = new EventEmitter();\n    this.intlChangesSub = Subscription.EMPTY;\n    /**\n     * Used for scheduling that focus should be moved to the active cell on the next tick.\n     * We need to schedule it, rather than do it immediately, because we have to wait\n     * for Angular to re-evaluate the view children.\n     */\n    this.moveFocusOnNextTick = false;\n    /**\n     * Date filter for the month and year view\n     */\n    this.dateFilterForViews = date => {\n      return !!date && (!this.dateFilter || this.dateFilter(date)) && (!this.minDate || this.dateTimeAdapter.compare(date, this.minDate) >= 0) && (!this.maxDate || this.dateTimeAdapter.compare(date, this.maxDate) <= 0);\n    };\n    this.intlChangesSub = this.pickerIntl.changes.subscribe(() => {\n      this.cdRef.markForCheck();\n    });\n  }\n  ngOnInit() {}\n  ngAfterContentInit() {\n    this._currentView = this.startView;\n  }\n  ngAfterViewChecked() {\n    if (this.moveFocusOnNextTick) {\n      this.moveFocusOnNextTick = false;\n      this.focusActiveCell();\n    }\n  }\n  ngOnDestroy() {\n    this.intlChangesSub.unsubscribe();\n  }\n  /**\n   * Toggle between month view and year view\n   */\n  toggleViews() {\n    let nextView = null;\n    if (this._currentView === DateView.MONTH) {\n      nextView = DateView.MULTI_YEARS;\n    } else {\n      if (this.multiyearOnly) {\n        nextView = DateView.MULTI_YEARS;\n      } else if (this.yearOnly) {\n        nextView = this._currentView === DateView.YEAR ? DateView.MULTI_YEARS : DateView.YEAR;\n      } else {\n        nextView = DateView.MONTH;\n      }\n    }\n    this.currentView = nextView;\n  }\n  /**\n   * Handles user clicks on the previous button.\n   * */\n  previousClicked() {\n    this.pickerMoment = this.isMonthView ? this.dateTimeAdapter.addCalendarMonths(this.pickerMoment, -1) : this.dateTimeAdapter.addCalendarYears(this.pickerMoment, -1);\n    this.pickerMomentChange.emit(this.pickerMoment);\n  }\n  /**\n   * Handles user clicks on the next button.\n   * */\n  nextClicked() {\n    this.pickerMoment = this.isMonthView ? this.dateTimeAdapter.addCalendarMonths(this.pickerMoment, 1) : this.dateTimeAdapter.addCalendarYears(this.pickerMoment, 1);\n    this.pickerMomentChange.emit(this.pickerMoment);\n  }\n  dateSelected(date) {\n    if (!this.dateFilterForViews(date)) {\n      return;\n    }\n    this.dateClicked.emit(date);\n    this.selectedChange.emit(date);\n    /*if ((this.isInSingleMode && !this.dateTimeAdapter.isSameDay(date, this.selected)) ||\n        this.isInRangeMode) {\n        this.selectedChange.emit(date);\n    }*/\n  }\n  /**\n   * Change the pickerMoment value and switch to a specific view\n   */\n  goToDateInView(date, view) {\n    this.handlePickerMomentChange(date);\n    if (!this.yearOnly && !this.multiyearOnly || this.multiyearOnly && view !== DateView.MONTH && view !== DateView.YEAR || this.yearOnly && view !== DateView.MONTH) {\n      this.currentView = view;\n    }\n    return;\n  }\n  /**\n   * Change the pickerMoment value\n   */\n  handlePickerMomentChange(date) {\n    this.pickerMoment = this.dateTimeAdapter.clampDate(date, this.minDate, this.maxDate);\n    this.pickerMomentChange.emit(this.pickerMoment);\n    return;\n  }\n  userSelected() {\n    this.userSelection.emit();\n  }\n  /**\n   * Whether the previous period button is enabled.\n   */\n  prevButtonEnabled() {\n    return !this.minDate || !this.isSameView(this.pickerMoment, this.minDate);\n  }\n  /**\n   * Whether the next period button is enabled.\n   */\n  nextButtonEnabled() {\n    return !this.maxDate || !this.isSameView(this.pickerMoment, this.maxDate);\n  }\n  /**\n   * Focus to the host element\n   * */\n  focusActiveCell() {\n    this.ngZone.runOutsideAngular(() => {\n      this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n        this.elmRef.nativeElement.querySelector('.owl-dt-calendar-cell-active').focus();\n      });\n    });\n  }\n  selectYearInMultiYearView(normalizedYear) {\n    this.yearSelected.emit(normalizedYear);\n  }\n  selectMonthInYearView(normalizedMonth) {\n    this.monthSelected.emit(normalizedMonth);\n  }\n  /**\n   * Whether the two dates represent the same view in the current view mode (month or year).\n   */\n  isSameView(date1, date2) {\n    if (this._currentView === DateView.MONTH) {\n      return !!(date1 && date2 && this.dateTimeAdapter.getYear(date1) === this.dateTimeAdapter.getYear(date2) && this.dateTimeAdapter.getMonth(date1) === this.dateTimeAdapter.getMonth(date2));\n    } else if (this._currentView === DateView.YEAR) {\n      return !!(date1 && date2 && this.dateTimeAdapter.getYear(date1) === this.dateTimeAdapter.getYear(date2));\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Get a valid date object\n   */\n  getValidDate(obj) {\n    return this.dateTimeAdapter.isDateInstance(obj) && this.dateTimeAdapter.isValid(obj) ? obj : null;\n  }\n  static #_ = this.ɵfac = function OwlCalendarComponent_Factory(t) {\n    return new (t || OwlCalendarComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(OwlDateTimeIntl), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(DateTimeAdapter, 8), i0.ɵɵdirectiveInject(OWL_DATE_TIME_FORMATS, 8));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OwlCalendarComponent,\n    selectors: [[\"owl-date-time-calendar\"]],\n    hostVars: 2,\n    hostBindings: function OwlCalendarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"owl-dt-calendar\", ctx.owlDTCalendarClass);\n      }\n    },\n    inputs: {\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      pickerMoment: \"pickerMoment\",\n      selected: \"selected\",\n      selecteds: \"selecteds\",\n      dateFilter: \"dateFilter\",\n      firstDayOfWeek: \"firstDayOfWeek\",\n      selectMode: \"selectMode\",\n      startView: \"startView\",\n      yearOnly: \"yearOnly\",\n      multiyearOnly: \"multiyearOnly\",\n      hideOtherMonths: \"hideOtherMonths\"\n    },\n    outputs: {\n      pickerMomentChange: \"pickerMomentChange\",\n      dateClicked: \"dateClicked\",\n      selectedChange: \"selectedChange\",\n      userSelection: \"userSelection\",\n      yearSelected: \"yearSelected\",\n      monthSelected: \"monthSelected\"\n    },\n    exportAs: [\"owlDateTimeCalendar\"],\n    decls: 21,\n    vars: 16,\n    consts: [[1, \"owl-dt-calendar-control\"], [\"type\", \"button\", \"tabindex\", \"0\", 1, \"owl-dt-control\", \"owl-dt-control-button\", \"owl-dt-control-arrow-button\", 3, \"click\", \"disabled\"], [\"tabindex\", \"-1\", 1, \"owl-dt-control-content\", \"owl-dt-control-button-content\"], [\"xmlns\", \"http://www.w3.org/2000/svg\", 0, \"xmlns\", \"xlink\", \"http://www.w3.org/1999/xlink\", \"version\", \"1.1\", \"x\", \"0px\", \"y\", \"0px\", \"viewBox\", \"0 0 250.738 250.738\", 0, \"xml\", \"space\", \"preserve\", \"width\", \"100%\", \"height\", \"100%\", 2, \"enable-background\", \"new 0 0 250.738 250.738\"], [\"d\", \"M96.633,125.369l95.053-94.533c7.101-7.055,7.101-18.492,0-25.546   c-7.1-7.054-18.613-7.054-25.714,0L58.989,111.689c-3.784,3.759-5.487,8.759-5.238,13.68c-0.249,4.922,1.454,9.921,5.238,13.681   l106.983,106.398c7.101,7.055,18.613,7.055,25.714,0c7.101-7.054,7.101-18.491,0-25.544L96.633,125.369z\", 2, \"fill-rule\", \"evenodd\", \"clip-rule\", \"evenodd\"], [1, \"owl-dt-calendar-control-content\"], [\"type\", \"button\", \"tabindex\", \"0\", 1, \"owl-dt-control\", \"owl-dt-control-button\", \"owl-dt-control-period-button\", 3, \"click\"], [1, \"owl-dt-control-button-arrow\"], [\"version\", \"1.1\", \"xmlns\", \"http://www.w3.org/2000/svg\", 0, \"xmlns\", \"xlink\", \"http://www.w3.org/1999/xlink\", \"x\", \"0px\", \"y\", \"0px\", \"width\", \"50%\", \"height\", \"50%\", \"viewBox\", \"0 0 292.362 292.362\", 0, \"xml\", \"space\", \"preserve\", 2, \"enable-background\", \"new 0 0 292.362 292.362\"], [\"d\", \"M286.935,69.377c-3.614-3.617-7.898-5.424-12.848-5.424H18.274c-4.952,0-9.233,1.807-12.85,5.424\\n                                C1.807,72.998,0,77.279,0,82.228c0,4.948,1.807,9.229,5.424,12.847l127.907,127.907c3.621,3.617,7.902,5.428,12.85,5.428\\n                                s9.233-1.811,12.847-5.428L286.935,95.074c3.613-3.617,5.427-7.898,5.427-12.847C292.362,77.279,290.548,72.998,286.935,69.377z\"], [\"version\", \"1.1\", \"xmlns\", \"http://www.w3.org/2000/svg\", 0, \"xmlns\", \"xlink\", \"http://www.w3.org/1999/xlink\", \"x\", \"0px\", \"y\", \"0px\", \"viewBox\", \"0 0 250.738 250.738\", 0, \"xml\", \"space\", \"preserve\", 2, \"enable-background\", \"new 0 0 250.738 250.738\"], [\"d\", \"M191.75,111.689L84.766,5.291c-7.1-7.055-18.613-7.055-25.713,0\\n                    c-7.101,7.054-7.101,18.49,0,25.544l95.053,94.534l-95.053,94.533c-7.101,7.054-7.101,18.491,0,25.545\\n                    c7.1,7.054,18.613,7.054,25.713,0L191.75,139.05c3.784-3.759,5.487-8.759,5.238-13.681\\n                    C197.237,120.447,195.534,115.448,191.75,111.689z\", 2, \"fill-rule\", \"evenodd\", \"clip-rule\", \"evenodd\"], [\"cdkMonitorSubtreeFocus\", \"\", \"tabindex\", \"-1\", 1, \"owl-dt-calendar-main\", 3, \"ngSwitch\"], [3, \"pickerMoment\", \"firstDayOfWeek\", \"selected\", \"selecteds\", \"selectMode\", \"minDate\", \"maxDate\", \"dateFilter\", \"hideOtherMonths\", \"pickerMomentChange\", \"selectedChange\", \"userSelection\", 4, \"ngSwitchCase\"], [3, \"pickerMoment\", \"selected\", \"selecteds\", \"selectMode\", \"minDate\", \"maxDate\", \"dateFilter\", \"keyboardEnter\", \"pickerMomentChange\", \"monthSelected\", \"change\", 4, \"ngSwitchCase\"], [3, \"pickerMoment\", \"selected\", \"selecteds\", \"selectMode\", \"minDate\", \"maxDate\", \"dateFilter\", \"keyboardEnter\", \"pickerMomentChange\", \"yearSelected\", \"change\", 4, \"ngSwitchCase\"], [3, \"pickerMomentChange\", \"selectedChange\", \"userSelection\", \"pickerMoment\", \"firstDayOfWeek\", \"selected\", \"selecteds\", \"selectMode\", \"minDate\", \"maxDate\", \"dateFilter\", \"hideOtherMonths\"], [3, \"keyboardEnter\", \"pickerMomentChange\", \"monthSelected\", \"change\", \"pickerMoment\", \"selected\", \"selecteds\", \"selectMode\", \"minDate\", \"maxDate\", \"dateFilter\"], [3, \"keyboardEnter\", \"pickerMomentChange\", \"yearSelected\", \"change\", \"pickerMoment\", \"selected\", \"selecteds\", \"selectMode\", \"minDate\", \"maxDate\", \"dateFilter\"]],\n    template: function OwlCalendarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"button\", 1);\n        i0.ɵɵlistener(\"click\", function OwlCalendarComponent_Template_button_click_1_listener() {\n          return ctx.previousClicked();\n        });\n        i0.ɵɵelementStart(2, \"span\", 2);\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(3, \"svg\", 3);\n        i0.ɵɵelement(4, \"path\", 4);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵnamespaceHTML();\n        i0.ɵɵelementStart(5, \"div\", 5)(6, \"button\", 6);\n        i0.ɵɵlistener(\"click\", function OwlCalendarComponent_Template_button_click_6_listener() {\n          return ctx.toggleViews();\n        });\n        i0.ɵɵelementStart(7, \"span\", 2);\n        i0.ɵɵtext(8);\n        i0.ɵɵelementStart(9, \"span\", 7);\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(10, \"svg\", 8)(11, \"g\");\n        i0.ɵɵelement(12, \"path\", 9);\n        i0.ɵɵelementEnd()()()()()();\n        i0.ɵɵnamespaceHTML();\n        i0.ɵɵelementStart(13, \"button\", 1);\n        i0.ɵɵlistener(\"click\", function OwlCalendarComponent_Template_button_click_13_listener() {\n          return ctx.nextClicked();\n        });\n        i0.ɵɵelementStart(14, \"span\", 2);\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(15, \"svg\", 10);\n        i0.ɵɵelement(16, \"path\", 11);\n        i0.ɵɵelementEnd()()()();\n        i0.ɵɵnamespaceHTML();\n        i0.ɵɵelementStart(17, \"div\", 12);\n        i0.ɵɵtemplate(18, OwlCalendarComponent_owl_date_time_month_view_18_Template, 1, 9, \"owl-date-time-month-view\", 13)(19, OwlCalendarComponent_owl_date_time_year_view_19_Template, 1, 7, \"owl-date-time-year-view\", 14)(20, OwlCalendarComponent_owl_date_time_multi_year_view_20_Template, 1, 7, \"owl-date-time-multi-year-view\", 15);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance();\n        i0.ɵɵstyleProp(\"visibility\", ctx.showControlArrows ? \"visible\" : \"hidden\");\n        i0.ɵɵproperty(\"disabled\", !ctx.prevButtonEnabled());\n        i0.ɵɵattribute(\"aria-label\", ctx.prevButtonLabel);\n        i0.ɵɵadvance(5);\n        i0.ɵɵattribute(\"aria-label\", ctx.periodButtonLabel);\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate1(\" \", ctx.periodButtonText, \" \");\n        i0.ɵɵadvance();\n        i0.ɵɵstyleProp(\"transform\", \"rotate(\" + (ctx.isMonthView ? 0 : 180) + \"deg)\");\n        i0.ɵɵadvance(4);\n        i0.ɵɵstyleProp(\"visibility\", ctx.showControlArrows ? \"visible\" : \"hidden\");\n        i0.ɵɵproperty(\"disabled\", !ctx.nextButtonEnabled());\n        i0.ɵɵattribute(\"aria-label\", ctx.nextButtonLabel);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngSwitch\", ctx.currentView);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngSwitchCase\", ctx.DateView.MONTH);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngSwitchCase\", ctx.DateView.YEAR);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngSwitchCase\", ctx.DateView.MULTI_YEARS);\n      }\n    },\n    dependencies: [i3.NgSwitch, i3.NgSwitchCase, i4.CdkMonitorFocus, OwlMultiYearViewComponent, OwlYearViewComponent, OwlMonthViewComponent],\n    changeDetection: 0\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlCalendarComponent, [{\n    type: Component,\n    args: [{\n      selector: 'owl-date-time-calendar',\n      exportAs: 'owlDateTimeCalendar',\n      host: {\n        '[class.owl-dt-calendar]': 'owlDTCalendarClass'\n      },\n      preserveWhitespaces: false,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: \"<div class=\\\"owl-dt-calendar-control\\\">\\n    <!-- focus when keyboard tab (http://kizu.ru/en/blog/keyboard-only-focus/#x) -->\\n    <button class=\\\"owl-dt-control owl-dt-control-button owl-dt-control-arrow-button\\\"\\n            type=\\\"button\\\" tabindex=\\\"0\\\"\\n            [style.visibility]=\\\"showControlArrows? 'visible': 'hidden'\\\"\\n            [disabled]=\\\"!prevButtonEnabled()\\\"\\n            [attr.aria-label]=\\\"prevButtonLabel\\\"\\n            (click)=\\\"previousClicked()\\\">\\n        <span class=\\\"owl-dt-control-content owl-dt-control-button-content\\\" tabindex=\\\"-1\\\">\\n            <!-- <editor-fold desc=\\\"SVG Arrow Left\\\"> -->\\n        <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\\n                 version=\\\"1.1\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 250.738 250.738\\\"\\n                 style=\\\"enable-background:new 0 0 250.738 250.738;\\\" xml:space=\\\"preserve\\\"\\n                 width=\\\"100%\\\" height=\\\"100%\\\">\\n                <path style=\\\"fill-rule: evenodd; clip-rule: evenodd;\\\" d=\\\"M96.633,125.369l95.053-94.533c7.101-7.055,7.101-18.492,0-25.546   c-7.1-7.054-18.613-7.054-25.714,0L58.989,111.689c-3.784,3.759-5.487,8.759-5.238,13.68c-0.249,4.922,1.454,9.921,5.238,13.681   l106.983,106.398c7.101,7.055,18.613,7.055,25.714,0c7.101-7.054,7.101-18.491,0-25.544L96.633,125.369z\\\"/>\\n            </svg>\\n            <!-- </editor-fold> -->\\n        </span>\\n    </button>\\n    <div class=\\\"owl-dt-calendar-control-content\\\">\\n        <button class=\\\"owl-dt-control owl-dt-control-button owl-dt-control-period-button\\\"\\n                type=\\\"button\\\" tabindex=\\\"0\\\"\\n                [attr.aria-label]=\\\"periodButtonLabel\\\"\\n                (click)=\\\"toggleViews()\\\">\\n            <span class=\\\"owl-dt-control-content owl-dt-control-button-content\\\" tabindex=\\\"-1\\\">\\n                {{periodButtonText}}\\n\\n                <span class=\\\"owl-dt-control-button-arrow\\\"\\n                      [style.transform]=\\\"'rotate(' + (isMonthView? 0 : 180) +'deg)'\\\">\\n                    <!-- <editor-fold desc=\\\"SVG Arrow\\\"> -->\\n                    <svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\"\\n                         width=\\\"50%\\\" height=\\\"50%\\\" viewBox=\\\"0 0 292.362 292.362\\\" style=\\\"enable-background:new 0 0 292.362 292.362;\\\"\\n                         xml:space=\\\"preserve\\\">\\n                        <g>\\n                            <path d=\\\"M286.935,69.377c-3.614-3.617-7.898-5.424-12.848-5.424H18.274c-4.952,0-9.233,1.807-12.85,5.424\\n                                C1.807,72.998,0,77.279,0,82.228c0,4.948,1.807,9.229,5.424,12.847l127.907,127.907c3.621,3.617,7.902,5.428,12.85,5.428\\n                                s9.233-1.811,12.847-5.428L286.935,95.074c3.613-3.617,5.427-7.898,5.427-12.847C292.362,77.279,290.548,72.998,286.935,69.377z\\\"/>\\n                        </g>\\n                    </svg>\\n                    <!-- </editor-fold> -->\\n                </span>\\n            </span>\\n        </button>\\n    </div>\\n    <button class=\\\"owl-dt-control owl-dt-control-button owl-dt-control-arrow-button\\\"\\n            type=\\\"button\\\" tabindex=\\\"0\\\"\\n            [style.visibility]=\\\"showControlArrows? 'visible': 'hidden'\\\"\\n            [disabled]=\\\"!nextButtonEnabled()\\\"\\n            [attr.aria-label]=\\\"nextButtonLabel\\\"\\n            (click)=\\\"nextClicked()\\\">\\n        <span class=\\\"owl-dt-control-content owl-dt-control-button-content\\\" tabindex=\\\"-1\\\">\\n            <!-- <editor-fold desc=\\\"SVG Arrow Right\\\"> -->\\n        <svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\"\\n                 viewBox=\\\"0 0 250.738 250.738\\\" style=\\\"enable-background:new 0 0 250.738 250.738;\\\" xml:space=\\\"preserve\\\">\\n                <path style=\\\"fill-rule:evenodd;clip-rule:evenodd;\\\" d=\\\"M191.75,111.689L84.766,5.291c-7.1-7.055-18.613-7.055-25.713,0\\n                    c-7.101,7.054-7.101,18.49,0,25.544l95.053,94.534l-95.053,94.533c-7.101,7.054-7.101,18.491,0,25.545\\n                    c7.1,7.054,18.613,7.054,25.713,0L191.75,139.05c3.784-3.759,5.487-8.759,5.238-13.681\\n                    C197.237,120.447,195.534,115.448,191.75,111.689z\\\"/>\\n            </svg>\\n            <!-- </editor-fold> -->\\n        </span>\\n    </button>\\n</div>\\n<div class=\\\"owl-dt-calendar-main\\\" cdkMonitorSubtreeFocus [ngSwitch]=\\\"currentView\\\" tabindex=\\\"-1\\\">\\n    <owl-date-time-month-view\\n            *ngSwitchCase=\\\"DateView.MONTH\\\"\\n            [pickerMoment]=\\\"pickerMoment\\\"\\n            [firstDayOfWeek]=\\\"firstDayOfWeek\\\"\\n            [selected]=\\\"selected\\\"\\n            [selecteds]=\\\"selecteds\\\"\\n            [selectMode]=\\\"selectMode\\\"\\n            [minDate]=\\\"minDate\\\"\\n            [maxDate]=\\\"maxDate\\\"\\n            [dateFilter]=\\\"dateFilter\\\"\\n            [hideOtherMonths]=\\\"hideOtherMonths\\\"\\n            (pickerMomentChange)=\\\"handlePickerMomentChange($event)\\\"\\n            (selectedChange)=\\\"dateSelected($event)\\\"\\n            (userSelection)=\\\"userSelected()\\\"></owl-date-time-month-view>\\n\\n    <owl-date-time-year-view\\n            *ngSwitchCase=\\\"DateView.YEAR\\\"\\n            [pickerMoment]=\\\"pickerMoment\\\"\\n            [selected]=\\\"selected\\\"\\n            [selecteds]=\\\"selecteds\\\"\\n            [selectMode]=\\\"selectMode\\\"\\n            [minDate]=\\\"minDate\\\"\\n            [maxDate]=\\\"maxDate\\\"\\n            [dateFilter]=\\\"dateFilter\\\"\\n            (keyboardEnter)=\\\"focusActiveCell()\\\"\\n            (pickerMomentChange)=\\\"handlePickerMomentChange($event)\\\"\\n            (monthSelected)=\\\"selectMonthInYearView($event)\\\"\\n            (change)=\\\"goToDateInView($event, DateView.MONTH)\\\"></owl-date-time-year-view>\\n\\n    <owl-date-time-multi-year-view\\n            *ngSwitchCase=\\\"DateView.MULTI_YEARS\\\"\\n            [pickerMoment]=\\\"pickerMoment\\\"\\n            [selected]=\\\"selected\\\"\\n            [selecteds]=\\\"selecteds\\\"\\n            [selectMode]=\\\"selectMode\\\"\\n            [minDate]=\\\"minDate\\\"\\n            [maxDate]=\\\"maxDate\\\"\\n            [dateFilter]=\\\"dateFilter\\\"\\n            (keyboardEnter)=\\\"focusActiveCell()\\\"\\n            (pickerMomentChange)=\\\"handlePickerMomentChange($event)\\\"\\n            (yearSelected)=\\\"selectYearInMultiYearView($event)\\\"\\n            (change)=\\\"goToDateInView($event, DateView.YEAR)\\\"></owl-date-time-multi-year-view>\\n</div>\\n\"\n    }]\n  }], () => [{\n    type: i0.ElementRef\n  }, {\n    type: OwlDateTimeIntl\n  }, {\n    type: i0.NgZone\n  }, {\n    type: i0.ChangeDetectorRef\n  }, {\n    type: DateTimeAdapter,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [OWL_DATE_TIME_FORMATS]\n    }]\n  }], {\n    minDate: [{\n      type: Input\n    }],\n    maxDate: [{\n      type: Input\n    }],\n    pickerMoment: [{\n      type: Input\n    }],\n    selected: [{\n      type: Input\n    }],\n    selecteds: [{\n      type: Input\n    }],\n    dateFilter: [{\n      type: Input\n    }],\n    firstDayOfWeek: [{\n      type: Input\n    }],\n    selectMode: [{\n      type: Input\n    }],\n    startView: [{\n      type: Input\n    }],\n    yearOnly: [{\n      type: Input\n    }],\n    multiyearOnly: [{\n      type: Input\n    }],\n    hideOtherMonths: [{\n      type: Input\n    }],\n    pickerMomentChange: [{\n      type: Output\n    }],\n    dateClicked: [{\n      type: Output\n    }],\n    selectedChange: [{\n      type: Output\n    }],\n    userSelection: [{\n      type: Output\n    }],\n    yearSelected: [{\n      type: Output\n    }],\n    monthSelected: [{\n      type: Output\n    }]\n  });\n})();\n\n/**\n * timer-box.component\n */\nclass OwlTimerBoxComponent {\n  get displayValue() {\n    if (this.hasFocus) {\n      // Don't try to reformat the value that user is currently editing\n      return this.valueInput.nativeElement.value;\n    }\n    const value = this.boxValue || this.value;\n    if (value === null || isNaN(value)) {\n      return '';\n    }\n    return value < 10 ? '0' + value.toString() : value.toString();\n  }\n  get owlDTTimerBoxClass() {\n    return true;\n  }\n  constructor() {\n    this.showDivider = false;\n    this.step = 1;\n    this.valueChange = new EventEmitter();\n    this.inputChange = new EventEmitter();\n    this.inputStream = new Subject();\n    this.inputStreamSub = Subscription.EMPTY;\n    this.hasFocus = false;\n    this.onValueInputMouseWheelBind = this.onValueInputMouseWheel.bind(this);\n  }\n  ngOnInit() {\n    this.inputStreamSub = this.inputStream.pipe(debounceTime(750)).subscribe(val => {\n      if (val) {\n        const inputValue = coerceNumberProperty(val, 0);\n        this.updateValueViaInput(inputValue);\n      }\n    });\n    this.bindValueInputMouseWheel();\n  }\n  ngOnDestroy() {\n    this.unbindValueInputMouseWheel();\n    this.inputStreamSub.unsubscribe();\n  }\n  upBtnClicked() {\n    this.updateValue(this.value + this.step);\n  }\n  downBtnClicked() {\n    this.updateValue(this.value - this.step);\n  }\n  handleInputChange(val) {\n    this.inputStream.next(val);\n  }\n  focusIn() {\n    this.hasFocus = true;\n  }\n  focusOut(value) {\n    this.hasFocus = false;\n    if (value) {\n      const inputValue = coerceNumberProperty(value, 0);\n      this.updateValueViaInput(inputValue);\n    }\n  }\n  updateValue(value) {\n    this.valueChange.emit(value);\n  }\n  updateValueViaInput(value) {\n    if (value > this.max || value < this.min) {\n      return;\n    }\n    this.inputChange.emit(value);\n  }\n  onValueInputMouseWheel(event) {\n    event = event || window.event;\n    const delta = event.wheelDelta || -event.deltaY || -event.detail;\n    if (delta > 0) {\n      if (!this.upBtnDisabled) {\n        this.upBtnClicked();\n      }\n    } else if (delta < 0) {\n      if (!this.downBtnDisabled) {\n        this.downBtnClicked();\n      }\n    }\n    event.preventDefault ? event.preventDefault() : event.returnValue = false;\n  }\n  bindValueInputMouseWheel() {\n    this.valueInput.nativeElement.addEventListener('onwheel' in document ? 'wheel' : 'mousewheel', this.onValueInputMouseWheelBind);\n  }\n  unbindValueInputMouseWheel() {\n    this.valueInput.nativeElement.removeEventListener('onwheel' in document ? 'wheel' : 'mousewheel', this.onValueInputMouseWheelBind);\n  }\n  static #_ = this.ɵfac = function OwlTimerBoxComponent_Factory(t) {\n    return new (t || OwlTimerBoxComponent)();\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OwlTimerBoxComponent,\n    selectors: [[\"owl-date-time-timer-box\"]],\n    viewQuery: function OwlTimerBoxComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c2, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.valueInput = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function OwlTimerBoxComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"owl-dt-timer-box\", ctx.owlDTTimerBoxClass);\n      }\n    },\n    inputs: {\n      showDivider: \"showDivider\",\n      upBtnAriaLabel: \"upBtnAriaLabel\",\n      upBtnDisabled: \"upBtnDisabled\",\n      downBtnAriaLabel: \"downBtnAriaLabel\",\n      downBtnDisabled: \"downBtnDisabled\",\n      boxValue: \"boxValue\",\n      value: \"value\",\n      min: \"min\",\n      max: \"max\",\n      step: \"step\",\n      inputLabel: \"inputLabel\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      inputChange: \"inputChange\"\n    },\n    exportAs: [\"owlDateTimeTimerBox\"],\n    decls: 14,\n    vars: 7,\n    consts: [[\"valueInput\", \"\"], [\"class\", \"owl-dt-timer-divider\", \"aria-hidden\", \"true\", 4, \"ngIf\"], [\"type\", \"button\", \"tabindex\", \"-1\", 1, \"owl-dt-control-button\", \"owl-dt-control-arrow-button\", 3, \"click\", \"disabled\"], [\"tabindex\", \"-1\", 1, \"owl-dt-control-button-content\"], [\"xmlns\", \"http://www.w3.org/2000/svg\", 0, \"xmlns\", \"xlink\", \"http://www.w3.org/1999/xlink\", \"version\", \"1.1\", \"x\", \"0px\", \"y\", \"0px\", \"viewBox\", \"0 0 451.847 451.846\", 0, \"xml\", \"space\", \"preserve\", \"width\", \"100%\", \"height\", \"100%\", 2, \"enable-background\", \"new 0 0 451.847 451.846\"], [\"d\", \"M248.292,106.406l194.281,194.29c12.365,12.359,12.365,32.391,0,44.744c-12.354,12.354-32.391,12.354-44.744,0\\n                        L225.923,173.529L54.018,345.44c-12.36,12.354-32.395,12.354-44.748,0c-12.359-12.354-12.359-32.391,0-44.75L203.554,106.4\\n                        c6.18-6.174,14.271-9.259,22.369-9.259C234.018,97.141,242.115,100.232,248.292,106.406z\"], [1, \"owl-dt-timer-content\"], [\"maxlength\", \"2\", 1, \"owl-dt-timer-input\", 3, \"keydown.arrowup\", \"keydown.arrowdown\", \"input\", \"focusin\", \"focusout\", \"value\"], [1, \"owl-hidden-accessible\"], [\"d\", \"M225.923,354.706c-8.098,0-16.195-3.092-22.369-9.263L9.27,151.157c-12.359-12.359-12.359-32.397,0-44.751\\n                        c12.354-12.354,32.388-12.354,44.748,0l171.905,171.915l171.906-171.909c12.359-12.354,32.391-12.354,44.744,0\\n                        c12.365,12.354,12.365,32.392,0,44.751L248.292,345.449C242.115,351.621,234.018,354.706,225.923,354.706z\"], [\"aria-hidden\", \"true\", 1, \"owl-dt-timer-divider\"]],\n    template: function OwlTimerBoxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r1 = i0.ɵɵgetCurrentView();\n        i0.ɵɵtemplate(0, OwlTimerBoxComponent_div_0_Template, 1, 0, \"div\", 1);\n        i0.ɵɵelementStart(1, \"button\", 2);\n        i0.ɵɵlistener(\"click\", function OwlTimerBoxComponent_Template_button_click_1_listener() {\n          i0.ɵɵrestoreView(_r1);\n          return i0.ɵɵresetView(ctx.upBtnClicked());\n        });\n        i0.ɵɵelementStart(2, \"span\", 3);\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(3, \"svg\", 4);\n        i0.ɵɵelement(4, \"path\", 5);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵnamespaceHTML();\n        i0.ɵɵelementStart(5, \"label\", 6)(6, \"input\", 7, 0);\n        i0.ɵɵlistener(\"keydown.arrowup\", function OwlTimerBoxComponent_Template_input_keydown_arrowup_6_listener() {\n          i0.ɵɵrestoreView(_r1);\n          return i0.ɵɵresetView(!ctx.upBtnDisabled && ctx.upBtnClicked());\n        })(\"keydown.arrowdown\", function OwlTimerBoxComponent_Template_input_keydown_arrowdown_6_listener() {\n          i0.ɵɵrestoreView(_r1);\n          return i0.ɵɵresetView(!ctx.downBtnDisabled && ctx.downBtnClicked());\n        })(\"input\", function OwlTimerBoxComponent_Template_input_input_6_listener() {\n          i0.ɵɵrestoreView(_r1);\n          const valueInput_r2 = i0.ɵɵreference(7);\n          return i0.ɵɵresetView(ctx.handleInputChange(valueInput_r2.value));\n        })(\"focusin\", function OwlTimerBoxComponent_Template_input_focusin_6_listener() {\n          i0.ɵɵrestoreView(_r1);\n          return i0.ɵɵresetView(ctx.focusIn());\n        })(\"focusout\", function OwlTimerBoxComponent_Template_input_focusout_6_listener() {\n          i0.ɵɵrestoreView(_r1);\n          const valueInput_r2 = i0.ɵɵreference(7);\n          return i0.ɵɵresetView(ctx.focusOut(valueInput_r2.value));\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(8, \"span\", 8);\n        i0.ɵɵtext(9);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(10, \"button\", 2);\n        i0.ɵɵlistener(\"click\", function OwlTimerBoxComponent_Template_button_click_10_listener() {\n          i0.ɵɵrestoreView(_r1);\n          return i0.ɵɵresetView(ctx.downBtnClicked());\n        });\n        i0.ɵɵelementStart(11, \"span\", 3);\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(12, \"svg\", 4);\n        i0.ɵɵelement(13, \"path\", 9);\n        i0.ɵɵelementEnd()()();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.showDivider);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"disabled\", ctx.upBtnDisabled);\n        i0.ɵɵattribute(\"aria-label\", ctx.upBtnAriaLabel);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"value\", ctx.displayValue);\n        i0.ɵɵadvance(3);\n        i0.ɵɵtextInterpolate(ctx.inputLabel);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"disabled\", ctx.downBtnDisabled);\n        i0.ɵɵattribute(\"aria-label\", ctx.downBtnAriaLabel);\n      }\n    },\n    dependencies: [i3.NgIf],\n    changeDetection: 0\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlTimerBoxComponent, [{\n    type: Component,\n    args: [{\n      exportAs: 'owlDateTimeTimerBox',\n      selector: 'owl-date-time-timer-box',\n      preserveWhitespaces: false,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      host: {\n        '[class.owl-dt-timer-box]': 'owlDTTimerBoxClass'\n      },\n      template: \"<div *ngIf=\\\"showDivider\\\" class=\\\"owl-dt-timer-divider\\\" aria-hidden=\\\"true\\\"></div>\\n<button class=\\\"owl-dt-control-button owl-dt-control-arrow-button\\\"\\n        type=\\\"button\\\" tabindex=\\\"-1\\\"\\n        [disabled]=\\\"upBtnDisabled\\\"\\n        [attr.aria-label]=\\\"upBtnAriaLabel\\\"\\n        (click)=\\\"upBtnClicked()\\\">\\n    <span class=\\\"owl-dt-control-button-content\\\" tabindex=\\\"-1\\\">\\n        <!-- <editor-fold desc=\\\"SVG Arrow Up\\\"> -->\\n    <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\\n                 version=\\\"1.1\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 451.847 451.846\\\"\\n                 style=\\\"enable-background:new 0 0 451.847 451.846;\\\" xml:space=\\\"preserve\\\"\\n                 width=\\\"100%\\\" height=\\\"100%\\\">\\n                    <path d=\\\"M248.292,106.406l194.281,194.29c12.365,12.359,12.365,32.391,0,44.744c-12.354,12.354-32.391,12.354-44.744,0\\n                        L225.923,173.529L54.018,345.44c-12.36,12.354-32.395,12.354-44.748,0c-12.359-12.354-12.359-32.391,0-44.75L203.554,106.4\\n                        c6.18-6.174,14.271-9.259,22.369-9.259C234.018,97.141,242.115,100.232,248.292,106.406z\\\"/>\\n                </svg>\\n        <!-- </editor-fold> -->\\n    </span>\\n</button>\\n<label class=\\\"owl-dt-timer-content\\\">\\n    <input class=\\\"owl-dt-timer-input\\\" maxlength=\\\"2\\\"\\n           [value]=\\\"displayValue\\\"\\n           (keydown.arrowup)=\\\"!upBtnDisabled && upBtnClicked()\\\"\\n           (keydown.arrowdown)=\\\"!downBtnDisabled && downBtnClicked()\\\"\\n           (input)=\\\"handleInputChange(valueInput.value)\\\"\\n           (focusin)=\\\"focusIn()\\\"\\n           (focusout)=\\\"focusOut(valueInput.value)\\\"\\n           #valueInput>\\n    <span class=\\\"owl-hidden-accessible\\\">{{inputLabel}}</span>\\n</label>\\n<button class=\\\"owl-dt-control-button owl-dt-control-arrow-button\\\"\\n        type=\\\"button\\\" tabindex=\\\"-1\\\"\\n        [disabled]=\\\"downBtnDisabled\\\"\\n        [attr.aria-label]=\\\"downBtnAriaLabel\\\"\\n        (click)=\\\"downBtnClicked()\\\">\\n    <span class=\\\"owl-dt-control-button-content\\\" tabindex=\\\"-1\\\">\\n        <!-- <editor-fold desc=\\\"SVG Arrow Down\\\"> -->\\n    <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\\n                 version=\\\"1.1\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 451.847 451.846\\\"\\n                 style=\\\"enable-background:new 0 0 451.847 451.846;\\\" xml:space=\\\"preserve\\\"\\n                 width=\\\"100%\\\" height=\\\"100%\\\">\\n                    <path d=\\\"M225.923,354.706c-8.098,0-16.195-3.092-22.369-9.263L9.27,151.157c-12.359-12.359-12.359-32.397,0-44.751\\n                        c12.354-12.354,32.388-12.354,44.748,0l171.905,171.915l171.906-171.909c12.359-12.354,32.391-12.354,44.744,0\\n                        c12.365,12.354,12.365,32.392,0,44.751L248.292,345.449C242.115,351.621,234.018,354.706,225.923,354.706z\\\"/>\\n                </svg>\\n        <!-- </editor-fold> -->\\n    </span>\\n</button>\\n\"\n    }]\n  }], () => [], {\n    showDivider: [{\n      type: Input\n    }],\n    upBtnAriaLabel: [{\n      type: Input\n    }],\n    upBtnDisabled: [{\n      type: Input\n    }],\n    downBtnAriaLabel: [{\n      type: Input\n    }],\n    downBtnDisabled: [{\n      type: Input\n    }],\n    boxValue: [{\n      type: Input\n    }],\n    value: [{\n      type: Input\n    }],\n    min: [{\n      type: Input\n    }],\n    max: [{\n      type: Input\n    }],\n    step: [{\n      type: Input\n    }],\n    inputLabel: [{\n      type: Input\n    }],\n    valueChange: [{\n      type: Output\n    }],\n    inputChange: [{\n      type: Output\n    }],\n    valueInput: [{\n      type: ViewChild,\n      args: ['valueInput', {\n        static: true\n      }]\n    }]\n  });\n})();\n\n/**\n * timer.component\n */\nclass OwlTimerComponent {\n  get pickerMoment() {\n    return this._pickerMoment;\n  }\n  set pickerMoment(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this._pickerMoment = this.getValidDate(value) || this.dateTimeAdapter.now();\n  }\n  get minDateTime() {\n    return this._minDateTime;\n  }\n  set minDateTime(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this._minDateTime = this.getValidDate(value);\n  }\n  get maxDateTime() {\n    return this._maxDateTime;\n  }\n  set maxDateTime(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this._maxDateTime = this.getValidDate(value);\n  }\n  get hourValue() {\n    return this.dateTimeAdapter.getHours(this.pickerMoment);\n  }\n  /**\n   * The value would be displayed in hourBox.\n   * We need this because the value displayed in hourBox it not\n   * the same as the hourValue when the timer is in hour12Timer mode.\n   * */\n  get hourBoxValue() {\n    let hours = this.hourValue;\n    if (!this.hour12Timer) {\n      return hours;\n    } else {\n      if (hours === 0) {\n        hours = 12;\n        this.isPM = false;\n      } else if (hours > 0 && hours < 12) {\n        this.isPM = false;\n      } else if (hours === 12) {\n        this.isPM = true;\n      } else if (hours > 12 && hours < 24) {\n        hours = hours - 12;\n        this.isPM = true;\n      }\n      return hours;\n    }\n  }\n  get minuteValue() {\n    return this.dateTimeAdapter.getMinutes(this.pickerMoment);\n  }\n  get secondValue() {\n    return this.dateTimeAdapter.getSeconds(this.pickerMoment);\n  }\n  get upHourButtonLabel() {\n    return this.pickerIntl.upHourLabel;\n  }\n  get downHourButtonLabel() {\n    return this.pickerIntl.downHourLabel;\n  }\n  get upMinuteButtonLabel() {\n    return this.pickerIntl.upMinuteLabel;\n  }\n  get downMinuteButtonLabel() {\n    return this.pickerIntl.downMinuteLabel;\n  }\n  get upSecondButtonLabel() {\n    return this.pickerIntl.upSecondLabel;\n  }\n  get downSecondButtonLabel() {\n    return this.pickerIntl.downSecondLabel;\n  }\n  get hour12ButtonLabel() {\n    return this.isPM ? this.pickerIntl.hour12PMLabel : this.pickerIntl.hour12AMLabel;\n  }\n  get owlDTTimerClass() {\n    return true;\n  }\n  get owlDTTimeTabIndex() {\n    return -1;\n  }\n  constructor(ngZone, elmRef, pickerIntl, cdRef, dateTimeAdapter) {\n    this.ngZone = ngZone;\n    this.elmRef = elmRef;\n    this.pickerIntl = pickerIntl;\n    this.cdRef = cdRef;\n    this.dateTimeAdapter = dateTimeAdapter;\n    this.isPM = false; // a flag indicates the current timer moment is in PM or AM\n    /**\n     * Hours to change per step\n     */\n    this.stepHour = 1;\n    /**\n     * Minutes to change per step\n     */\n    this.stepMinute = 1;\n    /**\n     * Seconds to change per step\n     */\n    this.stepSecond = 1;\n    this.selectedChange = new EventEmitter();\n  }\n  ngOnInit() {}\n  /**\n   * Focus to the host element\n   * */\n  focus() {\n    this.ngZone.runOutsideAngular(() => {\n      this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n        this.elmRef.nativeElement.focus();\n      });\n    });\n  }\n  /**\n   * Set the hour value via typing into timer box input\n   * We need this to handle the hour value when the timer is in hour12 mode\n   * */\n  setHourValueViaInput(hours) {\n    if (this.hour12Timer && this.isPM && hours >= 1 && hours <= 11) {\n      hours = hours + 12;\n    } else if (this.hour12Timer && !this.isPM && hours === 12) {\n      hours = 0;\n    }\n    this.setHourValue(hours);\n  }\n  setHourValue(hours) {\n    const m = this.dateTimeAdapter.setHours(this.pickerMoment, hours);\n    this.selectedChange.emit(m);\n    this.cdRef.markForCheck();\n  }\n  setMinuteValue(minutes) {\n    const m = this.dateTimeAdapter.setMinutes(this.pickerMoment, minutes);\n    this.selectedChange.emit(m);\n    this.cdRef.markForCheck();\n  }\n  setSecondValue(seconds) {\n    const m = this.dateTimeAdapter.setSeconds(this.pickerMoment, seconds);\n    this.selectedChange.emit(m);\n    this.cdRef.markForCheck();\n  }\n  setMeridiem(event) {\n    this.isPM = !this.isPM;\n    let hours = this.hourValue;\n    if (this.isPM) {\n      hours = hours + 12;\n    } else {\n      hours = hours - 12;\n    }\n    if (hours >= 0 && hours <= 23) {\n      this.setHourValue(hours);\n    }\n    this.cdRef.markForCheck();\n    event.preventDefault();\n  }\n  /**\n   * Check if the up hour button is enabled\n   */\n  upHourEnabled() {\n    return !this.maxDateTime || this.compareHours(this.stepHour, this.maxDateTime) < 1;\n  }\n  /**\n   * Check if the down hour button is enabled\n   */\n  downHourEnabled() {\n    return !this.minDateTime || this.compareHours(-this.stepHour, this.minDateTime) > -1;\n  }\n  /**\n   * Check if the up minute button is enabled\n   */\n  upMinuteEnabled() {\n    return !this.maxDateTime || this.compareMinutes(this.stepMinute, this.maxDateTime) < 1;\n  }\n  /**\n   * Check if the down minute button is enabled\n   */\n  downMinuteEnabled() {\n    return !this.minDateTime || this.compareMinutes(-this.stepMinute, this.minDateTime) > -1;\n  }\n  /**\n   * Check if the up second button is enabled\n   */\n  upSecondEnabled() {\n    return !this.maxDateTime || this.compareSeconds(this.stepSecond, this.maxDateTime) < 1;\n  }\n  /**\n   * Check if the down second button is enabled\n   */\n  downSecondEnabled() {\n    return !this.minDateTime || this.compareSeconds(-this.stepSecond, this.minDateTime) > -1;\n  }\n  /**\n   * PickerMoment's hour value +/- certain amount and compare it to the give date\n   * 1 is after the comparedDate\n   * -1 is before the comparedDate\n   * 0 is equal the comparedDate\n   * */\n  compareHours(amount, comparedDate) {\n    const hours = this.dateTimeAdapter.getHours(this.pickerMoment) + amount;\n    const result = this.dateTimeAdapter.setHours(this.pickerMoment, hours);\n    return this.dateTimeAdapter.compare(result, comparedDate);\n  }\n  /**\n   * PickerMoment's minute value +/- certain amount and compare it to the give date\n   * 1 is after the comparedDate\n   * -1 is before the comparedDate\n   * 0 is equal the comparedDate\n   * */\n  compareMinutes(amount, comparedDate) {\n    const minutes = this.dateTimeAdapter.getMinutes(this.pickerMoment) + amount;\n    const result = this.dateTimeAdapter.setMinutes(this.pickerMoment, minutes);\n    return this.dateTimeAdapter.compare(result, comparedDate);\n  }\n  /**\n   * PickerMoment's second value +/- certain amount and compare it to the give date\n   * 1 is after the comparedDate\n   * -1 is before the comparedDate\n   * 0 is equal the comparedDate\n   * */\n  compareSeconds(amount, comparedDate) {\n    const seconds = this.dateTimeAdapter.getSeconds(this.pickerMoment) + amount;\n    const result = this.dateTimeAdapter.setSeconds(this.pickerMoment, seconds);\n    return this.dateTimeAdapter.compare(result, comparedDate);\n  }\n  /**\n   * Get a valid date object\n   */\n  getValidDate(obj) {\n    return this.dateTimeAdapter.isDateInstance(obj) && this.dateTimeAdapter.isValid(obj) ? obj : null;\n  }\n  static #_ = this.ɵfac = function OwlTimerComponent_Factory(t) {\n    return new (t || OwlTimerComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(OwlDateTimeIntl), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(DateTimeAdapter, 8));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OwlTimerComponent,\n    selectors: [[\"owl-date-time-timer\"]],\n    hostVars: 3,\n    hostBindings: function OwlTimerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.owlDTTimeTabIndex);\n        i0.ɵɵclassProp(\"owl-dt-timer\", ctx.owlDTTimerClass);\n      }\n    },\n    inputs: {\n      pickerMoment: \"pickerMoment\",\n      minDateTime: \"minDateTime\",\n      maxDateTime: \"maxDateTime\",\n      showSecondsTimer: \"showSecondsTimer\",\n      hour12Timer: \"hour12Timer\",\n      stepHour: \"stepHour\",\n      stepMinute: \"stepMinute\",\n      stepSecond: \"stepSecond\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\"\n    },\n    exportAs: [\"owlDateTimeTimer\"],\n    decls: 4,\n    vars: 22,\n    consts: [[3, \"inputChange\", \"valueChange\", \"upBtnAriaLabel\", \"downBtnAriaLabel\", \"upBtnDisabled\", \"downBtnDisabled\", \"boxValue\", \"value\", \"min\", \"max\", \"step\", \"inputLabel\"], [3, \"inputChange\", \"valueChange\", \"showDivider\", \"upBtnAriaLabel\", \"downBtnAriaLabel\", \"upBtnDisabled\", \"downBtnDisabled\", \"value\", \"min\", \"max\", \"step\", \"inputLabel\"], [3, \"showDivider\", \"upBtnAriaLabel\", \"downBtnAriaLabel\", \"upBtnDisabled\", \"downBtnDisabled\", \"value\", \"min\", \"max\", \"step\", \"inputLabel\", \"inputChange\", \"valueChange\", 4, \"ngIf\"], [\"class\", \"owl-dt-timer-hour12\", 4, \"ngIf\"], [1, \"owl-dt-timer-hour12\"], [\"type\", \"button\", \"tabindex\", \"0\", 1, \"owl-dt-control-button\", \"owl-dt-timer-hour12-box\", 3, \"click\"], [\"tabindex\", \"-1\", 1, \"owl-dt-control-button-content\"]],\n    template: function OwlTimerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"owl-date-time-timer-box\", 0);\n        i0.ɵɵlistener(\"inputChange\", function OwlTimerComponent_Template_owl_date_time_timer_box_inputChange_0_listener($event) {\n          return ctx.setHourValueViaInput($event);\n        })(\"valueChange\", function OwlTimerComponent_Template_owl_date_time_timer_box_valueChange_0_listener($event) {\n          return ctx.setHourValue($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(1, \"owl-date-time-timer-box\", 1);\n        i0.ɵɵlistener(\"inputChange\", function OwlTimerComponent_Template_owl_date_time_timer_box_inputChange_1_listener($event) {\n          return ctx.setMinuteValue($event);\n        })(\"valueChange\", function OwlTimerComponent_Template_owl_date_time_timer_box_valueChange_1_listener($event) {\n          return ctx.setMinuteValue($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, OwlTimerComponent_owl_date_time_timer_box_2_Template, 1, 10, \"owl-date-time-timer-box\", 2)(3, OwlTimerComponent_div_3_Template, 4, 1, \"div\", 3);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"upBtnAriaLabel\", ctx.upHourButtonLabel)(\"downBtnAriaLabel\", ctx.downHourButtonLabel)(\"upBtnDisabled\", !ctx.upHourEnabled())(\"downBtnDisabled\", !ctx.downHourEnabled())(\"boxValue\", ctx.hourBoxValue)(\"value\", ctx.hourValue)(\"min\", 0)(\"max\", 23)(\"step\", ctx.stepHour)(\"inputLabel\", \"Hour\");\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"showDivider\", true)(\"upBtnAriaLabel\", ctx.upMinuteButtonLabel)(\"downBtnAriaLabel\", ctx.downMinuteButtonLabel)(\"upBtnDisabled\", !ctx.upMinuteEnabled())(\"downBtnDisabled\", !ctx.downMinuteEnabled())(\"value\", ctx.minuteValue)(\"min\", 0)(\"max\", 59)(\"step\", ctx.stepMinute)(\"inputLabel\", \"Minute\");\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngIf\", ctx.showSecondsTimer);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngIf\", ctx.hour12Timer);\n      }\n    },\n    dependencies: [i3.NgIf, OwlTimerBoxComponent],\n    changeDetection: 0\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlTimerComponent, [{\n    type: Component,\n    args: [{\n      exportAs: 'owlDateTimeTimer',\n      selector: 'owl-date-time-timer',\n      preserveWhitespaces: false,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      host: {\n        '[class.owl-dt-timer]': 'owlDTTimerClass',\n        '[attr.tabindex]': 'owlDTTimeTabIndex'\n      },\n      template: \"<owl-date-time-timer-box\\n        [upBtnAriaLabel]=\\\"upHourButtonLabel\\\"\\n        [downBtnAriaLabel]=\\\"downHourButtonLabel\\\"\\n        [upBtnDisabled]=\\\"!upHourEnabled()\\\"\\n        [downBtnDisabled]=\\\"!downHourEnabled()\\\"\\n        [boxValue]=\\\"hourBoxValue\\\"\\n        [value]=\\\"hourValue\\\" [min]=\\\"0\\\" [max]=\\\"23\\\"\\n        [step]=\\\"stepHour\\\" [inputLabel]=\\\"'Hour'\\\"\\n        (inputChange)=\\\"setHourValueViaInput($event)\\\"\\n        (valueChange)=\\\"setHourValue($event)\\\"></owl-date-time-timer-box>\\n<owl-date-time-timer-box\\n        [showDivider]=\\\"true\\\"\\n        [upBtnAriaLabel]=\\\"upMinuteButtonLabel\\\"\\n        [downBtnAriaLabel]=\\\"downMinuteButtonLabel\\\"\\n        [upBtnDisabled]=\\\"!upMinuteEnabled()\\\"\\n        [downBtnDisabled]=\\\"!downMinuteEnabled()\\\"\\n        [value]=\\\"minuteValue\\\" [min]=\\\"0\\\" [max]=\\\"59\\\"\\n        [step]=\\\"stepMinute\\\" [inputLabel]=\\\"'Minute'\\\"\\n        (inputChange)=\\\"setMinuteValue($event)\\\"\\n        (valueChange)=\\\"setMinuteValue($event)\\\"></owl-date-time-timer-box>\\n<owl-date-time-timer-box\\n        *ngIf=\\\"showSecondsTimer\\\"\\n        [showDivider]=\\\"true\\\"\\n        [upBtnAriaLabel]=\\\"upSecondButtonLabel\\\"\\n        [downBtnAriaLabel]=\\\"downSecondButtonLabel\\\"\\n        [upBtnDisabled]=\\\"!upSecondEnabled()\\\"\\n        [downBtnDisabled]=\\\"!downSecondEnabled()\\\"\\n        [value]=\\\"secondValue\\\" [min]=\\\"0\\\" [max]=\\\"59\\\"\\n        [step]=\\\"stepSecond\\\" [inputLabel]=\\\"'Second'\\\"\\n        (inputChange)=\\\"setSecondValue($event)\\\"\\n        (valueChange)=\\\"setSecondValue($event)\\\"></owl-date-time-timer-box>\\n\\n<div *ngIf=\\\"hour12Timer\\\" class=\\\"owl-dt-timer-hour12\\\">\\n    <button class=\\\"owl-dt-control-button owl-dt-timer-hour12-box\\\"\\n            type=\\\"button\\\" tabindex=\\\"0\\\"\\n            (click)=\\\"setMeridiem($event)\\\">\\n        <span class=\\\"owl-dt-control-button-content\\\" tabindex=\\\"-1\\\">\\n            {{hour12ButtonLabel}}\\n        </span>\\n    </button>\\n</div>\\n\"\n    }]\n  }], () => [{\n    type: i0.NgZone\n  }, {\n    type: i0.ElementRef\n  }, {\n    type: OwlDateTimeIntl\n  }, {\n    type: i0.ChangeDetectorRef\n  }, {\n    type: DateTimeAdapter,\n    decorators: [{\n      type: Optional\n    }]\n  }], {\n    pickerMoment: [{\n      type: Input\n    }],\n    minDateTime: [{\n      type: Input\n    }],\n    maxDateTime: [{\n      type: Input\n    }],\n    showSecondsTimer: [{\n      type: Input\n    }],\n    hour12Timer: [{\n      type: Input\n    }],\n    stepHour: [{\n      type: Input\n    }],\n    stepMinute: [{\n      type: Input\n    }],\n    stepSecond: [{\n      type: Input\n    }],\n    selectedChange: [{\n      type: Output\n    }]\n  });\n})();\n\n/**\n * date-time-picker.animations\n */\nconst owlDateTimePickerAnimations = {\n  transformPicker: trigger('transformPicker', [state('void', style({\n    opacity: 0,\n    transform: 'scale(1, 0)'\n  })), state('enter', style({\n    opacity: 1,\n    transform: 'scale(1, 1)'\n  })), transition('void => enter', group([query('@fadeInPicker', animateChild(), {\n    optional: true\n  }), animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')])), transition('enter => void', animate('100ms linear', style({\n    opacity: 0\n  })))]),\n  fadeInPicker: trigger('fadeInPicker', [state('enter', style({\n    opacity: 1\n  })), state('void', style({\n    opacity: 0\n  })), transition('void => enter', animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'))])\n};\n\n/**\n * date-time-picker-container.component\n */\nclass OwlDateTimeContainerComponent {\n  get hidePickerStream() {\n    return this.hidePicker$.asObservable();\n  }\n  get confirmSelectedStream() {\n    return this.confirmSelected$.asObservable();\n  }\n  get beforePickerOpenedStream() {\n    return this.beforePickerOpened$.asObservable();\n  }\n  get pickerOpenedStream() {\n    return this.pickerOpened$.asObservable();\n  }\n  get pickerMoment() {\n    return this._clamPickerMoment;\n  }\n  set pickerMoment(value) {\n    if (value) {\n      this._clamPickerMoment = this.dateTimeAdapter.clampDate(value, this.picker.minDateTime, this.picker.maxDateTime);\n    }\n    this.cdRef.markForCheck();\n  }\n  get pickerType() {\n    return this.picker.pickerType;\n  }\n  get cancelLabel() {\n    return this.pickerIntl.cancelBtnLabel;\n  }\n  get setLabel() {\n    return this.pickerIntl.setBtnLabel;\n  }\n  /**\n   * The range 'from' label\n   * */\n  get fromLabel() {\n    return this.pickerIntl.rangeFromLabel;\n  }\n  /**\n   * The range 'to' label\n   * */\n  get toLabel() {\n    return this.pickerIntl.rangeToLabel;\n  }\n  /**\n   * The range 'from' formatted value\n   * */\n  get fromFormattedValue() {\n    const value = this.picker.selecteds[0];\n    return value ? this.dateTimeAdapter.format(value, this.picker.formatString) : '';\n  }\n  /**\n   * The range 'to' formatted value\n   * */\n  get toFormattedValue() {\n    const value = this.picker.selecteds[1];\n    return value ? this.dateTimeAdapter.format(value, this.picker.formatString) : '';\n  }\n  /**\n   * Cases in which the control buttons show in the picker\n   * 1) picker mode is 'dialog'\n   * 2) picker type is NOT 'calendar' and the picker mode is NOT 'inline'\n   * */\n  get showControlButtons() {\n    return this.picker.pickerMode === 'dialog' || this.picker.pickerType !== 'calendar' && this.picker.pickerMode !== 'inline';\n  }\n  get containerElm() {\n    return this.elmRef.nativeElement;\n  }\n  get owlDTContainerClass() {\n    return true;\n  }\n  get owlDTPopupContainerClass() {\n    return this.picker.pickerMode === 'popup';\n  }\n  get owlDTDialogContainerClass() {\n    return this.picker.pickerMode === 'dialog';\n  }\n  get owlDTInlineContainerClass() {\n    return this.picker.pickerMode === 'inline';\n  }\n  get owlDTContainerDisabledClass() {\n    return this.picker.disabled;\n  }\n  get owlDTContainerId() {\n    return this.picker.id;\n  }\n  get owlDTContainerAnimation() {\n    return this.picker.pickerMode === 'inline' ? '' : 'enter';\n  }\n  constructor(cdRef, elmRef, pickerIntl, dateTimeAdapter) {\n    this.cdRef = cdRef;\n    this.elmRef = elmRef;\n    this.pickerIntl = pickerIntl;\n    this.dateTimeAdapter = dateTimeAdapter;\n    this.activeSelectedIndex = 0; // The current active SelectedIndex in range select mode (0: 'from', 1: 'to')\n    /**\n     * Stream emits when try to hide picker\n     * */\n    this.hidePicker$ = new Subject();\n    /**\n     * Stream emits when try to confirm the selected value\n     * */\n    this.confirmSelected$ = new Subject();\n    this.beforePickerOpened$ = new Subject();\n    this.pickerOpened$ = new Subject();\n  }\n  ngOnInit() {\n    if (this.picker.selectMode === 'range') {\n      if (this.picker.selecteds[0]) {\n        this.retainStartTime = this.dateTimeAdapter.clone(this.picker.selecteds[0]);\n      }\n      if (this.picker.selecteds[1]) {\n        this.retainEndTime = this.dateTimeAdapter.clone(this.picker.selecteds[1]);\n      }\n    }\n  }\n  ngAfterContentInit() {\n    this.initPicker();\n  }\n  ngAfterViewInit() {\n    this.focusPicker();\n  }\n  handleContainerAnimationStart(event) {\n    const toState = event.toState;\n    if (toState === 'enter') {\n      this.beforePickerOpened$.next(null);\n    }\n  }\n  handleContainerAnimationDone(event) {\n    const toState = event.toState;\n    if (toState === 'enter') {\n      this.pickerOpened$.next(null);\n    }\n  }\n  dateSelected(date) {\n    let result;\n    if (this.picker.isInSingleMode) {\n      result = this.dateSelectedInSingleMode(date);\n      if (result) {\n        this.pickerMoment = result;\n        this.picker.select(result);\n      } else {\n        // we close the picker when result is null and pickerType is calendar.\n        if (this.pickerType === 'calendar') {\n          this.hidePicker$.next(null);\n        }\n      }\n      return;\n    }\n    if (this.picker.isInRangeMode) {\n      result = this.dateSelectedInRangeMode(date);\n      if (result) {\n        this.pickerMoment = result[this.activeSelectedIndex];\n        this.picker.select(result);\n      }\n    }\n  }\n  timeSelected(time) {\n    this.pickerMoment = this.dateTimeAdapter.clone(time);\n    if (!this.picker.dateTimeChecker(this.pickerMoment)) {\n      return;\n    }\n    if (this.picker.isInSingleMode) {\n      this.picker.select(this.pickerMoment);\n      return;\n    }\n    if (this.picker.isInRangeMode) {\n      const selecteds = [...this.picker.selecteds];\n      // check if the 'from' is after 'to' or 'to'is before 'from'\n      // In this case, we set both the 'from' and 'to' the same value\n      if (this.activeSelectedIndex === 0 && selecteds[1] && this.dateTimeAdapter.compare(this.pickerMoment, selecteds[1]) === 1 || this.activeSelectedIndex === 1 && selecteds[0] && this.dateTimeAdapter.compare(this.pickerMoment, selecteds[0]) === -1) {\n        selecteds[0] = this.pickerMoment;\n        selecteds[1] = this.pickerMoment;\n      } else {\n        selecteds[this.activeSelectedIndex] = this.pickerMoment;\n      }\n      if (selecteds[0]) {\n        this.retainStartTime = this.dateTimeAdapter.clone(selecteds[0]);\n      }\n      if (selecteds[1]) {\n        this.retainEndTime = this.dateTimeAdapter.clone(selecteds[1]);\n      }\n      this.picker.select(selecteds);\n    }\n  }\n  /**\n   * Handle click on cancel button\n   */\n  onCancelClicked(event) {\n    this.hidePicker$.next(null);\n    event.preventDefault();\n    return;\n  }\n  /**\n   * Handle click on set button\n   */\n  onSetClicked(event) {\n    if (!this.picker.dateTimeChecker(this.pickerMoment)) {\n      this.hidePicker$.next(null);\n      event.preventDefault();\n      return;\n    }\n    this.confirmSelected$.next(event);\n    event.preventDefault();\n    return;\n  }\n  /**\n   * Handle click on inform radio group\n   */\n  handleClickOnInfoGroup(event, index) {\n    this.setActiveSelectedIndex(index);\n    event.preventDefault();\n    event.stopPropagation();\n  }\n  /**\n   * Handle click on inform radio group\n   */\n  handleKeydownOnInfoGroup(event, next, index) {\n    switch (event.keyCode) {\n      case DOWN_ARROW:\n      case RIGHT_ARROW:\n      case UP_ARROW:\n      case LEFT_ARROW:\n        next.focus();\n        this.setActiveSelectedIndex(index === 0 ? 1 : 0);\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n      case SPACE:\n        this.setActiveSelectedIndex(index);\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n      default:\n        return;\n    }\n  }\n  /**\n   * Set the value of activeSelectedIndex\n   */\n  setActiveSelectedIndex(index) {\n    if (this.picker.selectMode === 'range' && this.activeSelectedIndex !== index) {\n      this.activeSelectedIndex = index;\n      const selected = this.picker.selecteds[this.activeSelectedIndex];\n      if (this.picker.selecteds && selected) {\n        this.pickerMoment = this.dateTimeAdapter.clone(selected);\n      }\n    }\n    return;\n  }\n  initPicker() {\n    this.pickerMoment = this.picker.startAt || this.dateTimeAdapter.now();\n    this.activeSelectedIndex = this.picker.selectMode === 'rangeTo' ? 1 : 0;\n  }\n  /**\n   * Select calendar date in single mode,\n   * it returns null when date is not selected.\n   */\n  dateSelectedInSingleMode(date) {\n    if (this.dateTimeAdapter.isSameDay(date, this.picker.selected)) {\n      return null;\n    }\n    return this.updateAndCheckCalendarDate(date);\n  }\n  /**\n   * Select dates in range Mode\n   */\n  dateSelectedInRangeMode(date) {\n    let from = this.picker.selecteds[0];\n    let to = this.picker.selecteds[1];\n    const result = this.updateAndCheckCalendarDate(date);\n    if (!result) {\n      return null;\n    }\n    // if the given calendar day is after or equal to 'from',\n    // set ths given date as 'to'\n    // otherwise, set it as 'from' and set 'to' to null\n    if (this.picker.selectMode === 'range') {\n      if (this.picker.selecteds && this.picker.selecteds.length && !to && from && this.dateTimeAdapter.differenceInCalendarDays(result, from) >= 0) {\n        if (this.picker.endAt && !this.retainEndTime) {\n          to = this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(result), this.dateTimeAdapter.getMonth(result), this.dateTimeAdapter.getDate(result), this.dateTimeAdapter.getHours(this.picker.endAt), this.dateTimeAdapter.getMinutes(this.picker.endAt), this.dateTimeAdapter.getSeconds(this.picker.endAt));\n        } else if (this.retainEndTime) {\n          to = this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(result), this.dateTimeAdapter.getMonth(result), this.dateTimeAdapter.getDate(result), this.dateTimeAdapter.getHours(this.retainEndTime), this.dateTimeAdapter.getMinutes(this.retainEndTime), this.dateTimeAdapter.getSeconds(this.retainEndTime));\n        } else {\n          to = result;\n        }\n        this.activeSelectedIndex = 1;\n      } else {\n        if (this.picker.startAt && !this.retainStartTime) {\n          from = this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(result), this.dateTimeAdapter.getMonth(result), this.dateTimeAdapter.getDate(result), this.dateTimeAdapter.getHours(this.picker.startAt), this.dateTimeAdapter.getMinutes(this.picker.startAt), this.dateTimeAdapter.getSeconds(this.picker.startAt));\n        } else if (this.retainStartTime) {\n          from = this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(result), this.dateTimeAdapter.getMonth(result), this.dateTimeAdapter.getDate(result), this.dateTimeAdapter.getHours(this.retainStartTime), this.dateTimeAdapter.getMinutes(this.retainStartTime), this.dateTimeAdapter.getSeconds(this.retainStartTime));\n        } else {\n          from = result;\n        }\n        to = null;\n        this.activeSelectedIndex = 0;\n      }\n    } else if (this.picker.selectMode === 'rangeFrom') {\n      from = result;\n      // if the from value is after the to value, set the to value as null\n      if (to && this.dateTimeAdapter.compare(from, to) > 0) {\n        to = null;\n      }\n    } else if (this.picker.selectMode === 'rangeTo') {\n      to = result;\n      // if the from value is after the to value, set the from value as null\n      if (from && this.dateTimeAdapter.compare(from, to) > 0) {\n        from = null;\n      }\n    }\n    return [from, to];\n  }\n  /**\n   * Update the given calendar date's time and check if it is valid\n   * Because the calendar date has 00:00:00 as default time, if the picker type is 'both',\n   * we need to update the given calendar date's time before selecting it.\n   * if it is valid, return the updated dateTime\n   * if it is not valid, return null\n   */\n  updateAndCheckCalendarDate(date) {\n    let result;\n    // if the picker is 'both', update the calendar date's time value\n    if (this.picker.pickerType === 'both') {\n      result = this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(date), this.dateTimeAdapter.getMonth(date), this.dateTimeAdapter.getDate(date), this.dateTimeAdapter.getHours(this.pickerMoment), this.dateTimeAdapter.getMinutes(this.pickerMoment), this.dateTimeAdapter.getSeconds(this.pickerMoment));\n      result = this.dateTimeAdapter.clampDate(result, this.picker.minDateTime, this.picker.maxDateTime);\n    } else {\n      result = this.dateTimeAdapter.clone(date);\n    }\n    // check the updated dateTime\n    return this.picker.dateTimeChecker(result) ? result : null;\n  }\n  /**\n   * Focus to the picker\n   * */\n  focusPicker() {\n    if (this.picker.pickerMode === 'inline') {\n      return;\n    }\n    if (this.calendar) {\n      this.calendar.focusActiveCell();\n    } else if (this.timer) {\n      this.timer.focus();\n    }\n  }\n  static #_ = this.ɵfac = function OwlDateTimeContainerComponent_Factory(t) {\n    return new (t || OwlDateTimeContainerComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(OwlDateTimeIntl), i0.ɵɵdirectiveInject(DateTimeAdapter, 8));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OwlDateTimeContainerComponent,\n    selectors: [[\"owl-date-time-container\"]],\n    viewQuery: function OwlDateTimeContainerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(OwlCalendarComponent, 5);\n        i0.ɵɵviewQuery(OwlTimerComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calendar = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.timer = _t.first);\n      }\n    },\n    hostVars: 12,\n    hostBindings: function OwlDateTimeContainerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵsyntheticHostListener(\"@transformPicker.start\", function OwlDateTimeContainerComponent_animation_transformPicker_start_HostBindingHandler($event) {\n          return ctx.handleContainerAnimationStart($event);\n        })(\"@transformPicker.done\", function OwlDateTimeContainerComponent_animation_transformPicker_done_HostBindingHandler($event) {\n          return ctx.handleContainerAnimationDone($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵsyntheticHostProperty(\"@transformPicker\", ctx.owlDTContainerAnimation);\n        i0.ɵɵattribute(\"id\", ctx.owlDTContainerId);\n        i0.ɵɵclassProp(\"owl-dt-container\", ctx.owlDTContainerClass)(\"owl-dt-popup-container\", ctx.owlDTPopupContainerClass)(\"owl-dt-dialog-container\", ctx.owlDTDialogContainerClass)(\"owl-dt-inline-container\", ctx.owlDTInlineContainerClass)(\"owl-dt-container-disabled\", ctx.owlDTContainerDisabledClass);\n      }\n    },\n    exportAs: [\"owlDateTimeContainer\"],\n    decls: 5,\n    vars: 6,\n    consts: [[\"from\", \"\"], [\"to\", \"\"], [1, \"owl-dt-container-inner\", 3, \"cdkTrapFocus\"], [\"class\", \"owl-dt-container-row\", 3, \"firstDayOfWeek\", \"pickerMoment\", \"selected\", \"selecteds\", \"selectMode\", \"minDate\", \"maxDate\", \"dateFilter\", \"startView\", \"yearOnly\", \"multiyearOnly\", \"hideOtherMonths\", \"pickerMomentChange\", \"yearSelected\", \"monthSelected\", \"dateClicked\", \"selectedChange\", 4, \"ngIf\"], [\"class\", \"owl-dt-container-row\", 3, \"pickerMoment\", \"minDateTime\", \"maxDateTime\", \"showSecondsTimer\", \"hour12Timer\", \"stepHour\", \"stepMinute\", \"stepSecond\", \"selectedChange\", 4, \"ngIf\"], [\"role\", \"radiogroup\", \"class\", \"owl-dt-container-info owl-dt-container-row\", 4, \"ngIf\"], [\"class\", \"owl-dt-container-buttons owl-dt-container-row\", 4, \"ngIf\"], [1, \"owl-dt-container-row\", 3, \"pickerMomentChange\", \"yearSelected\", \"monthSelected\", \"dateClicked\", \"selectedChange\", \"firstDayOfWeek\", \"pickerMoment\", \"selected\", \"selecteds\", \"selectMode\", \"minDate\", \"maxDate\", \"dateFilter\", \"startView\", \"yearOnly\", \"multiyearOnly\", \"hideOtherMonths\"], [1, \"owl-dt-container-row\", 3, \"selectedChange\", \"pickerMoment\", \"minDateTime\", \"maxDateTime\", \"showSecondsTimer\", \"hour12Timer\", \"stepHour\", \"stepMinute\", \"stepSecond\"], [\"role\", \"radiogroup\", 1, \"owl-dt-container-info\", \"owl-dt-container-row\"], [\"role\", \"radio\", 1, \"owl-dt-control\", \"owl-dt-container-range\", \"owl-dt-container-from\", 3, \"click\", \"keydown\", \"tabindex\", \"ngClass\"], [\"tabindex\", \"-1\", 1, \"owl-dt-control-content\", \"owl-dt-container-range-content\"], [1, \"owl-dt-container-info-label\"], [1, \"owl-dt-container-info-value\"], [\"role\", \"radio\", 1, \"owl-dt-control\", \"owl-dt-container-range\", \"owl-dt-container-to\", 3, \"click\", \"keydown\", \"tabindex\", \"ngClass\"], [1, \"owl-dt-container-buttons\", \"owl-dt-container-row\"], [\"type\", \"button\", \"tabindex\", \"0\", 1, \"owl-dt-control\", \"owl-dt-control-button\", \"owl-dt-container-control-button\", 3, \"click\"], [\"tabindex\", \"-1\", 1, \"owl-dt-control-content\", \"owl-dt-control-button-content\"]],\n    template: function OwlDateTimeContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 2);\n        i0.ɵɵtemplate(1, OwlDateTimeContainerComponent_owl_date_time_calendar_1_Template, 1, 12, \"owl-date-time-calendar\", 3)(2, OwlDateTimeContainerComponent_owl_date_time_timer_2_Template, 1, 8, \"owl-date-time-timer\", 4)(3, OwlDateTimeContainerComponent_div_3_Template, 15, 14, \"div\", 5)(4, OwlDateTimeContainerComponent_div_4_Template, 7, 2, \"div\", 6);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"cdkTrapFocus\", ctx.picker.pickerMode !== \"inline\")(\"@fadeInPicker\", ctx.picker.pickerMode === \"inline\" ? \"\" : \"enter\");\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngIf\", ctx.pickerType === \"both\" || ctx.pickerType === \"calendar\");\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngIf\", ctx.pickerType === \"both\" || ctx.pickerType === \"timer\");\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngIf\", ctx.picker.isInRangeMode);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngIf\", ctx.showControlButtons);\n      }\n    },\n    dependencies: [i3.NgClass, i3.NgIf, i4.CdkTrapFocus, OwlTimerComponent, OwlCalendarComponent],\n    data: {\n      animation: [owlDateTimePickerAnimations.transformPicker, owlDateTimePickerAnimations.fadeInPicker]\n    },\n    changeDetection: 0\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlDateTimeContainerComponent, [{\n    type: Component,\n    args: [{\n      exportAs: 'owlDateTimeContainer',\n      selector: 'owl-date-time-container',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      preserveWhitespaces: false,\n      animations: [owlDateTimePickerAnimations.transformPicker, owlDateTimePickerAnimations.fadeInPicker],\n      host: {\n        '(@transformPicker.start)': 'handleContainerAnimationStart($event)',\n        '(@transformPicker.done)': 'handleContainerAnimationDone($event)',\n        '[class.owl-dt-container]': 'owlDTContainerClass',\n        '[class.owl-dt-popup-container]': 'owlDTPopupContainerClass',\n        '[class.owl-dt-dialog-container]': 'owlDTDialogContainerClass',\n        '[class.owl-dt-inline-container]': 'owlDTInlineContainerClass',\n        '[class.owl-dt-container-disabled]': 'owlDTContainerDisabledClass',\n        '[attr.id]': 'owlDTContainerId',\n        '[@transformPicker]': 'owlDTContainerAnimation'\n      },\n      template: \"<div [cdkTrapFocus]=\\\"picker.pickerMode !== 'inline'\\\"\\n     [@fadeInPicker]=\\\"picker.pickerMode === 'inline'? '' : 'enter'\\\"\\n     class=\\\"owl-dt-container-inner\\\">\\n\\n    <owl-date-time-calendar\\n            *ngIf=\\\"pickerType === 'both' || pickerType === 'calendar'\\\"\\n            class=\\\"owl-dt-container-row\\\"\\n            [firstDayOfWeek]=\\\"picker.firstDayOfWeek\\\"\\n            [(pickerMoment)]=\\\"pickerMoment\\\"\\n            [selected]=\\\"picker.selected\\\"\\n            [selecteds]=\\\"picker.selecteds\\\"\\n            [selectMode]=\\\"picker.selectMode\\\"\\n            [minDate]=\\\"picker.minDateTime\\\"\\n            [maxDate]=\\\"picker.maxDateTime\\\"\\n            [dateFilter]=\\\"picker.dateTimeFilter\\\"\\n            [startView]=\\\"picker.startView\\\"\\n            [yearOnly]=\\\"picker.yearOnly\\\"\\n            [multiyearOnly]=\\\"picker.multiyearOnly\\\"\\n            [hideOtherMonths]=\\\"picker.hideOtherMonths\\\"\\n            (yearSelected)=\\\"picker.selectYear($event)\\\"\\n            (monthSelected)=\\\"picker.selectMonth($event)\\\"\\n            (dateClicked)=\\\"picker.selectDate($event)\\\"\\n            (selectedChange)=\\\"dateSelected($event)\\\"></owl-date-time-calendar>\\n\\n    <owl-date-time-timer\\n            *ngIf=\\\"pickerType === 'both' || pickerType === 'timer'\\\"\\n            class=\\\"owl-dt-container-row\\\"\\n            [pickerMoment]=\\\"pickerMoment\\\"\\n            [minDateTime]=\\\"picker.minDateTime\\\"\\n            [maxDateTime]=\\\"picker.maxDateTime\\\"\\n            [showSecondsTimer]=\\\"picker.showSecondsTimer\\\"\\n            [hour12Timer]=\\\"picker.hour12Timer\\\"\\n            [stepHour]=\\\"picker.stepHour\\\"\\n            [stepMinute]=\\\"picker.stepMinute\\\"\\n            [stepSecond]=\\\"picker.stepSecond\\\"\\n            (selectedChange)=\\\"timeSelected($event)\\\"></owl-date-time-timer>\\n\\n    <div *ngIf=\\\"picker.isInRangeMode\\\"\\n         role=\\\"radiogroup\\\"\\n         class=\\\"owl-dt-container-info owl-dt-container-row\\\">\\n        <div role=\\\"radio\\\" [tabindex]=\\\"activeSelectedIndex === 0 ? 0 : -1\\\"\\n             [attr.aria-checked]=\\\"activeSelectedIndex === 0\\\"\\n             class=\\\"owl-dt-control owl-dt-container-range owl-dt-container-from\\\"\\n             [ngClass]=\\\"{'owl-dt-container-info-active': activeSelectedIndex === 0}\\\"\\n             (click)=\\\"handleClickOnInfoGroup($event, 0)\\\"\\n             (keydown)=\\\"handleKeydownOnInfoGroup($event, to, 0)\\\" #from>\\n            <span class=\\\"owl-dt-control-content owl-dt-container-range-content\\\" tabindex=\\\"-1\\\">\\n                <span class=\\\"owl-dt-container-info-label\\\">{{fromLabel}}:</span>\\n                <span class=\\\"owl-dt-container-info-value\\\">{{fromFormattedValue}}</span>\\n            </span>\\n        </div>\\n        <div role=\\\"radio\\\" [tabindex]=\\\"activeSelectedIndex === 1 ? 0 : -1\\\"\\n             [attr.aria-checked]=\\\"activeSelectedIndex === 1\\\"\\n             class=\\\"owl-dt-control owl-dt-container-range owl-dt-container-to\\\"\\n             [ngClass]=\\\"{'owl-dt-container-info-active': activeSelectedIndex === 1}\\\"\\n             (click)=\\\"handleClickOnInfoGroup($event, 1)\\\"\\n             (keydown)=\\\"handleKeydownOnInfoGroup($event, from, 1)\\\" #to>\\n            <span class=\\\"owl-dt-control-content owl-dt-container-range-content\\\" tabindex=\\\"-1\\\">\\n                <span class=\\\"owl-dt-container-info-label\\\">{{toLabel}}:</span>\\n                <span class=\\\"owl-dt-container-info-value\\\">{{toFormattedValue}}</span>\\n            </span>\\n        </div>\\n    </div>\\n\\n    <div *ngIf=\\\"showControlButtons\\\" class=\\\"owl-dt-container-buttons owl-dt-container-row\\\">\\n        <button class=\\\"owl-dt-control owl-dt-control-button owl-dt-container-control-button\\\"\\n                type=\\\"button\\\" tabindex=\\\"0\\\"\\n                (click)=\\\"onCancelClicked($event)\\\">\\n            <span class=\\\"owl-dt-control-content owl-dt-control-button-content\\\" tabindex=\\\"-1\\\">\\n                {{cancelLabel}}\\n            </span>\\n        </button>\\n        <button class=\\\"owl-dt-control owl-dt-control-button owl-dt-container-control-button\\\"\\n                type=\\\"button\\\" tabindex=\\\"0\\\"\\n                (click)=\\\"onSetClicked($event)\\\">\\n            <span class=\\\"owl-dt-control-content owl-dt-control-button-content\\\" tabindex=\\\"-1\\\">\\n                {{setLabel}}\\n            </span>\\n        </button>\\n    </div>\\n</div>\\n\"\n    }]\n  }], () => [{\n    type: i0.ChangeDetectorRef\n  }, {\n    type: i0.ElementRef\n  }, {\n    type: OwlDateTimeIntl\n  }, {\n    type: DateTimeAdapter,\n    decorators: [{\n      type: Optional\n    }]\n  }], {\n    calendar: [{\n      type: ViewChild,\n      args: [OwlCalendarComponent]\n    }],\n    timer: [{\n      type: ViewChild,\n      args: [OwlTimerComponent]\n    }]\n  });\n})();\nlet uniqueId = 0;\nclass OwlDialogConfig {\n  constructor() {\n    /**\n     * ID of the element that describes the dialog.\n     */\n    this.ariaDescribedBy = null;\n    /**\n     * Whether to focus the dialog when the dialog is opened\n     */\n    this.autoFocus = true;\n    /** Whether the dialog has a backdrop. */\n    this.hasBackdrop = true;\n    /** Data being injected into the child component. */\n    this.data = null;\n    /** Whether the user can use escape or clicking outside to close a modal. */\n    this.disableClose = false;\n    /**\n     * The ARIA role of the dialog element.\n     */\n    this.role = 'dialog';\n    /**\n     * Custom class for the pane\n     * */\n    this.paneClass = '';\n    /**\n     * Mouse Event\n     * */\n    this.event = null;\n    /**\n     * Custom class for the backdrop\n     * */\n    this.backdropClass = '';\n    /**\n     * Whether the dialog should close when the user goes backwards/forwards in history.\n     * */\n    this.closeOnNavigation = true;\n    /** Width of the dialog. */\n    this.width = '';\n    /** Height of the dialog. */\n    this.height = '';\n    /**\n     * The max-width of the overlay panel.\n     * If a number is provided, pixel units are assumed.\n     * */\n    this.maxWidth = '85vw';\n    /**\n     * The scroll strategy when the dialog is open\n     * Learn more this from https://material.angular.io/cdk/overlay/overview#scroll-strategies\n     * */\n    this.scrollStrategy = new NoopScrollStrategy();\n    this.id = `owl-dialog-${uniqueId++}`;\n  }\n}\nclass OwlDialogRef {\n  constructor(overlayRef, container, id, location) {\n    this.overlayRef = overlayRef;\n    this.container = container;\n    this.id = id;\n    this._beforeClose$ = new Subject();\n    this._beforeOpen$ = new Subject();\n    this._afterOpen$ = new Subject();\n    this._afterClosed$ = new Subject();\n    /** Subscription to changes in the user's location. */\n    this.locationChanged = Subscription.EMPTY;\n    /** Whether the user is allowed to close the dialog. */\n    this.disableClose = true;\n    this.disableClose = this.container.config.disableClose;\n    this.container.animationStateChanged.pipe(filter(event => event.phaseName === 'start' && event.toState === 'enter'), take$1(1)).subscribe(() => {\n      this._beforeOpen$.next(null);\n      this._beforeOpen$.complete();\n    });\n    this.container.animationStateChanged.pipe(filter(event => event.phaseName === 'done' && event.toState === 'enter'), take$1(1)).subscribe(() => {\n      this._afterOpen$.next(null);\n      this._afterOpen$.complete();\n    });\n    this.container.animationStateChanged.pipe(filter(event => event.phaseName === 'done' && event.toState === 'exit'), take$1(1)).subscribe(() => {\n      this.overlayRef.dispose();\n      this.locationChanged.unsubscribe();\n      this._afterClosed$.next(this.result);\n      this._afterClosed$.complete();\n      this.componentInstance = null;\n    });\n    this.overlayRef.keydownEvents().pipe(filter(event => event.keyCode === ESCAPE && !this.disableClose)).subscribe(() => this.close());\n    if (location) {\n      this.locationChanged = location.subscribe(() => {\n        if (this.container.config.closeOnNavigation) {\n          this.close();\n        }\n      });\n    }\n  }\n  close(dialogResult) {\n    this.result = dialogResult;\n    this.container.animationStateChanged.pipe(filter(event => event.phaseName === 'start'), take$1(1)).subscribe(() => {\n      this._beforeClose$.next(dialogResult);\n      this._beforeClose$.complete();\n      this.overlayRef.detachBackdrop();\n    });\n    this.container.startExitAnimation();\n  }\n  /**\n   * Gets an observable that emits when the overlay's backdrop has been clicked.\n   */\n  backdropClick() {\n    return this.overlayRef.backdropClick();\n  }\n  /**\n   * Gets an observable that emits when keydown events are targeted on the overlay.\n   */\n  keydownEvents() {\n    return this.overlayRef.keydownEvents();\n  }\n  /**\n   * Updates the dialog's position.\n   * @param position New dialog position.\n   */\n  updatePosition(position) {\n    const strategy = this.getPositionStrategy();\n    if (position && (position.left || position.right)) {\n      position.left ? strategy.left(position.left) : strategy.right(position.right);\n    } else {\n      strategy.centerHorizontally();\n    }\n    if (position && (position.top || position.bottom)) {\n      position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);\n    } else {\n      strategy.centerVertically();\n    }\n    this.overlayRef.updatePosition();\n    return this;\n  }\n  /**\n   * Updates the dialog's width and height.\n   * @param width New width of the dialog.\n   * @param height New height of the dialog.\n   */\n  updateSize(width = 'auto', height = 'auto') {\n    this.getPositionStrategy().width(width).height(height);\n    this.overlayRef.updatePosition();\n    return this;\n  }\n  isAnimating() {\n    return this.container.isAnimating;\n  }\n  beforeOpen() {\n    return this._beforeOpen$.asObservable();\n  }\n  afterOpen() {\n    return this._afterOpen$.asObservable();\n  }\n  beforeClose() {\n    return this._beforeClose$.asObservable();\n  }\n  afterClosed() {\n    return this._afterClosed$.asObservable();\n  }\n  /** Fetches the position strategy object from the overlay ref. */\n  getPositionStrategy() {\n    return this.overlayRef.getConfig().positionStrategy;\n  }\n}\n\n/**\n * dialog-container.component\n */\nconst zoomFadeIn = {\n  opacity: 0,\n  transform: 'translateX({{ x }}) translateY({{ y }}) scale({{scale}})'\n};\nconst zoomFadeInFrom = {\n  opacity: 0,\n  transform: 'translateX({{ x }}) translateY({{ y }}) scale({{scale}})',\n  transformOrigin: '{{ ox }} {{ oy }}'\n};\nclass OwlDialogContainerComponent extends BasePortalOutlet {\n  get config() {\n    return this._config;\n  }\n  get owlDialogContainerClass() {\n    return true;\n  }\n  get owlDialogContainerTabIndex() {\n    return -1;\n  }\n  get owlDialogContainerId() {\n    return this._config.id;\n  }\n  get owlDialogContainerRole() {\n    return this._config.role || null;\n  }\n  get owlDialogContainerAriaLabelledby() {\n    return this.ariaLabelledBy;\n  }\n  get owlDialogContainerAriaDescribedby() {\n    return this._config.ariaDescribedBy || null;\n  }\n  get owlDialogContainerAnimation() {\n    return {\n      value: this.state,\n      params: this.params\n    };\n  }\n  constructor(changeDetector, elementRef, focusTrapFactory, document) {\n    super();\n    this.changeDetector = changeDetector;\n    this.elementRef = elementRef;\n    this.focusTrapFactory = focusTrapFactory;\n    this.document = document;\n    this.portalOutlet = null;\n    /** ID of the element that should be considered as the dialog's label. */\n    this.ariaLabelledBy = null;\n    /** Emits when an animation state changes. */\n    this.animationStateChanged = new EventEmitter();\n    this.isAnimating = false;\n    this.state = 'enter';\n    // for animation purpose\n    this.params = {\n      x: '0px',\n      y: '0px',\n      ox: '50%',\n      oy: '50%',\n      scale: 0\n    };\n    // A variable to hold the focused element before the dialog was open.\n    // This would help us to refocus back to element when the dialog was closed.\n    this.elementFocusedBeforeDialogWasOpened = null;\n  }\n  ngOnInit() {}\n  /**\n   * Attach a ComponentPortal as content to this dialog container.\n   */\n  attachComponentPortal(portal) {\n    if (this.portalOutlet.hasAttached()) {\n      throw Error('Attempting to attach dialog content after content is already attached');\n    }\n    this.savePreviouslyFocusedElement();\n    return this.portalOutlet.attachComponentPortal(portal);\n  }\n  attachTemplatePortal(portal) {\n    throw new Error('Method not implemented.');\n  }\n  setConfig(config) {\n    this._config = config;\n    if (config.event) {\n      this.calculateZoomOrigin(event);\n    }\n  }\n  onAnimationStart(event) {\n    this.isAnimating = true;\n    this.animationStateChanged.emit(event);\n  }\n  onAnimationDone(event) {\n    if (event.toState === 'enter') {\n      this.trapFocus();\n    } else if (event.toState === 'exit') {\n      this.restoreFocus();\n    }\n    this.animationStateChanged.emit(event);\n    this.isAnimating = false;\n  }\n  startExitAnimation() {\n    this.state = 'exit';\n    this.changeDetector.markForCheck();\n  }\n  /**\n   * Calculate origin used in the `zoomFadeInFrom()`\n   * for animation purpose\n   */\n  calculateZoomOrigin(event) {\n    if (!event) {\n      return;\n    }\n    const clientX = event.clientX;\n    const clientY = event.clientY;\n    const wh = window.innerWidth / 2;\n    const hh = window.innerHeight / 2;\n    const x = clientX - wh;\n    const y = clientY - hh;\n    const ox = clientX / window.innerWidth;\n    const oy = clientY / window.innerHeight;\n    this.params.x = `${x}px`;\n    this.params.y = `${y}px`;\n    this.params.ox = `${ox * 100}%`;\n    this.params.oy = `${oy * 100}%`;\n    this.params.scale = 0;\n    return;\n  }\n  /**\n   * Save the focused element before dialog was open\n   */\n  savePreviouslyFocusedElement() {\n    if (this.document) {\n      this.elementFocusedBeforeDialogWasOpened = this.document.activeElement;\n      Promise.resolve().then(() => this.elementRef.nativeElement.focus());\n    }\n  }\n  trapFocus() {\n    if (!this.focusTrap) {\n      this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);\n    }\n    if (this._config.autoFocus) {\n      this.focusTrap.focusInitialElementWhenReady();\n    }\n  }\n  restoreFocus() {\n    const toFocus = this.elementFocusedBeforeDialogWasOpened;\n    // We need the extra check, because IE can set the `activeElement` to null in some cases.\n    if (toFocus && typeof toFocus.focus === 'function') {\n      toFocus.focus();\n    }\n    if (this.focusTrap) {\n      this.focusTrap.destroy();\n    }\n  }\n  static #_ = this.ɵfac = function OwlDialogContainerComponent_Factory(t) {\n    return new (t || OwlDialogContainerComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i4.FocusTrapFactory), i0.ɵɵdirectiveInject(DOCUMENT, 8));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OwlDialogContainerComponent,\n    selectors: [[\"owl-dialog-container\"]],\n    viewQuery: function OwlDialogContainerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(CdkPortalOutlet, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function OwlDialogContainerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵsyntheticHostListener(\"@slideModal.start\", function OwlDialogContainerComponent_animation_slideModal_start_HostBindingHandler($event) {\n          return ctx.onAnimationStart($event);\n        })(\"@slideModal.done\", function OwlDialogContainerComponent_animation_slideModal_done_HostBindingHandler($event) {\n          return ctx.onAnimationDone($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵsyntheticHostProperty(\"@slideModal\", ctx.owlDialogContainerAnimation);\n        i0.ɵɵattribute(\"tabindex\", ctx.owlDialogContainerTabIndex)(\"id\", ctx.owlDialogContainerId)(\"role\", ctx.owlDialogContainerRole)(\"aria-labelledby\", ctx.owlDialogContainerAriaLabelledby)(\"aria-describedby\", ctx.owlDialogContainerAriaDescribedby);\n        i0.ɵɵclassProp(\"owl-dialog-container\", ctx.owlDialogContainerClass);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 0,\n    consts: [[3, \"cdkPortalOutlet\"]],\n    template: function OwlDialogContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, OwlDialogContainerComponent_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n      }\n    },\n    dependencies: [i2.CdkPortalOutlet],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('slideModal', [transition('void => enter', [style(zoomFadeInFrom), animate('300ms cubic-bezier(0.35, 0, 0.25, 1)', style('*')), animate('150ms', keyframes([style({\n        transform: 'scale(1)',\n        offset: 0\n      }), style({\n        transform: 'scale(1.05)',\n        offset: 0.3\n      }), style({\n        transform: 'scale(.95)',\n        offset: 0.8\n      }), style({\n        transform: 'scale(1)',\n        offset: 1.0\n      })])), animateChild()], {\n        params: {\n          x: '0px',\n          y: '0px',\n          ox: '50%',\n          oy: '50%',\n          scale: 1\n        }\n      }), transition('enter => exit', [animateChild(), animate(200, style(zoomFadeIn))], {\n        params: {\n          x: '0px',\n          y: '0px',\n          ox: '50%',\n          oy: '50%'\n        }\n      })])]\n    }\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlDialogContainerComponent, [{\n    type: Component,\n    args: [{\n      selector: 'owl-dialog-container',\n      animations: [trigger('slideModal', [transition('void => enter', [style(zoomFadeInFrom), animate('300ms cubic-bezier(0.35, 0, 0.25, 1)', style('*')), animate('150ms', keyframes([style({\n        transform: 'scale(1)',\n        offset: 0\n      }), style({\n        transform: 'scale(1.05)',\n        offset: 0.3\n      }), style({\n        transform: 'scale(.95)',\n        offset: 0.8\n      }), style({\n        transform: 'scale(1)',\n        offset: 1.0\n      })])), animateChild()], {\n        params: {\n          x: '0px',\n          y: '0px',\n          ox: '50%',\n          oy: '50%',\n          scale: 1\n        }\n      }), transition('enter => exit', [animateChild(), animate(200, style(zoomFadeIn))], {\n        params: {\n          x: '0px',\n          y: '0px',\n          ox: '50%',\n          oy: '50%'\n        }\n      })])],\n      host: {\n        '(@slideModal.start)': 'onAnimationStart($event)',\n        '(@slideModal.done)': 'onAnimationDone($event)',\n        '[class.owl-dialog-container]': 'owlDialogContainerClass',\n        '[attr.tabindex]': 'owlDialogContainerTabIndex',\n        '[attr.id]': 'owlDialogContainerId',\n        '[attr.role]': 'owlDialogContainerRole',\n        '[attr.aria-labelledby]': 'owlDialogContainerAriaLabelledby',\n        '[attr.aria-describedby]': 'owlDialogContainerAriaDescribedby',\n        '[@slideModal]': 'owlDialogContainerAnimation'\n      },\n      template: \"<ng-template [cdkPortalOutlet]></ng-template>\\n\"\n    }]\n  }], () => [{\n    type: i0.ChangeDetectorRef\n  }, {\n    type: i0.ElementRef\n  }, {\n    type: i4.FocusTrapFactory\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }], {\n    portalOutlet: [{\n      type: ViewChild,\n      args: [CdkPortalOutlet, {\n        static: true\n      }]\n    }]\n  });\n})();\n\n/**\n * object.utils\n */\n/**\n * Extends an object with the *enumerable* and *own* properties of one or more source objects,\n * similar to Object.assign.\n *\n * @param dest The object which will have properties copied to it.\n * @param sources The source objects from which properties will be copied.\n */\nfunction extendObject(dest, ...sources) {\n  if (dest == null) {\n    throw TypeError('Cannot convert undefined or null to object');\n  }\n  for (const source of sources) {\n    if (source != null) {\n      for (const key in source) {\n        if (source.hasOwnProperty(key)) {\n          dest[key] = source[key];\n        }\n      }\n    }\n  }\n  return dest;\n}\n\n/**\n * index\n */\n\n/**\n * dialog.service\n */\nconst OWL_DIALOG_DATA = new InjectionToken('OwlDialogData');\n/**\n * Injection token that determines the scroll handling while the dialog is open.\n * */\nconst OWL_DIALOG_SCROLL_STRATEGY = new InjectionToken('owl-dialog-scroll-strategy');\nfunction OWL_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n  const fn = () => overlay.scrollStrategies.block();\n  return fn;\n}\n/** @docs-private */\nconst OWL_DIALOG_SCROLL_STRATEGY_PROVIDER = {\n  provide: OWL_DIALOG_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: OWL_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY\n};\n/**\n * Injection token that can be used to specify default dialog options.\n * */\nconst OWL_DIALOG_DEFAULT_OPTIONS = new InjectionToken('owl-dialog-default-options');\nclass OwlDialogService {\n  /** Keeps track of the currently-open dialogs. */\n  get openDialogs() {\n    return this.parentDialog ? this.parentDialog.openDialogs : this._openDialogsAtThisLevel;\n  }\n  /** Stream that emits when a dialog has been opened. */\n  get beforeOpen() {\n    return this.parentDialog ? this.parentDialog.beforeOpen : this._beforeOpenAtThisLevel;\n  }\n  /** Stream that emits when a dialog has been opened. */\n  get afterOpen() {\n    return this.parentDialog ? this.parentDialog.afterOpen : this._afterOpenAtThisLevel;\n  }\n  get _afterAllClosed() {\n    const parent = this.parentDialog;\n    return parent ? parent._afterAllClosed : this._afterAllClosedAtThisLevel;\n  }\n  constructor(overlay, injector, location, scrollStrategy, defaultOptions, parentDialog, overlayContainer) {\n    this.overlay = overlay;\n    this.injector = injector;\n    this.location = location;\n    this.defaultOptions = defaultOptions;\n    this.parentDialog = parentDialog;\n    this.overlayContainer = overlayContainer;\n    this.ariaHiddenElements = new Map();\n    this._openDialogsAtThisLevel = [];\n    this._beforeOpenAtThisLevel = new Subject();\n    this._afterOpenAtThisLevel = new Subject();\n    this._afterAllClosedAtThisLevel = new Subject();\n    /**\n     * Stream that emits when all open dialog have finished closing.\n     * Will emit on subscribe if there are no open dialogs to begin with.\n     */\n    this.afterAllClosed = defer(() => this._openDialogsAtThisLevel.length ? this._afterAllClosed : this._afterAllClosed.pipe(startWith(undefined)));\n    this.scrollStrategy = scrollStrategy;\n    if (!parentDialog && location) {\n      location.subscribe(() => this.closeAll());\n    }\n  }\n  open(componentOrTemplateRef, config) {\n    config = applyConfigDefaults(config, this.defaultOptions);\n    if (config.id && this.getDialogById(config.id)) {\n      throw Error(`Dialog with id \"${config.id}\" exists already. The dialog id must be unique.`);\n    }\n    const overlayRef = this.createOverlay(config);\n    const dialogContainer = this.attachDialogContainer(overlayRef, config);\n    const dialogRef = this.attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);\n    if (!this.openDialogs.length) {\n      this.hideNonDialogContentFromAssistiveTechnology();\n    }\n    this.openDialogs.push(dialogRef);\n    dialogRef.afterClosed().subscribe(() => this.removeOpenDialog(dialogRef));\n    this.beforeOpen.next(dialogRef);\n    this.afterOpen.next(dialogRef);\n    return dialogRef;\n  }\n  /**\n   * Closes all of the currently-open dialogs.\n   */\n  closeAll() {\n    let i = this.openDialogs.length;\n    while (i--) {\n      this.openDialogs[i].close();\n    }\n  }\n  /**\n   * Finds an open dialog by its id.\n   * @param id ID to use when looking up the dialog.\n   */\n  getDialogById(id) {\n    return this.openDialogs.find(dialog => dialog.id === id);\n  }\n  attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config) {\n    const dialogRef = new OwlDialogRef(overlayRef, dialogContainer, config.id, this.location);\n    if (config.hasBackdrop) {\n      overlayRef.backdropClick().subscribe(() => {\n        if (!dialogRef.disableClose) {\n          dialogRef.close();\n        }\n      });\n    }\n    if (componentOrTemplateRef instanceof TemplateRef) {} else {\n      const injector = this.createInjector(config, dialogRef, dialogContainer);\n      const contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, undefined, injector));\n      dialogRef.componentInstance = contentRef.instance;\n    }\n    dialogRef.updateSize(config.width, config.height).updatePosition(config.position);\n    return dialogRef;\n  }\n  createInjector(config, dialogRef, dialogContainer) {\n    const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n    const injectionTokens = new WeakMap();\n    injectionTokens.set(OwlDialogRef, dialogRef);\n    injectionTokens.set(OwlDialogContainerComponent, dialogContainer);\n    injectionTokens.set(OWL_DIALOG_DATA, config.data);\n    return new PortalInjector(userInjector || this.injector, injectionTokens);\n  }\n  createOverlay(config) {\n    const overlayConfig = this.getOverlayConfig(config);\n    return this.overlay.create(overlayConfig);\n  }\n  attachDialogContainer(overlayRef, config) {\n    const containerPortal = new ComponentPortal(OwlDialogContainerComponent, config.viewContainerRef);\n    const containerRef = overlayRef.attach(containerPortal);\n    containerRef.instance.setConfig(config);\n    return containerRef.instance;\n  }\n  getOverlayConfig(dialogConfig) {\n    const state = new OverlayConfig({\n      positionStrategy: this.overlay.position().global(),\n      scrollStrategy: dialogConfig.scrollStrategy || this.scrollStrategy(),\n      panelClass: dialogConfig.paneClass,\n      hasBackdrop: dialogConfig.hasBackdrop,\n      minWidth: dialogConfig.minWidth,\n      minHeight: dialogConfig.minHeight,\n      maxWidth: dialogConfig.maxWidth,\n      maxHeight: dialogConfig.maxHeight\n    });\n    if (dialogConfig.backdropClass) {\n      state.backdropClass = dialogConfig.backdropClass;\n    }\n    return state;\n  }\n  removeOpenDialog(dialogRef) {\n    const index = this._openDialogsAtThisLevel.indexOf(dialogRef);\n    if (index > -1) {\n      this.openDialogs.splice(index, 1);\n      // If all the dialogs were closed, remove/restore the `aria-hidden`\n      // to a the siblings and emit to the `afterAllClosed` stream.\n      if (!this.openDialogs.length) {\n        this.ariaHiddenElements.forEach((previousValue, element) => {\n          if (previousValue) {\n            element.setAttribute('aria-hidden', previousValue);\n          } else {\n            element.removeAttribute('aria-hidden');\n          }\n        });\n        this.ariaHiddenElements.clear();\n        this._afterAllClosed.next();\n      }\n    }\n  }\n  /**\n   * Hides all of the content that isn't an overlay from assistive technology.\n   */\n  hideNonDialogContentFromAssistiveTechnology() {\n    const overlayContainer = this.overlayContainer.getContainerElement();\n    // Ensure that the overlay container is attached to the DOM.\n    if (overlayContainer.parentElement) {\n      const siblings = overlayContainer.parentElement.children;\n      for (let i = siblings.length - 1; i > -1; i--) {\n        const sibling = siblings[i];\n        if (sibling !== overlayContainer && sibling.nodeName !== 'SCRIPT' && sibling.nodeName !== 'STYLE' && !sibling.hasAttribute('aria-live')) {\n          this.ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));\n          sibling.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n  }\n  static #_ = this.ɵfac = function OwlDialogService_Factory(t) {\n    return new (t || OwlDialogService)(i0.ɵɵinject(i1.Overlay), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i3.Location, 8), i0.ɵɵinject(OWL_DIALOG_SCROLL_STRATEGY), i0.ɵɵinject(OWL_DIALOG_DEFAULT_OPTIONS, 8), i0.ɵɵinject(OwlDialogService, 12), i0.ɵɵinject(i1.OverlayContainer));\n  };\n  static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OwlDialogService,\n    factory: OwlDialogService.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlDialogService, [{\n    type: Injectable\n  }], () => [{\n    type: i1.Overlay\n  }, {\n    type: i0.Injector\n  }, {\n    type: i3.Location,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [OWL_DIALOG_SCROLL_STRATEGY]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [OWL_DIALOG_DEFAULT_OPTIONS]\n    }]\n  }, {\n    type: OwlDialogService,\n    decorators: [{\n      type: Optional\n    }, {\n      type: SkipSelf\n    }]\n  }, {\n    type: i1.OverlayContainer\n  }], null);\n})();\n/**\n * Applies default options to the dialog config.\n * @param config Config to be modified.\n * @param defaultOptions Default config setting\n * @returns The new configuration object.\n */\nfunction applyConfigDefaults(config, defaultOptions) {\n  return extendObject(new OwlDialogConfig(), config, defaultOptions);\n}\n\n/**\n * date-time-picker.component\n */\n/** Injection token that determines the scroll handling while the dtPicker is open. */\nconst OWL_DTPICKER_SCROLL_STRATEGY = new InjectionToken('owl-dtpicker-scroll-strategy');\n/** @docs-private */\nfunction OWL_DTPICKER_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n  const fn = () => overlay.scrollStrategies.block();\n  return fn;\n}\n/** @docs-private */\nconst OWL_DTPICKER_SCROLL_STRATEGY_PROVIDER = {\n  provide: OWL_DTPICKER_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: OWL_DTPICKER_SCROLL_STRATEGY_PROVIDER_FACTORY\n};\nclass OwlDateTimeComponent extends OwlDateTime {\n  get startAt() {\n    // If an explicit startAt is set we start there, otherwise we start at whatever the currently\n    // selected value is.\n    if (this._startAt) {\n      return this._startAt;\n    }\n    if (this._dtInput) {\n      if (this._dtInput.selectMode === 'single') {\n        return this._dtInput.value || null;\n      } else if (this._dtInput.selectMode === 'range' || this._dtInput.selectMode === 'rangeFrom') {\n        return this._dtInput.values[0] || null;\n      } else if (this._dtInput.selectMode === 'rangeTo') {\n        return this._dtInput.values[1] || null;\n      }\n    } else {\n      return null;\n    }\n  }\n  set startAt(date) {\n    this._startAt = this.getValidDate(this.dateTimeAdapter.deserialize(date));\n  }\n  get endAt() {\n    if (this._endAt) {\n      return this._endAt;\n    }\n    if (this._dtInput) {\n      if (this._dtInput.selectMode === 'single') {\n        return this._dtInput.value || null;\n      } else if (this._dtInput.selectMode === 'range' || this._dtInput.selectMode === 'rangeFrom') {\n        return this._dtInput.values[1] || null;\n      }\n    } else {\n      return null;\n    }\n  }\n  set endAt(date) {\n    this._endAt = this.getValidDate(this.dateTimeAdapter.deserialize(date));\n  }\n  get pickerType() {\n    return this._pickerType;\n  }\n  set pickerType(val) {\n    if (val !== this._pickerType) {\n      this._pickerType = val;\n      if (this._dtInput) {\n        this._dtInput.formatNativeInputValue();\n      }\n    }\n  }\n  get pickerMode() {\n    return this._pickerMode;\n  }\n  set pickerMode(mode) {\n    if (mode === 'popup') {\n      this._pickerMode = mode;\n    } else {\n      this._pickerMode = 'dialog';\n    }\n  }\n  get disabled() {\n    return this._disabled === undefined && this._dtInput ? this._dtInput.disabled : !!this._disabled;\n  }\n  set disabled(value) {\n    value = coerceBooleanProperty(value);\n    if (value !== this._disabled) {\n      this._disabled = value;\n      this.disabledChange.next(value);\n    }\n  }\n  get opened() {\n    return this._opened;\n  }\n  set opened(val) {\n    val ? this.open() : this.close();\n  }\n  get dtInput() {\n    return this._dtInput;\n  }\n  get selected() {\n    return this._selected;\n  }\n  set selected(value) {\n    this._selected = value;\n    this.changeDetector.markForCheck();\n  }\n  get selecteds() {\n    return this._selecteds;\n  }\n  set selecteds(values) {\n    this._selecteds = values;\n    this.changeDetector.markForCheck();\n  }\n  /** The minimum selectable date. */\n  get minDateTime() {\n    return this._dtInput && this._dtInput.min;\n  }\n  /** The maximum selectable date. */\n  get maxDateTime() {\n    return this._dtInput && this._dtInput.max;\n  }\n  get dateTimeFilter() {\n    return this._dtInput && this._dtInput.dateTimeFilter;\n  }\n  get selectMode() {\n    return this._dtInput.selectMode;\n  }\n  get isInSingleMode() {\n    return this._dtInput.isInSingleMode;\n  }\n  get isInRangeMode() {\n    return this._dtInput.isInRangeMode;\n  }\n  constructor(overlay, viewContainerRef, dialogService, ngZone, changeDetector, dateTimeAdapter, defaultScrollStrategy, dateTimeFormats, document) {\n    super(dateTimeAdapter, dateTimeFormats);\n    this.overlay = overlay;\n    this.viewContainerRef = viewContainerRef;\n    this.dialogService = dialogService;\n    this.ngZone = ngZone;\n    this.changeDetector = changeDetector;\n    this.dateTimeAdapter = dateTimeAdapter;\n    this.dateTimeFormats = dateTimeFormats;\n    this.document = document;\n    /** Custom class for the picker backdrop. */\n    this.backdropClass = [];\n    /** Custom class for the picker overlay pane. */\n    this.panelClass = [];\n    /**\n     * Set the type of the dateTime picker\n     *      'both' -- show both calendar and timer\n     *      'calendar' -- show only calendar\n     *      'timer' -- show only timer\n     */\n    this._pickerType = 'both';\n    /**\n     * Whether the picker open as a dialog\n     */\n    this._pickerMode = 'popup';\n    /** Whether the calendar is open. */\n    this._opened = false;\n    /**\n     * Callback when the picker is closed\n     * */\n    this.afterPickerClosed = new EventEmitter();\n    /**\n     * Callback before the picker is open\n     * */\n    this.beforePickerOpen = new EventEmitter();\n    /**\n     * Callback when the picker is open\n     * */\n    this.afterPickerOpen = new EventEmitter();\n    /**\n     * Emits selected year in multi-year view\n     * This doesn't imply a change on the selected date.\n     * */\n    this.yearSelected = new EventEmitter();\n    /**\n     * Emits selected month in year view\n     * This doesn't imply a change on the selected date.\n     * */\n    this.monthSelected = new EventEmitter();\n    /**\n     * Emits selected date\n     * */\n    this.dateSelected = new EventEmitter();\n    /**\n     * Emit when the selected value has been confirmed\n     * */\n    this.confirmSelectedChange = new EventEmitter();\n    /**\n     * Emits when the date time picker is disabled.\n     * */\n    this.disabledChange = new EventEmitter();\n    this.dtInputSub = Subscription.EMPTY;\n    this.hidePickerStreamSub = Subscription.EMPTY;\n    this.confirmSelectedStreamSub = Subscription.EMPTY;\n    this.pickerOpenedStreamSub = Subscription.EMPTY;\n    this.pickerBeforeOpenedStreamSub = Subscription.EMPTY;\n    /** The element that was focused before the date time picker was opened. */\n    this.focusedElementBeforeOpen = null;\n    this._selecteds = [];\n    this.defaultScrollStrategy = defaultScrollStrategy;\n  }\n  ngOnInit() {}\n  ngOnDestroy() {\n    this.close();\n    this.dtInputSub.unsubscribe();\n    this.disabledChange.complete();\n    if (this.popupRef) {\n      this.popupRef.dispose();\n    }\n  }\n  registerInput(input) {\n    if (this._dtInput) {\n      throw Error('A Owl DateTimePicker can only be associated with a single input.');\n    }\n    this._dtInput = input;\n    this.dtInputSub = this._dtInput.valueChange.subscribe(value => {\n      if (Array.isArray(value)) {\n        this.selecteds = value;\n      } else {\n        this.selected = value;\n      }\n    });\n  }\n  open() {\n    if (this._opened || this.disabled) {\n      return;\n    }\n    if (!this._dtInput) {\n      throw Error('Attempted to open an DateTimePicker with no associated input.');\n    }\n    if (this.document) {\n      this.focusedElementBeforeOpen = this.document.activeElement;\n    }\n    // reset the picker selected value\n    if (this.isInSingleMode) {\n      this.selected = this._dtInput.value;\n    } else if (this.isInRangeMode) {\n      this.selecteds = this._dtInput.values;\n    }\n    // when the picker is open , we make sure the picker's current selected time value\n    // is the same as the _startAt time value.\n    if (this.selected && this.pickerType !== 'calendar' && this._startAt) {\n      this.selected = this.dateTimeAdapter.createDate(this.dateTimeAdapter.getYear(this.selected), this.dateTimeAdapter.getMonth(this.selected), this.dateTimeAdapter.getDate(this.selected), this.dateTimeAdapter.getHours(this._startAt), this.dateTimeAdapter.getMinutes(this._startAt), this.dateTimeAdapter.getSeconds(this._startAt));\n    }\n    this.pickerMode === 'dialog' ? this.openAsDialog() : this.openAsPopup();\n    this.pickerContainer.picker = this;\n    // Listen to picker container's hidePickerStream\n    this.hidePickerStreamSub = this.pickerContainer.hidePickerStream.subscribe(() => {\n      this.close();\n    });\n    // Listen to picker container's confirmSelectedStream\n    this.confirmSelectedStreamSub = this.pickerContainer.confirmSelectedStream.subscribe(event => {\n      this.confirmSelect(event);\n    });\n  }\n  /**\n   * Selects the given date\n   */\n  select(date) {\n    if (Array.isArray(date)) {\n      this.selecteds = [...date];\n    } else {\n      this.selected = date;\n    }\n    /**\n     * Cases in which automatically confirm the select when date or dates are selected:\n     * 1) picker mode is NOT 'dialog'\n     * 2) picker type is 'calendar' and selectMode is 'single'.\n     * 3) picker type is 'calendar' and selectMode is 'range' and\n     *    the 'selecteds' has 'from'(selecteds[0]) and 'to'(selecteds[1]) values.\n     * 4) selectMode is 'rangeFrom' and selecteds[0] has value.\n     * 5) selectMode is 'rangeTo' and selecteds[1] has value.\n     * */\n    if (this.pickerMode !== 'dialog' && this.pickerType === 'calendar' && (this.selectMode === 'single' && this.selected || this.selectMode === 'rangeFrom' && this.selecteds[0] || this.selectMode === 'rangeTo' && this.selecteds[1] || this.selectMode === 'range' && this.selecteds[0] && this.selecteds[1])) {\n      this.confirmSelect();\n    }\n  }\n  /**\n   * Emits the selected year in multi-year view\n   * */\n  selectYear(normalizedYear) {\n    this.yearSelected.emit(normalizedYear);\n  }\n  /**\n   * Emits selected month in year view\n   * */\n  selectMonth(normalizedMonth) {\n    this.monthSelected.emit(normalizedMonth);\n  }\n  /**\n   * Emits the selected date\n   * */\n  selectDate(normalizedDate) {\n    this.dateSelected.emit(normalizedDate);\n  }\n  /**\n   * Hide the picker\n   */\n  close() {\n    if (!this._opened) {\n      return;\n    }\n    if (this.popupRef && this.popupRef.hasAttached()) {\n      this.popupRef.detach();\n    }\n    if (this.pickerContainerPortal && this.pickerContainerPortal.isAttached) {\n      this.pickerContainerPortal.detach();\n    }\n    if (this.hidePickerStreamSub) {\n      this.hidePickerStreamSub.unsubscribe();\n      this.hidePickerStreamSub = null;\n    }\n    if (this.confirmSelectedStreamSub) {\n      this.confirmSelectedStreamSub.unsubscribe();\n      this.confirmSelectedStreamSub = null;\n    }\n    if (this.pickerBeforeOpenedStreamSub) {\n      this.pickerBeforeOpenedStreamSub.unsubscribe();\n      this.pickerBeforeOpenedStreamSub = null;\n    }\n    if (this.pickerOpenedStreamSub) {\n      this.pickerOpenedStreamSub.unsubscribe();\n      this.pickerOpenedStreamSub = null;\n    }\n    if (this.dialogRef) {\n      this.dialogRef.close();\n      this.dialogRef = null;\n    }\n    const completeClose = () => {\n      if (this._opened) {\n        this._opened = false;\n        const selected = this.selected || this.selecteds;\n        this.afterPickerClosed.emit(selected);\n        this.focusedElementBeforeOpen = null;\n      }\n    };\n    if (this.focusedElementBeforeOpen && typeof this.focusedElementBeforeOpen.focus === 'function') {\n      // Because IE moves focus asynchronously, we can't count on it being restored before we've\n      // marked the datepicker as closed. If the event fires out of sequence and the element that\n      // we're refocusing opens the datepicker on focus, the user could be stuck with not being\n      // able to close the calendar at all. We work around it by making the logic, that marks\n      // the datepicker as closed, async as well.\n      this.focusedElementBeforeOpen.focus();\n      setTimeout(completeClose);\n    } else {\n      completeClose();\n    }\n  }\n  /**\n   * Confirm the selected value\n   */\n  confirmSelect(event) {\n    if (this.isInSingleMode) {\n      const selected = this.selected || this.startAt || this.dateTimeAdapter.now();\n      this.confirmSelectedChange.emit(selected);\n    } else if (this.isInRangeMode) {\n      this.confirmSelectedChange.emit(this.selecteds);\n    }\n    this.close();\n    return;\n  }\n  /**\n   * Open the picker as a dialog\n   */\n  openAsDialog() {\n    this.dialogRef = this.dialogService.open(OwlDateTimeContainerComponent, {\n      autoFocus: false,\n      backdropClass: ['cdk-overlay-dark-backdrop', ...coerceArray(this.backdropClass)],\n      paneClass: ['owl-dt-dialog', ...coerceArray(this.panelClass)],\n      viewContainerRef: this.viewContainerRef,\n      scrollStrategy: this.scrollStrategy || this.defaultScrollStrategy()\n    });\n    this.pickerContainer = this.dialogRef.componentInstance;\n    this.dialogRef.beforeOpen().subscribe(() => {\n      this.beforePickerOpen.emit(null);\n    });\n    this.dialogRef.afterOpen().subscribe(() => {\n      this.afterPickerOpen.emit(null);\n      this._opened = true;\n    });\n    this.dialogRef.afterClosed().subscribe(() => this.close());\n  }\n  /**\n   * Open the picker as popup\n   */\n  openAsPopup() {\n    if (!this.pickerContainerPortal) {\n      this.pickerContainerPortal = new ComponentPortal(OwlDateTimeContainerComponent, this.viewContainerRef);\n    }\n    if (!this.popupRef) {\n      this.createPopup();\n    }\n    if (!this.popupRef.hasAttached()) {\n      const componentRef = this.popupRef.attach(this.pickerContainerPortal);\n      this.pickerContainer = componentRef.instance;\n      // Update the position once the calendar has rendered.\n      this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n        this.popupRef.updatePosition();\n      });\n      this.pickerBeforeOpenedStreamSub = this.pickerContainer.beforePickerOpenedStream.pipe(take(1)).subscribe(() => {\n        this.beforePickerOpen.emit(null);\n      });\n      // emit open stream\n      this.pickerOpenedStreamSub = this.pickerContainer.pickerOpenedStream.pipe(take(1)).subscribe(() => {\n        this.afterPickerOpen.emit(null);\n        this._opened = true;\n      });\n    }\n  }\n  createPopup() {\n    const overlayConfig = new OverlayConfig({\n      positionStrategy: this.createPopupPositionStrategy(),\n      hasBackdrop: true,\n      backdropClass: ['cdk-overlay-transparent-backdrop', ...coerceArray(this.backdropClass)],\n      scrollStrategy: this.scrollStrategy || this.defaultScrollStrategy(),\n      panelClass: ['owl-dt-popup', ...coerceArray(this.panelClass)]\n    });\n    this.popupRef = this.overlay.create(overlayConfig);\n    merge(this.popupRef.backdropClick(), this.popupRef.detachments(), this.popupRef.keydownEvents().pipe(filter$1(event => event.keyCode === ESCAPE || this._dtInput && event.altKey && event.keyCode === UP_ARROW))).subscribe(() => this.close());\n  }\n  /**\n   * Create the popup PositionStrategy.\n   * */\n  createPopupPositionStrategy() {\n    return this.overlay.position().flexibleConnectedTo(this._dtInput.elementRef).withTransformOriginOn('.owl-dt-container').withFlexibleDimensions(false).withPush(false).withPositions([{\n      originX: 'start',\n      originY: 'bottom',\n      overlayX: 'start',\n      overlayY: 'top'\n    }, {\n      originX: 'start',\n      originY: 'top',\n      overlayX: 'start',\n      overlayY: 'bottom'\n    }, {\n      originX: 'end',\n      originY: 'bottom',\n      overlayX: 'end',\n      overlayY: 'top'\n    }, {\n      originX: 'end',\n      originY: 'top',\n      overlayX: 'end',\n      overlayY: 'bottom'\n    }, {\n      originX: 'start',\n      originY: 'top',\n      overlayX: 'start',\n      overlayY: 'top',\n      offsetY: -176\n    }, {\n      originX: 'start',\n      originY: 'top',\n      overlayX: 'start',\n      overlayY: 'top',\n      offsetY: -352\n    }]);\n  }\n  static #_ = this.ɵfac = function OwlDateTimeComponent_Factory(t) {\n    return new (t || OwlDateTimeComponent)(i0.ɵɵdirectiveInject(i1.Overlay), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(OwlDialogService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(DateTimeAdapter, 8), i0.ɵɵdirectiveInject(OWL_DTPICKER_SCROLL_STRATEGY), i0.ɵɵdirectiveInject(OWL_DATE_TIME_FORMATS, 8), i0.ɵɵdirectiveInject(DOCUMENT, 8));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OwlDateTimeComponent,\n    selectors: [[\"owl-date-time\"]],\n    inputs: {\n      backdropClass: \"backdropClass\",\n      panelClass: \"panelClass\",\n      startAt: \"startAt\",\n      endAt: \"endAt\",\n      pickerType: \"pickerType\",\n      pickerMode: \"pickerMode\",\n      disabled: \"disabled\",\n      opened: \"opened\",\n      scrollStrategy: \"scrollStrategy\"\n    },\n    outputs: {\n      afterPickerClosed: \"afterPickerClosed\",\n      beforePickerOpen: \"beforePickerOpen\",\n      afterPickerOpen: \"afterPickerOpen\",\n      yearSelected: \"yearSelected\",\n      monthSelected: \"monthSelected\",\n      dateSelected: \"dateSelected\"\n    },\n    exportAs: [\"owlDateTime\"],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function OwlDateTimeComponent_Template(rf, ctx) {},\n    changeDetection: 0\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlDateTimeComponent, [{\n    type: Component,\n    args: [{\n      selector: 'owl-date-time',\n      exportAs: 'owlDateTime',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      preserveWhitespaces: false,\n      template: \"\"\n    }]\n  }], () => [{\n    type: i1.Overlay\n  }, {\n    type: i0.ViewContainerRef\n  }, {\n    type: OwlDialogService\n  }, {\n    type: i0.NgZone\n  }, {\n    type: i0.ChangeDetectorRef\n  }, {\n    type: DateTimeAdapter,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [OWL_DTPICKER_SCROLL_STRATEGY]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [OWL_DATE_TIME_FORMATS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }], {\n    backdropClass: [{\n      type: Input\n    }],\n    panelClass: [{\n      type: Input\n    }],\n    startAt: [{\n      type: Input\n    }],\n    endAt: [{\n      type: Input\n    }],\n    pickerType: [{\n      type: Input\n    }],\n    pickerMode: [{\n      type: Input\n    }],\n    disabled: [{\n      type: Input\n    }],\n    opened: [{\n      type: Input\n    }],\n    scrollStrategy: [{\n      type: Input\n    }],\n    afterPickerClosed: [{\n      type: Output\n    }],\n    beforePickerOpen: [{\n      type: Output\n    }],\n    afterPickerOpen: [{\n      type: Output\n    }],\n    yearSelected: [{\n      type: Output\n    }],\n    monthSelected: [{\n      type: Output\n    }],\n    dateSelected: [{\n      type: Output\n    }]\n  });\n})();\n\n/**\n * date-time-picker-input.directive\n */\nconst OWL_DATETIME_VALUE_ACCESSOR$1 = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => OwlDateTimeInputDirective),\n  multi: true\n};\nconst OWL_DATETIME_VALIDATORS = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => OwlDateTimeInputDirective),\n  multi: true\n};\nclass OwlDateTimeInputDirective {\n  get required() {\n    return this._required;\n  }\n  set required(value) {\n    this._required = value === '' || value;\n    this.validatorOnChange();\n  }\n  /**\n   * The date time picker that this input is associated with.\n   * */\n  set owlDateTime(value) {\n    this.registerDateTimePicker(value);\n  }\n  /**\n   * A function to filter date time\n   */\n  set owlDateTimeFilter(filter) {\n    this._dateTimeFilter = filter;\n    this.validatorOnChange();\n  }\n  get dateTimeFilter() {\n    return this._dateTimeFilter;\n  }\n  get disabled() {\n    return !!this._disabled;\n  }\n  set disabled(value) {\n    const newValue = coerceBooleanProperty(value);\n    const element = this.elmRef.nativeElement;\n    if (this._disabled !== newValue) {\n      this._disabled = newValue;\n      this.disabledChange.emit(newValue);\n    }\n    // We need to null check the `blur` method, because it's undefined during SSR.\n    if (newValue && element.blur) {\n      // Normally, native input elements automatically blur if they turn disabled. This behavior\n      // is problematic, because it would mean that it triggers another change detection cycle,\n      // which then causes a changed after checked error if the input element was focused before.\n      element.blur();\n    }\n  }\n  get min() {\n    return this._min;\n  }\n  set min(value) {\n    this._min = this.getValidDate(this.dateTimeAdapter.deserialize(value));\n    this.validatorOnChange();\n  }\n  get max() {\n    return this._max;\n  }\n  set max(value) {\n    this._max = this.getValidDate(this.dateTimeAdapter.deserialize(value));\n    this.validatorOnChange();\n  }\n  get selectMode() {\n    return this._selectMode;\n  }\n  set selectMode(mode) {\n    if (mode !== 'single' && mode !== 'range' && mode !== 'rangeFrom' && mode !== 'rangeTo') {\n      throw Error('OwlDateTime Error: invalid selectMode value!');\n    }\n    this._selectMode = mode;\n  }\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    this.lastValueValid = !value || this.dateTimeAdapter.isValid(value);\n    value = this.getValidDate(value);\n    const oldDate = this._value;\n    this._value = value;\n    // set the input property 'value'\n    this.formatNativeInputValue();\n    // check if the input value changed\n    if (!this.dateTimeAdapter.isEqual(oldDate, value)) {\n      this.valueChange.emit(value);\n    }\n  }\n  get values() {\n    return this._values;\n  }\n  set values(values) {\n    if (values && values.length > 0) {\n      this._values = values.map(v => {\n        v = this.dateTimeAdapter.deserialize(v);\n        return this.getValidDate(v);\n      });\n      this.lastValueValid = (!this._values[0] || this.dateTimeAdapter.isValid(this._values[0])) && (!this._values[1] || this.dateTimeAdapter.isValid(this._values[1]));\n    } else {\n      this._values = [];\n      this.lastValueValid = true;\n    }\n    // set the input property 'value'\n    this.formatNativeInputValue();\n    this.valueChange.emit(this._values);\n  }\n  get elementRef() {\n    return this.elmRef;\n  }\n  get isInSingleMode() {\n    return this._selectMode === 'single';\n  }\n  get isInRangeMode() {\n    return this._selectMode === 'range' || this._selectMode === 'rangeFrom' || this._selectMode === 'rangeTo';\n  }\n  get owlDateTimeInputAriaHaspopup() {\n    return true;\n  }\n  get owlDateTimeInputAriaOwns() {\n    return this.dtPicker.opened && this.dtPicker.id || null;\n  }\n  get minIso8601() {\n    return this.min ? this.dateTimeAdapter.toIso8601(this.min) : null;\n  }\n  get maxIso8601() {\n    return this.max ? this.dateTimeAdapter.toIso8601(this.max) : null;\n  }\n  get owlDateTimeInputDisabled() {\n    return this.disabled;\n  }\n  constructor(elmRef, renderer, dateTimeAdapter, dateTimeFormats) {\n    this.elmRef = elmRef;\n    this.renderer = renderer;\n    this.dateTimeAdapter = dateTimeAdapter;\n    this.dateTimeFormats = dateTimeFormats;\n    /**\n     * The picker's select mode\n     */\n    this._selectMode = 'single';\n    /**\n     * The character to separate the 'from' and 'to' in input value\n     */\n    this.rangeSeparator = '-';\n    this._values = [];\n    /**\n     * Callback to invoke when `change` event is fired on this `<input>`\n     * */\n    this.dateTimeChange = new EventEmitter();\n    /**\n     * Callback to invoke when an `input` event is fired on this `<input>`.\n     * */\n    this.dateTimeInput = new EventEmitter();\n    this.dtPickerSub = Subscription.EMPTY;\n    this.localeSub = Subscription.EMPTY;\n    this.lastValueValid = true;\n    this.onModelChange = () => {};\n    this.onModelTouched = () => {};\n    this.validatorOnChange = () => {};\n    /** The form control validator for whether the input parses. */\n    this.parseValidator = () => {\n      return this.lastValueValid ? null : {\n        owlDateTimeParse: {\n          text: this.elmRef.nativeElement.value\n        }\n      };\n    };\n    /** The form control validator for the min date. */\n    this.minValidator = control => {\n      if (this.isInSingleMode) {\n        const controlValue = this.getValidDate(this.dateTimeAdapter.deserialize(control.value));\n        return !this.min || !controlValue || this.dateTimeAdapter.compare(this.min, controlValue) <= 0 ? null : {\n          owlDateTimeMin: {\n            min: this.min,\n            actual: controlValue\n          }\n        };\n      } else if (this.isInRangeMode && control.value) {\n        const controlValueFrom = this.getValidDate(this.dateTimeAdapter.deserialize(control.value[0]));\n        const controlValueTo = this.getValidDate(this.dateTimeAdapter.deserialize(control.value[1]));\n        return !this.min || !controlValueFrom || !controlValueTo || this.dateTimeAdapter.compare(this.min, controlValueFrom) <= 0 ? null : {\n          owlDateTimeMin: {\n            min: this.min,\n            actual: [controlValueFrom, controlValueTo]\n          }\n        };\n      }\n    };\n    /** The form control validator for the max date. */\n    this.maxValidator = control => {\n      if (this.isInSingleMode) {\n        const controlValue = this.getValidDate(this.dateTimeAdapter.deserialize(control.value));\n        return !this.max || !controlValue || this.dateTimeAdapter.compare(this.max, controlValue) >= 0 ? null : {\n          owlDateTimeMax: {\n            max: this.max,\n            actual: controlValue\n          }\n        };\n      } else if (this.isInRangeMode && control.value) {\n        const controlValueFrom = this.getValidDate(this.dateTimeAdapter.deserialize(control.value[0]));\n        const controlValueTo = this.getValidDate(this.dateTimeAdapter.deserialize(control.value[1]));\n        return !this.max || !controlValueFrom || !controlValueTo || this.dateTimeAdapter.compare(this.max, controlValueTo) >= 0 ? null : {\n          owlDateTimeMax: {\n            max: this.max,\n            actual: [controlValueFrom, controlValueTo]\n          }\n        };\n      }\n    };\n    /** The form control validator for the date filter. */\n    this.filterValidator = control => {\n      const controlValue = this.getValidDate(this.dateTimeAdapter.deserialize(control.value));\n      return !this._dateTimeFilter || !controlValue || this._dateTimeFilter(controlValue) ? null : {\n        owlDateTimeFilter: true\n      };\n    };\n    /**\n     * The form control validator for the range.\n     * Check whether the 'before' value is before the 'to' value\n     * */\n    this.rangeValidator = control => {\n      if (this.isInSingleMode || !control.value) {\n        return null;\n      }\n      const controlValueFrom = this.getValidDate(this.dateTimeAdapter.deserialize(control.value[0]));\n      const controlValueTo = this.getValidDate(this.dateTimeAdapter.deserialize(control.value[1]));\n      return !controlValueFrom || !controlValueTo || this.dateTimeAdapter.compare(controlValueFrom, controlValueTo) <= 0 ? null : {\n        owlDateTimeRange: true\n      };\n    };\n    /**\n     * The form control validator for the range when required.\n     * Check whether the 'before' and 'to' values are present\n     * */\n    this.requiredRangeValidator = control => {\n      if (this.isInSingleMode || !control.value || !this.required) {\n        return null;\n      }\n      const controlValueFrom = this.getValidDate(this.dateTimeAdapter.deserialize(control.value[0]));\n      const controlValueTo = this.getValidDate(this.dateTimeAdapter.deserialize(control.value[1]));\n      return !controlValueFrom || !controlValueTo ? {\n        owlRequiredDateTimeRange: [controlValueFrom, controlValueTo]\n      } : null;\n    };\n    /** The combined form control validator for this input. */\n    this.validator = Validators.compose([this.parseValidator, this.minValidator, this.maxValidator, this.filterValidator, this.rangeValidator, this.requiredRangeValidator]);\n    /** Emits when the value changes (either due to user input or programmatic change). */\n    this.valueChange = new EventEmitter();\n    /** Emits when the disabled state has changed */\n    this.disabledChange = new EventEmitter();\n    if (!this.dateTimeAdapter) {\n      throw Error(`OwlDateTimePicker: No provider found for DateTimePicker. You must import one of the following ` + `modules at your application root: OwlNativeDateTimeModule, OwlMomentDateTimeModule, or provide a ` + `custom implementation.`);\n    }\n    if (!this.dateTimeFormats) {\n      throw Error(`OwlDateTimePicker: No provider found for OWL_DATE_TIME_FORMATS. You must import one of the following ` + `modules at your application root: OwlNativeDateTimeModule, OwlMomentDateTimeModule, or provide a ` + `custom implementation.`);\n    }\n    this.localeSub = this.dateTimeAdapter.localeChanges.subscribe(() => {\n      this.value = this.value;\n    });\n  }\n  ngOnInit() {\n    if (!this.dtPicker) {\n      throw Error(`OwlDateTimePicker: the picker input doesn't have any associated owl-date-time component`);\n    }\n  }\n  ngAfterContentInit() {\n    this.dtPickerSub = this.dtPicker.confirmSelectedChange.subscribe(selecteds => {\n      if (Array.isArray(selecteds)) {\n        this.values = selecteds;\n      } else {\n        this.value = selecteds;\n      }\n      this.onModelChange(selecteds);\n      this.onModelTouched();\n      this.dateTimeChange.emit({\n        source: this,\n        value: selecteds,\n        input: this.elmRef.nativeElement\n      });\n      this.dateTimeInput.emit({\n        source: this,\n        value: selecteds,\n        input: this.elmRef.nativeElement\n      });\n    });\n  }\n  ngOnDestroy() {\n    this.dtPickerSub.unsubscribe();\n    this.localeSub.unsubscribe();\n    this.valueChange.complete();\n    this.disabledChange.complete();\n  }\n  writeValue(value) {\n    if (this.isInSingleMode) {\n      this.value = value;\n    } else {\n      this.values = value;\n    }\n  }\n  registerOnChange(fn) {\n    this.onModelChange = fn;\n  }\n  registerOnTouched(fn) {\n    this.onModelTouched = fn;\n  }\n  setDisabledState(isDisabled) {\n    this.disabled = isDisabled;\n  }\n  validate(c) {\n    return this.validator ? this.validator(c) : null;\n  }\n  registerOnValidatorChange(fn) {\n    this.validatorOnChange = fn;\n  }\n  /**\n   * Open the picker when user hold alt + DOWN_ARROW\n   * */\n  handleKeydownOnHost(event) {\n    if (event.altKey && event.keyCode === DOWN_ARROW) {\n      this.dtPicker.open();\n      event.preventDefault();\n    }\n  }\n  handleBlurOnHost(event) {\n    this.onModelTouched();\n  }\n  handleInputOnHost(event) {\n    const value = event.target.value;\n    if (this._selectMode === 'single') {\n      this.changeInputInSingleMode(value);\n    } else if (this._selectMode === 'range') {\n      this.changeInputInRangeMode(value);\n    } else {\n      this.changeInputInRangeFromToMode(value);\n    }\n  }\n  handleChangeOnHost(event) {\n    let v;\n    if (this.isInSingleMode) {\n      v = this.value;\n    } else if (this.isInRangeMode) {\n      v = this.values;\n    }\n    this.dateTimeChange.emit({\n      source: this,\n      value: v,\n      input: this.elmRef.nativeElement\n    });\n  }\n  /**\n   * Set the native input property 'value'\n   */\n  formatNativeInputValue() {\n    if (this.isInSingleMode) {\n      this.renderer.setProperty(this.elmRef.nativeElement, 'value', this._value ? this.dateTimeAdapter.format(this._value, this.dtPicker.formatString) : '');\n    } else if (this.isInRangeMode) {\n      if (this._values && this.values.length > 0) {\n        const from = this._values[0];\n        const to = this._values[1];\n        const fromFormatted = from ? this.dateTimeAdapter.format(from, this.dtPicker.formatString) : '';\n        const toFormatted = to ? this.dateTimeAdapter.format(to, this.dtPicker.formatString) : '';\n        if (!fromFormatted && !toFormatted) {\n          this.renderer.setProperty(this.elmRef.nativeElement, 'value', null);\n        } else {\n          if (this._selectMode === 'range') {\n            this.renderer.setProperty(this.elmRef.nativeElement, 'value', fromFormatted + ' ' + this.rangeSeparator + ' ' + toFormatted);\n          } else if (this._selectMode === 'rangeFrom') {\n            this.renderer.setProperty(this.elmRef.nativeElement, 'value', fromFormatted);\n          } else if (this._selectMode === 'rangeTo') {\n            this.renderer.setProperty(this.elmRef.nativeElement, 'value', toFormatted);\n          }\n        }\n      } else {\n        this.renderer.setProperty(this.elmRef.nativeElement, 'value', '');\n      }\n    }\n    return;\n  }\n  /**\n   * Register the relationship between this input and its picker component\n   */\n  registerDateTimePicker(picker) {\n    if (picker) {\n      this.dtPicker = picker;\n      this.dtPicker.registerInput(this);\n    }\n  }\n  /**\n   * Convert a given obj to a valid date object\n   */\n  getValidDate(obj) {\n    return this.dateTimeAdapter.isDateInstance(obj) && this.dateTimeAdapter.isValid(obj) ? obj : null;\n  }\n  /**\n   * Convert a time string to a date-time string\n   * When pickerType is 'timer', the value in the picker's input is a time string.\n   * The dateTimeAdapter parse fn could not parse a time string to a Date Object.\n   * Therefore we need this fn to convert a time string to a date-time string.\n   */\n  convertTimeStringToDateTimeString(timeString, dateTime) {\n    if (timeString) {\n      const v = dateTime || this.dateTimeAdapter.now();\n      const dateString = this.dateTimeAdapter.format(v, this.dateTimeFormats.datePickerInput);\n      return dateString + ' ' + timeString;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Handle input change in single mode\n   */\n  changeInputInSingleMode(inputValue) {\n    let value = inputValue;\n    if (this.dtPicker.pickerType === 'timer') {\n      value = this.convertTimeStringToDateTimeString(value, this.value);\n    }\n    let result = this.dateTimeAdapter.parse(value, this.dateTimeFormats.parseInput);\n    this.lastValueValid = !result || this.dateTimeAdapter.isValid(result);\n    result = this.getValidDate(result);\n    // if the newValue is the same as the oldValue, we intend to not fire the valueChange event\n    // result equals to null means there is input event, but the input value is invalid\n    if (!this.isSameValue(result, this._value) || result === null) {\n      this._value = result;\n      this.valueChange.emit(result);\n      this.onModelChange(result);\n      this.dateTimeInput.emit({\n        source: this,\n        value: result,\n        input: this.elmRef.nativeElement\n      });\n    }\n  }\n  /**\n   * Handle input change in rangeFrom or rangeTo mode\n   */\n  changeInputInRangeFromToMode(inputValue) {\n    const originalValue = this._selectMode === 'rangeFrom' ? this._values[0] : this._values[1];\n    if (this.dtPicker.pickerType === 'timer') {\n      inputValue = this.convertTimeStringToDateTimeString(inputValue, originalValue);\n    }\n    let result = this.dateTimeAdapter.parse(inputValue, this.dateTimeFormats.parseInput);\n    this.lastValueValid = !result || this.dateTimeAdapter.isValid(result);\n    result = this.getValidDate(result);\n    // if the newValue is the same as the oldValue, we intend to not fire the valueChange event\n    if (this._selectMode === 'rangeFrom' && this.isSameValue(result, this._values[0]) && result || this._selectMode === 'rangeTo' && this.isSameValue(result, this._values[1]) && result) {\n      return;\n    }\n    this._values = this._selectMode === 'rangeFrom' ? [result, this._values[1]] : [this._values[0], result];\n    this.valueChange.emit(this._values);\n    this.onModelChange(this._values);\n    this.dateTimeInput.emit({\n      source: this,\n      value: this._values,\n      input: this.elmRef.nativeElement\n    });\n  }\n  /**\n   * Handle input change in range mode\n   */\n  changeInputInRangeMode(inputValue) {\n    const selecteds = inputValue.split(this.rangeSeparator);\n    let fromString = selecteds[0];\n    let toString = selecteds[1];\n    if (this.dtPicker.pickerType === 'timer') {\n      fromString = this.convertTimeStringToDateTimeString(fromString, this.values[0]);\n      toString = this.convertTimeStringToDateTimeString(toString, this.values[1]);\n    }\n    let from = this.dateTimeAdapter.parse(fromString, this.dateTimeFormats.parseInput);\n    let to = this.dateTimeAdapter.parse(toString, this.dateTimeFormats.parseInput);\n    this.lastValueValid = (!from || this.dateTimeAdapter.isValid(from)) && (!to || this.dateTimeAdapter.isValid(to));\n    from = this.getValidDate(from);\n    to = this.getValidDate(to);\n    // if the newValue is the same as the oldValue, we intend to not fire the valueChange event\n    if (!this.isSameValue(from, this._values[0]) || !this.isSameValue(to, this._values[1]) || from === null && to === null) {\n      this._values = [from, to];\n      this.valueChange.emit(this._values);\n      this.onModelChange(this._values);\n      this.dateTimeInput.emit({\n        source: this,\n        value: this._values,\n        input: this.elmRef.nativeElement\n      });\n    }\n  }\n  /**\n   * Check if the two value is the same\n   */\n  isSameValue(first, second) {\n    if (first && second) {\n      return this.dateTimeAdapter.compare(first, second) === 0;\n    }\n    return first === second;\n  }\n  static #_ = this.ɵfac = function OwlDateTimeInputDirective_Factory(t) {\n    return new (t || OwlDateTimeInputDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DateTimeAdapter, 8), i0.ɵɵdirectiveInject(OWL_DATE_TIME_FORMATS, 8));\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OwlDateTimeInputDirective,\n    selectors: [[\"input\", \"owlDateTime\", \"\"]],\n    hostVars: 5,\n    hostBindings: function OwlDateTimeInputDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function OwlDateTimeInputDirective_keydown_HostBindingHandler($event) {\n          return ctx.handleKeydownOnHost($event);\n        })(\"blur\", function OwlDateTimeInputDirective_blur_HostBindingHandler($event) {\n          return ctx.handleBlurOnHost($event);\n        })(\"input\", function OwlDateTimeInputDirective_input_HostBindingHandler($event) {\n          return ctx.handleInputOnHost($event);\n        })(\"change\", function OwlDateTimeInputDirective_change_HostBindingHandler($event) {\n          return ctx.handleChangeOnHost($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"disabled\", ctx.owlDateTimeInputDisabled);\n        i0.ɵɵattribute(\"aria-haspopup\", ctx.owlDateTimeInputAriaHaspopup)(\"aria-owns\", ctx.owlDateTimeInputAriaOwns)(\"min\", ctx.minIso8601)(\"max\", ctx.maxIso8601);\n      }\n    },\n    inputs: {\n      required: \"required\",\n      owlDateTime: \"owlDateTime\",\n      owlDateTimeFilter: \"owlDateTimeFilter\",\n      _disabled: \"_disabled\",\n      min: \"min\",\n      max: \"max\",\n      selectMode: \"selectMode\",\n      rangeSeparator: \"rangeSeparator\",\n      value: \"value\",\n      values: \"values\"\n    },\n    outputs: {\n      dateTimeChange: \"dateTimeChange\",\n      dateTimeInput: \"dateTimeInput\"\n    },\n    exportAs: [\"owlDateTimeInput\"],\n    features: [i0.ɵɵProvidersFeature([OWL_DATETIME_VALUE_ACCESSOR$1, OWL_DATETIME_VALIDATORS])]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlDateTimeInputDirective, [{\n    type: Directive,\n    args: [{\n      selector: 'input[owlDateTime]',\n      exportAs: 'owlDateTimeInput',\n      host: {\n        '(keydown)': 'handleKeydownOnHost($event)',\n        '(blur)': 'handleBlurOnHost($event)',\n        '(input)': 'handleInputOnHost($event)',\n        '(change)': 'handleChangeOnHost($event)',\n        '[attr.aria-haspopup]': 'owlDateTimeInputAriaHaspopup',\n        '[attr.aria-owns]': 'owlDateTimeInputAriaOwns',\n        '[attr.min]': 'minIso8601',\n        '[attr.max]': 'maxIso8601',\n        '[disabled]': 'owlDateTimeInputDisabled'\n      },\n      providers: [OWL_DATETIME_VALUE_ACCESSOR$1, OWL_DATETIME_VALIDATORS]\n    }]\n  }], () => [{\n    type: i0.ElementRef\n  }, {\n    type: i0.Renderer2\n  }, {\n    type: DateTimeAdapter,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [OWL_DATE_TIME_FORMATS]\n    }]\n  }], {\n    required: [{\n      type: Input\n    }],\n    owlDateTime: [{\n      type: Input\n    }],\n    owlDateTimeFilter: [{\n      type: Input\n    }],\n    _disabled: [{\n      type: Input\n    }],\n    min: [{\n      type: Input\n    }],\n    max: [{\n      type: Input\n    }],\n    selectMode: [{\n      type: Input\n    }],\n    rangeSeparator: [{\n      type: Input\n    }],\n    value: [{\n      type: Input\n    }],\n    values: [{\n      type: Input\n    }],\n    dateTimeChange: [{\n      type: Output\n    }],\n    dateTimeInput: [{\n      type: Output\n    }]\n  });\n})();\n\n/**\n * numberFixedLen.pipe\n */\nclass NumberFixedLenPipe {\n  transform(num, len) {\n    const number = Math.floor(num);\n    const length = Math.floor(len);\n    if (num === null || isNaN(number) || isNaN(length)) {\n      return num;\n    }\n    let numString = number.toString();\n    while (numString.length < length) {\n      numString = '0' + numString;\n    }\n    return numString;\n  }\n  static #_ = this.ɵfac = function NumberFixedLenPipe_Factory(t) {\n    return new (t || NumberFixedLenPipe)();\n  };\n  static #_2 = this.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"numberFixedLen\",\n    type: NumberFixedLenPipe,\n    pure: true\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NumberFixedLenPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'numberFixedLen'\n    }]\n  }], null, null);\n})();\n\n/**\n * date-time-inline.component\n */\nconst OWL_DATETIME_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => OwlDateTimeInlineComponent),\n  multi: true\n};\nclass OwlDateTimeInlineComponent extends OwlDateTime {\n  get pickerType() {\n    return this._pickerType;\n  }\n  set pickerType(val) {\n    if (val !== this._pickerType) {\n      this._pickerType = val;\n    }\n  }\n  get disabled() {\n    return !!this._disabled;\n  }\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n  }\n  get selectMode() {\n    return this._selectMode;\n  }\n  set selectMode(mode) {\n    if (mode !== 'single' && mode !== 'range' && mode !== 'rangeFrom' && mode !== 'rangeTo') {\n      throw Error('OwlDateTime Error: invalid selectMode value!');\n    }\n    this._selectMode = mode;\n  }\n  get startAt() {\n    if (this._startAt) {\n      return this._startAt;\n    }\n    if (this.selectMode === 'single') {\n      return this.value || null;\n    } else if (this.selectMode === 'range' || this.selectMode === 'rangeFrom') {\n      return this.values[0] || null;\n    } else if (this.selectMode === 'rangeTo') {\n      return this.values[1] || null;\n    } else {\n      return null;\n    }\n  }\n  set startAt(date) {\n    this._startAt = this.getValidDate(this.dateTimeAdapter.deserialize(date));\n  }\n  get endAt() {\n    if (this._endAt) {\n      return this._endAt;\n    }\n    if (this.selectMode === 'single') {\n      return this.value || null;\n    } else if (this.selectMode === 'range' || this.selectMode === 'rangeFrom') {\n      return this.values[1] || null;\n    } else {\n      return null;\n    }\n  }\n  set endAt(date) {\n    this._endAt = this.getValidDate(this.dateTimeAdapter.deserialize(date));\n  }\n  get dateTimeFilter() {\n    return this._dateTimeFilter;\n  }\n  set dateTimeFilter(filter) {\n    this._dateTimeFilter = filter;\n  }\n  get minDateTime() {\n    return this._min || null;\n  }\n  set minDateTime(value) {\n    this._min = this.getValidDate(this.dateTimeAdapter.deserialize(value));\n    this.changeDetector.markForCheck();\n  }\n  get maxDateTime() {\n    return this._max || null;\n  }\n  set maxDateTime(value) {\n    this._max = this.getValidDate(this.dateTimeAdapter.deserialize(value));\n    this.changeDetector.markForCheck();\n  }\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    value = this.dateTimeAdapter.deserialize(value);\n    value = this.getValidDate(value);\n    this._value = value;\n    this.selected = value;\n  }\n  get values() {\n    return this._values;\n  }\n  set values(values) {\n    if (values && values.length > 0) {\n      values = values.map(v => {\n        v = this.dateTimeAdapter.deserialize(v);\n        v = this.getValidDate(v);\n        return v ? this.dateTimeAdapter.clone(v) : null;\n      });\n      this._values = [...values];\n      this.selecteds = [...values];\n    } else {\n      this._values = [];\n      this.selecteds = [];\n    }\n  }\n  get selected() {\n    return this._selected;\n  }\n  set selected(value) {\n    this._selected = value;\n    this.changeDetector.markForCheck();\n  }\n  get selecteds() {\n    return this._selecteds;\n  }\n  set selecteds(values) {\n    this._selecteds = values;\n    this.changeDetector.markForCheck();\n  }\n  get opened() {\n    return true;\n  }\n  get pickerMode() {\n    return 'inline';\n  }\n  get isInSingleMode() {\n    return this._selectMode === 'single';\n  }\n  get isInRangeMode() {\n    return this._selectMode === 'range' || this._selectMode === 'rangeFrom' || this._selectMode === 'rangeTo';\n  }\n  get owlDTInlineClass() {\n    return true;\n  }\n  constructor(changeDetector, dateTimeAdapter, dateTimeFormats) {\n    super(dateTimeAdapter, dateTimeFormats);\n    this.changeDetector = changeDetector;\n    this.dateTimeAdapter = dateTimeAdapter;\n    this.dateTimeFormats = dateTimeFormats;\n    /**\n     * Set the type of the dateTime picker\n     *      'both' -- show both calendar and timer\n     *      'calendar' -- show only calendar\n     *      'timer' -- show only timer\n     */\n    this._pickerType = 'both';\n    this._disabled = false;\n    this._selectMode = 'single';\n    this._values = [];\n    /**\n     * Emits selected year in multi-year view\n     * This doesn't imply a change on the selected date.\n     * */\n    this.yearSelected = new EventEmitter();\n    /**\n     * Emits selected month in year view\n     * This doesn't imply a change on the selected date.\n     * */\n    this.monthSelected = new EventEmitter();\n    /**\n     * Emits selected date\n     * */\n    this.dateSelected = new EventEmitter();\n    this._selecteds = [];\n    this.onModelChange = () => {};\n    this.onModelTouched = () => {};\n  }\n  ngOnInit() {\n    this.container.picker = this;\n  }\n  writeValue(value) {\n    if (this.isInSingleMode) {\n      this.value = value;\n      this.container.pickerMoment = value;\n    } else {\n      this.values = value;\n      this.container.pickerMoment = this._values[this.container.activeSelectedIndex];\n    }\n  }\n  registerOnChange(fn) {\n    this.onModelChange = fn;\n  }\n  registerOnTouched(fn) {\n    this.onModelTouched = fn;\n  }\n  setDisabledState(isDisabled) {\n    this.disabled = isDisabled;\n  }\n  select(date) {\n    if (this.disabled) {\n      return;\n    }\n    if (Array.isArray(date)) {\n      this.values = [...date];\n    } else {\n      this.value = date;\n    }\n    this.onModelChange(date);\n    this.onModelTouched();\n  }\n  /**\n   * Emits the selected year in multi-year view\n   * */\n  selectYear(normalizedYear) {\n    this.yearSelected.emit(normalizedYear);\n  }\n  /**\n   * Emits selected month in year view\n   * */\n  selectMonth(normalizedMonth) {\n    this.monthSelected.emit(normalizedMonth);\n  }\n  /**\n   * Emits the selected date\n   * */\n  selectDate(normalizedDate) {\n    this.dateSelected.emit(normalizedDate);\n  }\n  static #_ = this.ɵfac = function OwlDateTimeInlineComponent_Factory(t) {\n    return new (t || OwlDateTimeInlineComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(DateTimeAdapter, 8), i0.ɵɵdirectiveInject(OWL_DATE_TIME_FORMATS, 8));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OwlDateTimeInlineComponent,\n    selectors: [[\"owl-date-time-inline\"]],\n    viewQuery: function OwlDateTimeInlineComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(OwlDateTimeContainerComponent, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function OwlDateTimeInlineComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"owl-dt-inline\", ctx.owlDTInlineClass);\n      }\n    },\n    inputs: {\n      pickerType: \"pickerType\",\n      disabled: \"disabled\",\n      selectMode: \"selectMode\",\n      startAt: \"startAt\",\n      endAt: \"endAt\",\n      dateTimeFilter: [0, \"owlDateTimeFilter\", \"dateTimeFilter\"],\n      minDateTime: [0, \"min\", \"minDateTime\"],\n      maxDateTime: [0, \"max\", \"maxDateTime\"],\n      value: \"value\",\n      values: \"values\"\n    },\n    outputs: {\n      yearSelected: \"yearSelected\",\n      monthSelected: \"monthSelected\",\n      dateSelected: \"dateSelected\"\n    },\n    features: [i0.ɵɵProvidersFeature([OWL_DATETIME_VALUE_ACCESSOR]), i0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 0,\n    template: function OwlDateTimeInlineComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"owl-date-time-container\");\n      }\n    },\n    dependencies: [OwlDateTimeContainerComponent],\n    changeDetection: 0\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlDateTimeInlineComponent, [{\n    type: Component,\n    args: [{\n      selector: 'owl-date-time-inline',\n      host: {\n        '[class.owl-dt-inline]': 'owlDTInlineClass'\n      },\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      preserveWhitespaces: false,\n      providers: [OWL_DATETIME_VALUE_ACCESSOR],\n      template: \"<owl-date-time-container></owl-date-time-container>\"\n    }]\n  }], () => [{\n    type: i0.ChangeDetectorRef\n  }, {\n    type: DateTimeAdapter,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [OWL_DATE_TIME_FORMATS]\n    }]\n  }], {\n    container: [{\n      type: ViewChild,\n      args: [OwlDateTimeContainerComponent, {\n        static: true\n      }]\n    }],\n    pickerType: [{\n      type: Input\n    }],\n    disabled: [{\n      type: Input\n    }],\n    selectMode: [{\n      type: Input\n    }],\n    startAt: [{\n      type: Input\n    }],\n    endAt: [{\n      type: Input\n    }],\n    dateTimeFilter: [{\n      type: Input,\n      args: ['owlDateTimeFilter']\n    }],\n    minDateTime: [{\n      type: Input,\n      args: ['min']\n    }],\n    maxDateTime: [{\n      type: Input,\n      args: ['max']\n    }],\n    value: [{\n      type: Input\n    }],\n    values: [{\n      type: Input\n    }],\n    yearSelected: [{\n      type: Output\n    }],\n    monthSelected: [{\n      type: Output\n    }],\n    dateSelected: [{\n      type: Output\n    }]\n  });\n})();\n\n/**\n * dialog.module\n */\nclass OwlDialogModule {\n  static #_ = this.ɵfac = function OwlDialogModule_Factory(t) {\n    return new (t || OwlDialogModule)();\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: OwlDialogModule\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [OWL_DIALOG_SCROLL_STRATEGY_PROVIDER, OwlDialogService],\n    imports: [CommonModule, A11yModule, OverlayModule, PortalModule]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlDialogModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, A11yModule, OverlayModule, PortalModule],\n      exports: [],\n      declarations: [OwlDialogContainerComponent],\n      providers: [OWL_DIALOG_SCROLL_STRATEGY_PROVIDER, OwlDialogService]\n    }]\n  }], null, null);\n})();\n\n/**\n * date-time.module\n */\nclass OwlDateTimeModule {\n  static #_ = this.ɵfac = function OwlDateTimeModule_Factory(t) {\n    return new (t || OwlDateTimeModule)();\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: OwlDateTimeModule\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [OwlDateTimeIntl, OWL_DTPICKER_SCROLL_STRATEGY_PROVIDER, ...optionsProviders],\n    imports: [CommonModule, OverlayModule, OwlDialogModule, A11yModule]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlDateTimeModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, OverlayModule, OwlDialogModule, A11yModule],\n      exports: [OwlCalendarComponent, OwlTimerComponent, OwlDateTimeTriggerDirective, OwlDateTimeInputDirective, OwlDateTimeComponent, OwlDateTimeInlineComponent, OwlMultiYearViewComponent, OwlYearViewComponent, OwlMonthViewComponent],\n      declarations: [OwlDateTimeTriggerDirective, OwlDateTimeInputDirective, OwlDateTimeComponent, OwlDateTimeContainerComponent, OwlMultiYearViewComponent, OwlYearViewComponent, OwlMonthViewComponent, OwlTimerComponent, OwlTimerBoxComponent, OwlCalendarComponent, OwlCalendarBodyComponent, NumberFixedLenPipe, OwlDateTimeInlineComponent],\n      providers: [OwlDateTimeIntl, OWL_DTPICKER_SCROLL_STRATEGY_PROVIDER, ...optionsProviders]\n    }]\n  }], null, null);\n})();\n\n/**\n * array.utils\n */\n/** Creates an array and fills it with values. */\nfunction range(length, valueFunction) {\n  const valuesArray = Array(length);\n  for (let i = 0; i < length; i++) {\n    valuesArray[i] = valueFunction(i);\n  }\n  return valuesArray;\n}\n\n/**\n * date.utils\n */\n/**\n * Creates a date with the given year, month, date, hour, minute and second. Does not allow over/under-flow of the\n * month and date.\n */\nfunction createDate(year, month, date, hours = 0, minutes = 0, seconds = 0) {\n  if (month < 0 || month > 11) {\n    throw Error(`Invalid month index \"${month}\". Month index has to be between 0 and 11.`);\n  }\n  if (date < 1) {\n    throw Error(`Invalid date \"${date}\". Date has to be greater than 0.`);\n  }\n  if (hours < 0 || hours > 23) {\n    throw Error(`Invalid hours \"${hours}\". Hours has to be between 0 and 23.`);\n  }\n  if (minutes < 0 || minutes > 59) {\n    throw Error(`Invalid minutes \"${minutes}\". Minutes has to between 0 and 59.`);\n  }\n  if (seconds < 0 || seconds > 59) {\n    throw Error(`Invalid seconds \"${seconds}\". Seconds has to be between 0 and 59.`);\n  }\n  const result = createDateWithOverflow(year, month, date, hours, minutes, seconds);\n  // Check that the date wasn't above the upper bound for the month, causing the month to overflow\n  // For example, createDate(2017, 1, 31) would try to create a date 2017/02/31 which is invalid\n  if (result.getMonth() !== month) {\n    throw Error(`Invalid date \"${date}\" for month with index \"${month}\".`);\n  }\n  return result;\n}\n/**\n * Gets the number of days in the month of the given date.\n */\nfunction getNumDaysInMonth(date) {\n  const lastDateOfMonth = createDateWithOverflow(date.getFullYear(), date.getMonth() + 1, 0);\n  return lastDateOfMonth.getDate();\n}\n/**\n * Creates a date but allows the month and date to overflow.\n */\nfunction createDateWithOverflow(year, month, date, hours = 0, minutes = 0, seconds = 0) {\n  const result = new Date(year, month, date, hours, minutes, seconds);\n  if (year >= 0 && year < 100) {\n    result.setFullYear(result.getFullYear() - 1900);\n  }\n  return result;\n}\n\n/**\n * constants\n */\n/** Whether the browser supports the Intl API. */\nconst SUPPORTS_INTL_API = typeof Intl !== 'undefined';\n/** The default month names to use if Intl API is not available. */\nconst DEFAULT_MONTH_NAMES = {\n  long: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n  short: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']\n};\n/** The default day of the week names to use if Intl API is not available. */\nconst DEFAULT_DAY_OF_WEEK_NAMES = {\n  long: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n  short: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S']\n};\n/** The default date names to use if Intl API is not available. */\nconst DEFAULT_DATE_NAMES = range(31, i => String(i + 1));\n\n/**\n * native-date-time-adapter.class\n */\n/**\n * Matches strings that have the form of a valid RFC 3339 string\n * (https://tools.ietf.org/html/rfc3339). Note that the string may not actually be a valid date\n * because the regex will match strings an with out of bounds month, date, etc.\n */\nconst ISO_8601_REGEX = /^\\d{4}-\\d{2}-\\d{2}(?:T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|(?:[+\\-]\\d{2}:\\d{2}))?)?$/;\nclass NativeDateTimeAdapter extends DateTimeAdapter {\n  constructor(owlDateTimeLocale, platform) {\n    super();\n    this.owlDateTimeLocale = owlDateTimeLocale;\n    super.setLocale(owlDateTimeLocale);\n    // IE does its own time zone correction, so we disable this on IE.\n    this.useUtcForDisplay = !platform.TRIDENT;\n    this._clampDate = platform.TRIDENT || platform.EDGE;\n  }\n  getYear(date) {\n    return date.getFullYear();\n  }\n  getMonth(date) {\n    return date.getMonth();\n  }\n  getDay(date) {\n    return date.getDay();\n  }\n  getDate(date) {\n    return date.getDate();\n  }\n  getHours(date) {\n    return date.getHours();\n  }\n  getMinutes(date) {\n    return date.getMinutes();\n  }\n  getSeconds(date) {\n    return date.getSeconds();\n  }\n  getTime(date) {\n    return date.getTime();\n  }\n  getNumDaysInMonth(date) {\n    return getNumDaysInMonth(date);\n  }\n  differenceInCalendarDays(dateLeft, dateRight) {\n    if (this.isValid(dateLeft) && this.isValid(dateRight)) {\n      const dateLeftStartOfDay = this.createDate(this.getYear(dateLeft), this.getMonth(dateLeft), this.getDate(dateLeft));\n      const dateRightStartOfDay = this.createDate(this.getYear(dateRight), this.getMonth(dateRight), this.getDate(dateRight));\n      const timeStampLeft = this.getTime(dateLeftStartOfDay) - dateLeftStartOfDay.getTimezoneOffset() * this.milliseondsInMinute;\n      const timeStampRight = this.getTime(dateRightStartOfDay) - dateRightStartOfDay.getTimezoneOffset() * this.milliseondsInMinute;\n      return Math.round((timeStampLeft - timeStampRight) / this.millisecondsInDay);\n    } else {\n      return null;\n    }\n  }\n  getYearName(date) {\n    if (SUPPORTS_INTL_API) {\n      const dtf = new Intl.DateTimeFormat(this.getLocale(), {\n        year: 'numeric',\n        timeZone: 'utc'\n      });\n      return this.stripDirectionalityCharacters(this._format(dtf, date));\n    }\n    return String(this.getYear(date));\n  }\n  getMonthNames(style) {\n    if (SUPPORTS_INTL_API) {\n      const dtf = new Intl.DateTimeFormat(this.getLocale(), {\n        month: style,\n        timeZone: 'utc'\n      });\n      return range(12, i => this.stripDirectionalityCharacters(this._format(dtf, new Date(2017, i, 1))));\n    }\n    return DEFAULT_MONTH_NAMES[style];\n  }\n  getDayOfWeekNames(style) {\n    if (SUPPORTS_INTL_API) {\n      const dtf = new Intl.DateTimeFormat(this.getLocale(), {\n        weekday: style,\n        timeZone: 'utc'\n      });\n      return range(7, i => this.stripDirectionalityCharacters(this._format(dtf, new Date(2017, 0, i + 1))));\n    }\n    return DEFAULT_DAY_OF_WEEK_NAMES[style];\n  }\n  getDateNames() {\n    if (SUPPORTS_INTL_API) {\n      const dtf = new Intl.DateTimeFormat(this.getLocale(), {\n        day: 'numeric',\n        timeZone: 'utc'\n      });\n      return range(31, i => this.stripDirectionalityCharacters(this._format(dtf, new Date(2017, 0, i + 1))));\n    }\n    return DEFAULT_DATE_NAMES;\n  }\n  toIso8601(date) {\n    return date.toISOString();\n  }\n  isEqual(dateLeft, dateRight) {\n    if (this.isValid(dateLeft) && this.isValid(dateRight)) {\n      return dateLeft.getTime() === dateRight.getTime();\n    } else {\n      return false;\n    }\n  }\n  isSameDay(dateLeft, dateRight) {\n    if (this.isValid(dateLeft) && this.isValid(dateRight)) {\n      const dateLeftStartOfDay = this.clone(dateLeft);\n      const dateRightStartOfDay = this.clone(dateRight);\n      dateLeftStartOfDay.setHours(0, 0, 0, 0);\n      dateRightStartOfDay.setHours(0, 0, 0, 0);\n      return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();\n    } else {\n      return false;\n    }\n  }\n  isValid(date) {\n    return date && !isNaN(date.getTime());\n  }\n  invalid() {\n    return new Date(NaN);\n  }\n  isDateInstance(obj) {\n    return obj instanceof Date;\n  }\n  addCalendarYears(date, amount) {\n    return this.addCalendarMonths(date, amount * 12);\n  }\n  addCalendarMonths(date, amount) {\n    const result = this.clone(date);\n    amount = Number(amount);\n    const desiredMonth = result.getMonth() + amount;\n    const dateWithDesiredMonth = new Date(0);\n    dateWithDesiredMonth.setFullYear(result.getFullYear(), desiredMonth, 1);\n    dateWithDesiredMonth.setHours(0, 0, 0, 0);\n    const daysInMonth = this.getNumDaysInMonth(dateWithDesiredMonth);\n    // Set the last day of the new month\n    // if the original date was the last day of the longer month\n    result.setMonth(desiredMonth, Math.min(daysInMonth, result.getDate()));\n    return result;\n  }\n  addCalendarDays(date, amount) {\n    const result = this.clone(date);\n    amount = Number(amount);\n    result.setDate(result.getDate() + amount);\n    return result;\n  }\n  setHours(date, amount) {\n    const result = this.clone(date);\n    result.setHours(amount);\n    return result;\n  }\n  setMinutes(date, amount) {\n    const result = this.clone(date);\n    result.setMinutes(amount);\n    return result;\n  }\n  setSeconds(date, amount) {\n    const result = this.clone(date);\n    result.setSeconds(amount);\n    return result;\n  }\n  createDate(year, month, date, hours = 0, minutes = 0, seconds = 0) {\n    return createDate(year, month, date, hours, minutes, seconds);\n  }\n  clone(date) {\n    return this.createDate(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHours(date), this.getMinutes(date), this.getSeconds(date));\n  }\n  now() {\n    return new Date();\n  }\n  format(date, displayFormat) {\n    if (!this.isValid(date)) {\n      throw Error('JSNativeDate: Cannot format invalid date.');\n    }\n    if (SUPPORTS_INTL_API) {\n      if (this._clampDate && (date.getFullYear() < 1 || date.getFullYear() > 9999)) {\n        date = this.clone(date);\n        date.setFullYear(Math.max(1, Math.min(9999, date.getFullYear())));\n      }\n      displayFormat = {\n        ...displayFormat,\n        timeZone: 'utc'\n      };\n      const dtf = new Intl.DateTimeFormat(this.getLocale(), displayFormat);\n      return this.stripDirectionalityCharacters(this._format(dtf, date));\n    }\n    return this.stripDirectionalityCharacters(date.toDateString());\n  }\n  parse(value, parseFormat) {\n    // There is no way using the native JS Date to set the parse format or locale\n    if (typeof value === 'number') {\n      return new Date(value);\n    }\n    return value ? new Date(Date.parse(value)) : null;\n  }\n  /**\n   * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings\n   * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an\n   * invalid date for all other values.\n   */\n  deserialize(value) {\n    if (typeof value === 'string') {\n      if (!value) {\n        return null;\n      }\n      // The `Date` constructor accepts formats other than ISO 8601, so we need to make sure the\n      // string is the right format first.\n      if (ISO_8601_REGEX.test(value)) {\n        const date = new Date(value);\n        if (this.isValid(date)) {\n          return date;\n        }\n      }\n    }\n    return super.deserialize(value);\n  }\n  /**\n   * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while\n   * other browsers do not. We remove them to make output consistent and because they interfere with\n   * date parsing.\n   */\n  stripDirectionalityCharacters(str) {\n    return str.replace(/[\\u200e\\u200f]/g, '');\n  }\n  /**\n   * When converting Date object to string, javascript built-in functions may return wrong\n   * results because it applies its internal DST rules. The DST rules around the world change\n   * very frequently, and the current valid rule is not always valid in previous years though.\n   * We work around this problem building a new Date object which has its internal UTC\n   * representation with the local date and time.\n   */\n  _format(dtf, date) {\n    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n    return dtf.format(d);\n  }\n  static #_ = this.ɵfac = function NativeDateTimeAdapter_Factory(t) {\n    return new (t || NativeDateTimeAdapter)(i0.ɵɵinject(OWL_DATE_TIME_LOCALE, 8), i0.ɵɵinject(i1$1.Platform));\n  };\n  static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NativeDateTimeAdapter,\n    factory: NativeDateTimeAdapter.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NativeDateTimeAdapter, [{\n    type: Injectable\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [OWL_DATE_TIME_LOCALE]\n    }]\n  }, {\n    type: i1$1.Platform\n  }], null);\n})();\nconst OWL_NATIVE_DATE_TIME_FORMATS = {\n  parseInput: null,\n  fullPickerInput: {\n    year: 'numeric',\n    month: 'numeric',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: 'numeric'\n  },\n  datePickerInput: {\n    year: 'numeric',\n    month: 'numeric',\n    day: 'numeric'\n  },\n  timePickerInput: {\n    hour: 'numeric',\n    minute: 'numeric'\n  },\n  monthYearLabel: {\n    year: 'numeric',\n    month: 'short'\n  },\n  dateA11yLabel: {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric'\n  },\n  monthYearA11yLabel: {\n    year: 'numeric',\n    month: 'long'\n  }\n};\n\n/**\n * native-date-time.module\n */\nclass NativeDateTimeModule {\n  static #_ = this.ɵfac = function NativeDateTimeModule_Factory(t) {\n    return new (t || NativeDateTimeModule)();\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NativeDateTimeModule\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: DateTimeAdapter,\n      useClass: NativeDateTimeAdapter\n    }],\n    imports: [PlatformModule]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NativeDateTimeModule, [{\n    type: NgModule,\n    args: [{\n      imports: [PlatformModule],\n      providers: [{\n        provide: DateTimeAdapter,\n        useClass: NativeDateTimeAdapter\n      }]\n    }]\n  }], null, null);\n})();\nclass OwlNativeDateTimeModule {\n  static #_ = this.ɵfac = function OwlNativeDateTimeModule_Factory(t) {\n    return new (t || OwlNativeDateTimeModule)();\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: OwlNativeDateTimeModule\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: OWL_DATE_TIME_FORMATS,\n      useValue: OWL_NATIVE_DATE_TIME_FORMATS\n    }],\n    imports: [NativeDateTimeModule]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OwlNativeDateTimeModule, [{\n    type: NgModule,\n    args: [{\n      imports: [NativeDateTimeModule],\n      providers: [{\n        provide: OWL_DATE_TIME_FORMATS,\n        useValue: OWL_NATIVE_DATE_TIME_FORMATS\n      }]\n    }]\n  }], null, null);\n})();\n\n/**\n * unix-timestamp-date-time-adapter.class\n */\nclass UnixTimestampDateTimeAdapter extends DateTimeAdapter {\n  constructor(owlDateTimeLocale, platform) {\n    super();\n    this.owlDateTimeLocale = owlDateTimeLocale;\n    super.setLocale(owlDateTimeLocale);\n    // IE does its own time zone correction, so we disable this on IE.\n    this.useUtcForDisplay = !platform.TRIDENT;\n    this._clampDate = platform.TRIDENT || platform.EDGE;\n  }\n  /**\n   * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while\n   * other browsers do not. We remove them to make output consistent and because they interfere with\n   * date parsing.\n   */\n  static #_ = this.search_ltr_rtl_pattern = '/[\\u200e\\u200f]/g';\n  static stripDirectionalityCharacters(str) {\n    return str.replace(UnixTimestampDateTimeAdapter.search_ltr_rtl_pattern, '');\n  }\n  /**\n   * When converting Date object to string, javascript built-in functions may return wrong\n   * results because it applies its internal DST rules. The DST rules around the world change\n   * very frequently, and the current valid rule is not always valid in previous years though.\n   * We work around this problem building a new Date object which has its internal UTC\n   * representation with the local date and time.\n   */\n  static _format(dtf, date) {\n    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n    return dtf.format(d);\n  }\n  addCalendarDays(date, amount) {\n    const result = new Date(date);\n    amount = Number(amount);\n    result.setDate(result.getDate() + amount);\n    return result.getTime();\n  }\n  addCalendarMonths(date, amount) {\n    const result = new Date(date);\n    amount = Number(amount);\n    const desiredMonth = result.getMonth() + amount;\n    const dateWithDesiredMonth = new Date(0);\n    dateWithDesiredMonth.setFullYear(result.getFullYear(), desiredMonth, 1);\n    dateWithDesiredMonth.setHours(0, 0, 0, 0);\n    const daysInMonth = this.getNumDaysInMonth(dateWithDesiredMonth.getTime());\n    // Set the last day of the new month\n    // if the original date was the last day of the longer month\n    result.setMonth(desiredMonth, Math.min(daysInMonth, result.getDate()));\n    return result.getTime();\n  }\n  addCalendarYears(date, amount) {\n    return this.addCalendarMonths(date, amount * 12);\n  }\n  clone(date) {\n    return date;\n  }\n  createDate(year, month, date, hours = 0, minutes = 0, seconds = 0) {\n    return createDate(year, month, date, hours, minutes, seconds).getTime();\n  }\n  differenceInCalendarDays(dateLeft, dateRight) {\n    if (this.isValid(dateLeft) && this.isValid(dateRight)) {\n      const dateLeftStartOfDay = this.createDate(this.getYear(dateLeft), this.getMonth(dateLeft), this.getDate(dateLeft));\n      const dateRightStartOfDay = this.createDate(this.getYear(dateRight), this.getMonth(dateRight), this.getDate(dateRight));\n      const timeStampLeft = this.getTime(dateLeftStartOfDay) - new Date(dateLeftStartOfDay).getTimezoneOffset() * this.milliseondsInMinute;\n      const timeStampRight = this.getTime(dateRightStartOfDay) - new Date(dateRightStartOfDay).getTimezoneOffset() * this.milliseondsInMinute;\n      return Math.round((timeStampLeft - timeStampRight) / this.millisecondsInDay);\n    } else {\n      return null;\n    }\n  }\n  format(date, displayFormat) {\n    if (!this.isValid(date)) {\n      throw Error('JSNativeDate: Cannot format invalid date.');\n    }\n    const jsDate = new Date(date);\n    if (SUPPORTS_INTL_API) {\n      if (this._clampDate && (jsDate.getFullYear() < 1 || jsDate.getFullYear() > 9999)) {\n        jsDate.setFullYear(Math.max(1, Math.min(9999, jsDate.getFullYear())));\n      }\n      displayFormat = {\n        ...displayFormat,\n        timeZone: 'utc'\n      };\n      const dtf = new Intl.DateTimeFormat(this.locale, displayFormat);\n      return UnixTimestampDateTimeAdapter.stripDirectionalityCharacters(UnixTimestampDateTimeAdapter._format(dtf, jsDate));\n    }\n    return UnixTimestampDateTimeAdapter.stripDirectionalityCharacters(jsDate.toDateString());\n  }\n  getDate(date) {\n    return new Date(date).getDate();\n  }\n  getDateNames() {\n    if (SUPPORTS_INTL_API) {\n      const dtf = new Intl.DateTimeFormat(this.locale, {\n        day: 'numeric',\n        timeZone: 'utc'\n      });\n      return range(31, i => UnixTimestampDateTimeAdapter.stripDirectionalityCharacters(UnixTimestampDateTimeAdapter._format(dtf, new Date(2017, 0, i + 1))));\n    }\n    return DEFAULT_DATE_NAMES;\n  }\n  getDay(date) {\n    return new Date(date).getDay();\n  }\n  getDayOfWeekNames(style) {\n    if (SUPPORTS_INTL_API) {\n      const dtf = new Intl.DateTimeFormat(this.locale, {\n        weekday: style,\n        timeZone: 'utc'\n      });\n      return range(7, i => UnixTimestampDateTimeAdapter.stripDirectionalityCharacters(UnixTimestampDateTimeAdapter._format(dtf, new Date(2017, 0, i + 1))));\n    }\n    return DEFAULT_DAY_OF_WEEK_NAMES[style];\n  }\n  getHours(date) {\n    return new Date(date).getHours();\n  }\n  getMinutes(date) {\n    return new Date(date).getMinutes();\n  }\n  getMonth(date) {\n    return new Date(date).getMonth();\n  }\n  getMonthNames(style) {\n    if (SUPPORTS_INTL_API) {\n      const dtf = new Intl.DateTimeFormat(this.locale, {\n        month: style,\n        timeZone: 'utc'\n      });\n      return range(12, i => UnixTimestampDateTimeAdapter.stripDirectionalityCharacters(UnixTimestampDateTimeAdapter._format(dtf, new Date(2017, i, 1))));\n    }\n    return DEFAULT_MONTH_NAMES[style];\n  }\n  getNumDaysInMonth(date) {\n    return getNumDaysInMonth(new Date(date));\n  }\n  getSeconds(date) {\n    return new Date(date).getSeconds();\n  }\n  getTime(date) {\n    return date;\n  }\n  getYear(date) {\n    return new Date(date).getFullYear();\n  }\n  getYearName(date) {\n    if (SUPPORTS_INTL_API) {\n      const dtf = new Intl.DateTimeFormat(this.locale, {\n        year: 'numeric',\n        timeZone: 'utc'\n      });\n      return UnixTimestampDateTimeAdapter.stripDirectionalityCharacters(UnixTimestampDateTimeAdapter._format(dtf, new Date(date)));\n    }\n    return String(this.getYear(date));\n  }\n  invalid() {\n    return NaN;\n  }\n  isDateInstance(obj) {\n    return typeof obj === 'number';\n  }\n  isEqual(dateLeft, dateRight) {\n    if (this.isValid(dateLeft) && this.isValid(dateRight)) {\n      return dateLeft === dateRight;\n    } else {\n      return false;\n    }\n  }\n  isSameDay(dateLeft, dateRight) {\n    if (this.isValid(dateLeft) && this.isValid(dateRight)) {\n      const dateLeftStartOfDay = new Date(dateLeft);\n      const dateRightStartOfDay = new Date(dateRight);\n      dateLeftStartOfDay.setHours(0, 0, 0, 0);\n      dateRightStartOfDay.setHours(0, 0, 0, 0);\n      return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();\n    } else {\n      return false;\n    }\n  }\n  isValid(date) {\n    return (date || date === 0) && !isNaN(date);\n  }\n  now() {\n    return new Date().getTime();\n  }\n  parse(value, parseFormat) {\n    // There is no way using the native JS Date to set the parse format or locale\n    if (typeof value === 'number') {\n      return value;\n    }\n    return value ? new Date(Date.parse(value)).getTime() : null;\n  }\n  setHours(date, amount) {\n    const result = new Date(date);\n    result.setHours(amount);\n    return result.getTime();\n  }\n  setMinutes(date, amount) {\n    const result = new Date(date);\n    result.setMinutes(amount);\n    return result.getTime();\n  }\n  setSeconds(date, amount) {\n    const result = new Date(date);\n    result.setSeconds(amount);\n    return result.getTime();\n  }\n  toIso8601(date) {\n    return new Date(date).toISOString();\n  }\n  static #_2 = this.ɵfac = function UnixTimestampDateTimeAdapter_Factory(t) {\n    return new (t || UnixTimestampDateTimeAdapter)(i0.ɵɵinject(OWL_DATE_TIME_LOCALE, 8), i0.ɵɵinject(i1$1.Platform));\n  };\n  static #_3 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UnixTimestampDateTimeAdapter,\n    factory: UnixTimestampDateTimeAdapter.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UnixTimestampDateTimeAdapter, [{\n    type: Injectable\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [OWL_DATE_TIME_LOCALE]\n    }]\n  }, {\n    type: i1$1.Platform\n  }], null);\n})();\nconst OWL_UNIX_TIMESTAMP_DATE_TIME_FORMATS = {\n  parseInput: null,\n  fullPickerInput: {\n    year: 'numeric',\n    month: 'numeric',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: 'numeric'\n  },\n  datePickerInput: {\n    year: 'numeric',\n    month: 'numeric',\n    day: 'numeric'\n  },\n  timePickerInput: {\n    hour: 'numeric',\n    minute: 'numeric'\n  },\n  monthYearLabel: {\n    year: 'numeric',\n    month: 'short'\n  },\n  dateA11yLabel: {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric'\n  },\n  monthYearA11yLabel: {\n    year: 'numeric',\n    month: 'long'\n  }\n};\n\n/**\n * picker\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CalendarCell, DateTimeAdapter, DateView, DefaultOptions, NativeDateTimeAdapter, OWL_DATETIME_VALIDATORS, OWL_DATETIME_VALUE_ACCESSOR$1 as OWL_DATETIME_VALUE_ACCESSOR, OWL_DATE_TIME_FORMATS, OWL_DATE_TIME_LOCALE, OWL_DATE_TIME_LOCALE_PROVIDER, OWL_UNIX_TIMESTAMP_DATE_TIME_FORMATS, OptionsTokens, OwlCalendarBodyComponent, OwlCalendarComponent, OwlDateTimeComponent, OwlDateTimeInlineComponent, OwlDateTimeInputDirective, OwlDateTimeIntl, OwlDateTimeModule, OwlDateTimeTriggerDirective, OwlMonthViewComponent, OwlMultiYearViewComponent, OwlNativeDateTimeModule, OwlTimerComponent, OwlYearViewComponent, UnixTimestampDateTimeAdapter, defaultOptionsFactory, multiYearOptionsFactory, optionsProviders };\n//# sourceMappingURL=danielmoncada-angular-datetime-picker.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}