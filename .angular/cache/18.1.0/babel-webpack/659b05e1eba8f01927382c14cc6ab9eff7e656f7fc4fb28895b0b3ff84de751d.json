{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, Component, ViewEncapsulation, ViewChild, ContentChild, Input, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nconst _c0 = [\"canvas\"];\nconst _c1 = [\"rLabel\"];\nconst _c2 = [\"reading\"];\nconst _c3 = [[[\"ngx-gauge-prepend\"]], [[\"ngx-gauge-value\"]], [[\"ngx-gauge-append\"]], [[\"ngx-gauge-label\"]]];\nconst _c4 = [\"ngx-gauge-prepend\", \"ngx-gauge-value\", \"ngx-gauge-append\", \"ngx-gauge-label\"];\nfunction NgxGauge_ng_content_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngSwitchCase\", \"true\"]);\n  }\n}\nfunction NgxGauge_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(ctx_r0.prepend);\n  }\n}\nfunction NgxGauge_ng_content_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1, [\"*ngSwitchCase\", \"true\"]);\n  }\n}\nfunction NgxGauge_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"number\");\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(2, 1, ctx_r0.value));\n  }\n}\nfunction NgxGauge_ng_content_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2, [\"*ngSwitchCase\", \"true\"]);\n  }\n}\nfunction NgxGauge_ng_container_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(ctx_r0.append);\n  }\n}\nfunction NgxGauge_ng_content_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 3, [\"*ngSwitchCase\", \"true\"]);\n  }\n}\nfunction NgxGauge_ng_container_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(ctx_r0.label);\n  }\n}\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction coerceBooleanProperty(value) {\n  return value != null && `${value}` !== 'false';\n}\nfunction coerceNumberProperty(value, fallbackValue = 0) {\n  return isNaN(parseFloat(value)) || isNaN(Number(value)) ? fallbackValue : Number(value);\n}\nfunction cssUnit(value) {\n  return `${value}px`;\n}\nfunction isNumber(value) {\n  return value != undefined && !isNaN(parseFloat(value)) && !isNaN(Number(value));\n}\nclass NgxGaugeAppend {\n  static #_ = this.ɵfac = function NgxGaugeAppend_Factory(t) {\n    return new (t || NgxGaugeAppend)();\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxGaugeAppend,\n    selectors: [[\"ngx-gauge-append\"]],\n    exportAs: [\"ngxGaugeAppend\"]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxGaugeAppend, [{\n    type: Directive,\n    args: [{\n      selector: \"ngx-gauge-append\",\n      exportAs: \"ngxGaugeAppend\"\n    }]\n  }], null, null);\n})();\nclass NgxGaugePrepend {\n  static #_ = this.ɵfac = function NgxGaugePrepend_Factory(t) {\n    return new (t || NgxGaugePrepend)();\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxGaugePrepend,\n    selectors: [[\"ngx-gauge-prepend\"]],\n    exportAs: [\"ngxGaugePrepend\"]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxGaugePrepend, [{\n    type: Directive,\n    args: [{\n      selector: \"ngx-gauge-prepend\",\n      exportAs: \"ngxGaugePrepend\"\n    }]\n  }], null, null);\n})();\nclass NgxGaugeValue {\n  static #_ = this.ɵfac = function NgxGaugeValue_Factory(t) {\n    return new (t || NgxGaugeValue)();\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxGaugeValue,\n    selectors: [[\"ngx-gauge-value\"]],\n    exportAs: [\"ngxGaugeValue\"]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxGaugeValue, [{\n    type: Directive,\n    args: [{\n      selector: \"ngx-gauge-value\",\n      exportAs: \"ngxGaugeValue\"\n    }]\n  }], null, null);\n})();\nclass NgxGaugeLabel {\n  static #_ = this.ɵfac = function NgxGaugeLabel_Factory(t) {\n    return new (t || NgxGaugeLabel)();\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxGaugeLabel,\n    selectors: [[\"ngx-gauge-label\"]],\n    exportAs: [\"ngxGaugeLabel\"]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxGaugeLabel, [{\n    type: Directive,\n    args: [{\n      selector: \"ngx-gauge-label\",\n      exportAs: \"ngxGaugeLabel\"\n    }]\n  }], null, null);\n})();\nconst DEFAULTS = {\n  MIN: 0,\n  MAX: 100,\n  TYPE: 'arch',\n  THICK: 4,\n  FOREGROUND_COLOR: 'rgba(0, 150, 136, 1)',\n  BACKGROUND_COLOR: 'rgba(0, 0, 0, 0.1)',\n  CAP: 'butt',\n  SIZE: 200\n};\nclass NgxGauge {\n  get size() {\n    return this._size;\n  }\n  set size(value) {\n    this._size = coerceNumberProperty(value);\n  }\n  get margin() {\n    return this._margin;\n  }\n  set margin(value) {\n    this._margin = coerceNumberProperty(value);\n  }\n  get min() {\n    return this._min;\n  }\n  set min(value) {\n    this._min = coerceNumberProperty(value, DEFAULTS.MIN);\n  }\n  get animate() {\n    return this._animate;\n  }\n  set animate(value) {\n    this._animate = coerceBooleanProperty(value);\n  }\n  get max() {\n    return this._max;\n  }\n  set max(value) {\n    this._max = coerceNumberProperty(value, DEFAULTS.MAX);\n  }\n  get value() {\n    return this._value;\n  }\n  set value(val) {\n    this._value = coerceNumberProperty(val);\n  }\n  constructor(_elementRef, _renderer) {\n    this._elementRef = _elementRef;\n    this._renderer = _renderer;\n    this._size = DEFAULTS.SIZE;\n    this._min = DEFAULTS.MIN;\n    this._max = DEFAULTS.MAX;\n    this._animate = true;\n    this._margin = 0;\n    this._initialized = false;\n    this._animationRequestID = 0;\n    this.ariaLabel = '';\n    this.ariaLabelledby = null;\n    this.type = DEFAULTS.TYPE;\n    this.cap = DEFAULTS.CAP;\n    this.thick = DEFAULTS.THICK;\n    this.foregroundColor = DEFAULTS.FOREGROUND_COLOR;\n    this.backgroundColor = DEFAULTS.BACKGROUND_COLOR;\n    // { \"40\" : { color: \"green\", bgOpacity: .2 }, ... }\n    this.thresholds = Object.create(null);\n    // { \"25\": { color: '#ccc', type: 'line', size: 8, label: \"25 lbs\" }, ... }\n    this.markers = Object.create(null);\n    this._value = 0;\n    this.duration = 1200;\n  }\n  ngOnInit() {\n    // if markers are to be added, but no margin specified then here we add 10 px.\n    if (this.markers && Object.keys(this.markers).length > 0 && !this._margin) this._margin = 10;\n  }\n  ngOnChanges(changes) {\n    const isCanvasPropertyChanged = changes['thick'] || changes['type'] || changes['cap'] || changes['size'];\n    const isDataChanged = changes['value'] || changes['min'] || changes['max'];\n    if (this._initialized) {\n      if (isDataChanged) {\n        let nv;\n        if (changes['value']) {\n          nv = Number(changes['value'].currentValue);\n          nv = isNaN(nv) ? 0 : nv;\n          const prevVal = Number(changes['value'].previousValue);\n          this._oldChangeVal = isNaN(prevVal) ? this._oldChangeVal : prevVal;\n        }\n        this._update(nv, this._oldChangeVal);\n      }\n      if (isCanvasPropertyChanged) {\n        this._destroy();\n        this._init();\n      }\n    }\n  }\n  _updateSize() {\n    this._renderer.setStyle(this._elementRef.nativeElement, 'width', cssUnit(this._getWidth()));\n    this._renderer.setStyle(this._elementRef.nativeElement, 'height', cssUnit(this._getCanvasHeight()));\n    this._canvas.nativeElement.width = this._getWidth();\n    this._canvas.nativeElement.height = this._getCanvasHeight();\n    this._renderer.setStyle(this._label.nativeElement, 'transform', 'translateY(' + (this.size / 3 * 2 - this.size / 13 / 4) + 'px)');\n    this._renderer.setStyle(this._reading.nativeElement, 'transform', 'translateY(' + (this.size / 2 - this.size * 0.22 / 2) + 'px)');\n  }\n  ngAfterViewInit() {\n    if (this._canvas) {\n      this._init();\n    }\n  }\n  ngOnDestroy() {\n    this._destroy();\n  }\n  _getBounds(type) {\n    let head, tail, start, end;\n    if (type == 'semi') {\n      head = Math.PI;\n      tail = 2 * Math.PI;\n      start = 180;\n      end = 360;\n    } else if (type == 'full') {\n      head = 1.5 * Math.PI;\n      tail = 3.5 * Math.PI;\n      start = 270;\n      end = start + 360;\n    } else if (type === 'arch') {\n      head = 0.8 * Math.PI;\n      tail = 2.2 * Math.PI;\n      start = 180 - 0.2 * 180;\n      end = 360 + 0.2 * 180;\n    }\n    return {\n      head,\n      tail,\n      start,\n      end\n    };\n  }\n  _drawShell(start, middle, tail, color) {\n    let center = this._getCenter(),\n      radius = this._getRadius();\n    if (this._initialized) {\n      this._clear();\n      this._drawMarkersAndTicks();\n      let ranges = this._getBackgroundColorRanges();\n      this._context.lineWidth = this.thick;\n      if (ranges && ranges.length > 0) {\n        // if background color is not specified then use default background, unless opacity is provided in which case use the color\n        // and opactity against color, to form the background color.\n        this._context.lineCap = 'butt';\n        for (let i = 0; i < ranges.length; ++i) {\n          let r = ranges[i];\n          this._context.beginPath();\n          this._context.strokeStyle = r.backgroundColor ? r.backgroundColor : r.bgOpacity ? r.color : this.backgroundColor;\n          if (r.bgOpacity !== undefined && r.bgOpacity !== null) {\n            this._context.globalAlpha = r.bgOpacity;\n          }\n          this._context.arc(center.x, center.y, radius, this._getDisplacement(r.start), this._getDisplacement(r.end), false);\n          this._context.stroke();\n          this._context.globalAlpha = 1;\n        }\n      } else {\n        this._context.lineCap = this.cap;\n        this._context.beginPath();\n        this._context.strokeStyle = this.backgroundColor;\n        this._context.arc(center.x, center.y, radius, start, tail, false);\n        this._context.stroke();\n      }\n      this._drawFill(start, middle, tail, color);\n    }\n  }\n  _drawFill(start, middle, tail, color) {\n    let center = this._getCenter(),\n      radius = this._getRadius();\n    this._context.lineCap = this.cap;\n    this._context.lineWidth = this.thick;\n    middle = Math.max(middle, start); // never below 0%\n    middle = Math.min(middle, tail); // never exceed 100%\n    this._context.lineCap = this.cap;\n    this._context.lineWidth = this.thick;\n    this._context.beginPath();\n    this._context.strokeStyle = color;\n    this._context.arc(center.x, center.y, radius, start, middle, false);\n    this._context.stroke();\n  }\n  _addMarker(angle, color, label, type, len, font) {\n    var rad = angle * Math.PI / 180;\n    let offset = 2;\n    if (!len) len = 8;\n    if (!type) type = 'line';\n    let center = this._getCenter(),\n      radius = this._getRadius();\n    let x = (radius + this.thick / 2 + offset) * Math.cos(rad) + center.x;\n    let y = (radius + this.thick / 2 + offset) * Math.sin(rad) + center.y;\n    let x2 = (radius + this.thick / 2 + offset + len) * Math.cos(rad) + center.x;\n    let y2 = (radius + this.thick / 2 + offset + len) * Math.sin(rad) + center.y;\n    if (type == 'triangle') {\n      //Draw the triangle marker\n      this._context.beginPath();\n      this._context.strokeStyle = color;\n      this._context.moveTo(x, y);\n      this._context.lineWidth = 1;\n      let a2 = angle - 45;\n      let a3 = angle + 45;\n      if (a2 < 0) a2 += 360;\n      if (a2 > 360) a2 -= 360;\n      if (a3 < 0) a3 += 360;\n      if (a3 > 360) a3 -= 360;\n      let rad2 = a2 * Math.PI / 180;\n      let x3 = len * Math.cos(rad2) + x;\n      let y3 = len * Math.sin(rad2) + y;\n      this._context.lineTo(x3, y3);\n      let rad3 = a3 * Math.PI / 180;\n      let x4 = len * Math.cos(rad3) + x;\n      let y4 = len * Math.sin(rad3) + y;\n      this._context.lineTo(x4, y4);\n      this._context.lineTo(x, y);\n      this._context.closePath();\n      this._context.stroke();\n      this._context.fillStyle = color;\n      this._context.fill();\n    } else {\n      //line\n      this._context.beginPath();\n      this._context.lineWidth = .5;\n      this._context.strokeStyle = color;\n      this._context.moveTo(x, y);\n      this._context.lineTo(x2, y2);\n      this._context.closePath();\n      this._context.stroke();\n    }\n    if (label) {\n      this._context.save();\n      this._context.translate(x2, y2);\n      this._context.rotate((angle + 90) * (Math.PI / 180));\n      this._context.textAlign = \"center\";\n      this._context.font = font ? font : '13px Arial';\n      this._context.fillText(label, 0, -3);\n      this._context.restore();\n    }\n  }\n  _clear() {\n    this._context.clearRect(0, 0, this._getWidth(), this._getHeight());\n  }\n  _getWidth() {\n    return this.size;\n  }\n  _getHeight() {\n    return this.size;\n  }\n  // canvas height will be shorter for type 'semi' and 'arch'\n  _getCanvasHeight() {\n    return this.type == 'arch' || this.type == 'semi' ? 0.85 * this._getHeight() : this._getHeight();\n  }\n  _getRadius() {\n    const center = this._getCenter();\n    var rad = center.x - this.thick;\n    if (this._margin > 0) rad -= this._margin;\n    return rad;\n  }\n  _getCenter() {\n    var x = this._getWidth() / 2,\n      y = this._getHeight() / 2;\n    return {\n      x,\n      y\n    };\n  }\n  _init() {\n    this._context = this._canvas.nativeElement.getContext('2d');\n    this._initialized = true;\n    this._updateSize();\n    this._create();\n  }\n  _destroy() {\n    if (this._animationRequestID) {\n      window.cancelAnimationFrame(this._animationRequestID);\n      this._animationRequestID = 0;\n    }\n    this._clear();\n    this._context = null;\n    this._initialized = false;\n  }\n  _getForegroundColorByRange(value) {\n    const thresh = this._getThresholdMatchForValue(value);\n    return thresh && thresh.color ? thresh.color : this.foregroundColor;\n  }\n  _getThresholdMatchForValue(value) {\n    const match = Object.keys(this.thresholds).filter(function (item) {\n      return isNumber(item) && Number(item) <= value;\n    }).sort((a, b) => Number(a) - Number(b)).reverse()[0];\n    if (match !== undefined) {\n      const thresh = this.thresholds[match];\n      const t = {\n        color: thresh.color,\n        backgroundColor: thresh.backgroundColor,\n        bgOpacity: thresh.bgOpacity,\n        start: Number(match),\n        end: this._getNextThreshold(Number(match))\n      };\n      return t;\n    }\n  }\n  _getNextThreshold(value) {\n    const match = Object.keys(this.thresholds).filter(function (item) {\n      return isNumber(item) && Number(item) > value;\n    }).sort((a, b) => Number(a) - Number(b));\n    if (match && match[0] !== undefined) {\n      return Number(match[0]);\n    } else {\n      return this.max;\n    }\n  }\n  _getBackgroundColorRanges() {\n    let i = 0,\n      ranges = [];\n    do {\n      let thresh = this._getThresholdMatchForValue(i);\n      if (thresh) {\n        ranges.push({\n          start: thresh.start,\n          end: thresh.end,\n          color: thresh.color,\n          backgroundColor: thresh.backgroundColor,\n          bgOpacity: thresh.bgOpacity\n        });\n        i = thresh.end;\n        if (i >= this.max) break;\n      } else break;\n    } while (true);\n    return ranges;\n  }\n  _getDisplacement(v) {\n    let type = this.type,\n      bounds = this._getBounds(type),\n      min = this.min,\n      max = this.max,\n      start = bounds.head,\n      value = clamp(v, this.min, this.max),\n      unit = (bounds.tail - bounds.head) / (max - min),\n      displacement = unit * (value - min);\n    return start + displacement;\n  }\n  _create(nv, ov) {\n    const self = this;\n    const type = this.type;\n    const bounds = this._getBounds(type);\n    const duration = this.duration;\n    const min = this.min;\n    const max = this.max;\n    const value = clamp(this.value, min, max);\n    const start = bounds.head;\n    const unit = (bounds.tail - bounds.head) / (max - min);\n    let displacement = unit * (value - min);\n    const tail = bounds.tail;\n    const color = this._getForegroundColorByRange(value);\n    let startTime;\n    if (self._animationRequestID) {\n      window.cancelAnimationFrame(self._animationRequestID);\n    }\n    const animate = timestamp => {\n      timestamp = timestamp || new Date().getTime();\n      const runtime = timestamp - startTime;\n      const progress = Math.min(runtime / duration, 1);\n      const previousProgress = ov ? (ov - min) * unit : 0;\n      const middle = start + previousProgress + displacement * progress;\n      self._drawShell(start, middle, tail, color);\n      if (self._animationRequestID && runtime < duration) {\n        self._animationRequestID = window.requestAnimationFrame(ts => animate(ts));\n      } else {\n        window.cancelAnimationFrame(self._animationRequestID);\n      }\n    };\n    if (this._animate) {\n      if (nv !== undefined && ov !== undefined && ov !== 0) {\n        displacement = unit * nv - unit * ov;\n      }\n      self._animationRequestID = window.requestAnimationFrame(timestamp => {\n        startTime = timestamp || new Date().getTime();\n        animate(startTime);\n      });\n    } else {\n      self._drawShell(start, start + displacement, tail, color);\n    }\n  }\n  _drawMarkersAndTicks() {\n    /*\n     * example:\n    this.markers = {\n        '-10': {\n            color: '#555',\n            size: 5,\n            label: '-10',\n            font: '11px verdana',\n            type: 'line',\n        },\n        '10': {\n            color: '#555',\n            size: 5,\n            label: '10',\n            font: '11px verdana',\n            type: 'line',\n        },\n        '20': {\n            color: '#555',\n            size: 5,\n            label: '20',\n            type: 'line',\n        },\n    };\n    */\n    if (this.markers) {\n      const bounds = this._getBounds(this.type);\n      const degrees = bounds.end - bounds.start;\n      const perD = degrees / (this.max - this.min);\n      for (const mv in this.markers) {\n        const n = Number(mv) - this.min;\n        const angle = bounds.start + n * perD;\n        const m = this.markers[mv];\n        this._addMarker(angle, m.color, m.label, m.type, m.size, m.font);\n      }\n    }\n  }\n  _update(nv, ov) {\n    this._clear();\n    this._create(nv, ov);\n  }\n  static #_ = this.ɵfac = function NgxGauge_Factory(t) {\n    return new (t || NgxGauge)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxGauge,\n    selectors: [[\"ngx-gauge\"]],\n    contentQueries: function NgxGauge_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NgxGaugeLabel, 5);\n        i0.ɵɵcontentQuery(dirIndex, NgxGaugePrepend, 5);\n        i0.ɵɵcontentQuery(dirIndex, NgxGaugeAppend, 5);\n        i0.ɵɵcontentQuery(dirIndex, NgxGaugeValue, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._labelChild = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._prependChild = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._appendChild = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._valueDisplayChild = _t.first);\n      }\n    },\n    viewQuery: function NgxGauge_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c2, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._canvas = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._label = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._reading = _t.first);\n      }\n    },\n    hostAttrs: [\"role\", \"slider\", \"aria-readonly\", \"true\"],\n    hostVars: 7,\n    hostBindings: function NgxGauge_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-valuemin\", ctx.min)(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.value)(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledby);\n        i0.ɵɵclassProp(\"ngx-gauge-meter\", true);\n      }\n    },\n    inputs: {\n      ariaLabel: [0, \"aria-label\", \"ariaLabel\"],\n      ariaLabelledby: [0, \"aria-labelledby\", \"ariaLabelledby\"],\n      size: \"size\",\n      margin: \"margin\",\n      min: \"min\",\n      animate: \"animate\",\n      max: \"max\",\n      type: \"type\",\n      cap: \"cap\",\n      thick: \"thick\",\n      label: \"label\",\n      append: \"append\",\n      prepend: \"prepend\",\n      foregroundColor: \"foregroundColor\",\n      backgroundColor: \"backgroundColor\",\n      thresholds: \"thresholds\",\n      markers: \"markers\",\n      value: \"value\",\n      duration: \"duration\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c4,\n    decls: 17,\n    vars: 16,\n    consts: [[\"reading\", \"\"], [\"rLabel\", \"\"], [\"canvas\", \"\"], [1, \"reading-block\"], [1, \"reading-affix\", 3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [3, \"ngSwitch\"], [1, \"reading-label\", 3, \"ngSwitch\"]],\n    template: function NgxGauge_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c3);\n        i0.ɵɵelementStart(0, \"div\", 3, 0)(2, \"u\", 4);\n        i0.ɵɵtemplate(3, NgxGauge_ng_content_3_Template, 1, 0, \"ng-content\", 5)(4, NgxGauge_ng_container_4_Template, 2, 1, \"ng-container\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerStart(5, 6);\n        i0.ɵɵtemplate(6, NgxGauge_ng_content_6_Template, 1, 0, \"ng-content\", 5)(7, NgxGauge_ng_container_7_Template, 3, 3, \"ng-container\", 5);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementStart(8, \"u\", 4);\n        i0.ɵɵtemplate(9, NgxGauge_ng_content_9_Template, 1, 0, \"ng-content\", 5)(10, NgxGauge_ng_container_10_Template, 2, 1, \"ng-container\", 5);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(11, \"div\", 7, 1);\n        i0.ɵɵtemplate(13, NgxGauge_ng_content_13_Template, 1, 0, \"ng-content\", 5)(14, NgxGauge_ng_container_14_Template, 2, 1, \"ng-container\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(15, \"canvas\", null, 2);\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"font-size\", (ctx.size - ctx.margin * 2) * 0.22 + \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngSwitch\", ctx._prependChild != null);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngSwitchCase\", true);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngSwitchCase\", false);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngSwitch\", ctx._valueDisplayChild != null);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngSwitchCase\", true);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngSwitchCase\", false);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngSwitch\", ctx._appendChild != null);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngSwitchCase\", true);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngSwitchCase\", false);\n        i0.ɵɵadvance();\n        i0.ɵɵstyleProp(\"font-size\", (ctx.size - ctx.margin * 2) / 13 + \"px\");\n        i0.ɵɵproperty(\"ngSwitch\", ctx._labelChild != null);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngSwitchCase\", true);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngSwitchCase\", false);\n      }\n    },\n    dependencies: [i1.NgSwitch, i1.NgSwitchCase, i1.DecimalPipe],\n    styles: [\".ngx-gauge-meter{display:inline-block;text-align:center;position:relative}.reading-block{position:absolute;width:100%;font-weight:400;white-space:nowrap;text-align:center;overflow:hidden;text-overflow:ellipsis}.reading-label{font-family:inherit;width:100%;display:inline-block;position:absolute;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:400}.reading-affix{text-decoration:none;font-size:.6em;opacity:.8;font-weight:200;padding:0 .18em}.reading-affix:first-child{padding-left:0}.reading-affix:last-child{padding-right:0}\\n\"],\n    encapsulation: 2\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxGauge, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-gauge',\n      host: {\n        'role': 'slider',\n        'aria-readonly': 'true',\n        '[class.ngx-gauge-meter]': 'true',\n        '[attr.aria-valuemin]': 'min',\n        '[attr.aria-valuemax]': 'max',\n        '[attr.aria-valuenow]': 'value',\n        '[attr.aria-label]': 'ariaLabel',\n        '[attr.aria-labelledby]': 'ariaLabelledby'\n      },\n      encapsulation: ViewEncapsulation.None,\n      template: \"<div class=\\\"reading-block\\\" #reading [style.fontSize]=\\\"(size-(margin*2)) * 0.22 + 'px'\\\">\\r\\n  <!-- This block can not be indented correctly, because line breaks cause layout spacing, related problem: https://pt.stackoverflow.com/q/276760/2998 -->\\r\\n  <u class=\\\"reading-affix\\\" [ngSwitch]=\\\"_prependChild != null\\\"><ng-content select=\\\"ngx-gauge-prepend\\\" *ngSwitchCase=\\\"true\\\"></ng-content><ng-container *ngSwitchCase=\\\"false\\\">{{prepend}}</ng-container></u><ng-container [ngSwitch]=\\\"_valueDisplayChild != null\\\"><ng-content *ngSwitchCase=\\\"true\\\" select=\\\"ngx-gauge-value\\\"></ng-content><ng-container *ngSwitchCase=\\\"false\\\">{{value | number}}</ng-container></ng-container><u class=\\\"reading-affix\\\" [ngSwitch]=\\\"_appendChild != null\\\"><ng-content select=\\\"ngx-gauge-append\\\" *ngSwitchCase=\\\"true\\\"></ng-content><ng-container *ngSwitchCase=\\\"false\\\">{{append}}</ng-container></u>\\r\\n</div>\\r\\n<div class=\\\"reading-label\\\" #rLabel\\r\\n     [style.fontSize]=\\\"(size-(margin*2)) / 13 + 'px'\\\"\\r\\n     [ngSwitch]=\\\"_labelChild != null\\\">\\r\\n  <ng-content select=\\\"ngx-gauge-label\\\" *ngSwitchCase=\\\"true\\\"></ng-content>\\r\\n  <ng-container *ngSwitchCase=\\\"false\\\">{{label}}</ng-container>\\r\\n</div>\\r\\n<canvas #canvas></canvas>\\r\\n\",\n      styles: [\".ngx-gauge-meter{display:inline-block;text-align:center;position:relative}.reading-block{position:absolute;width:100%;font-weight:400;white-space:nowrap;text-align:center;overflow:hidden;text-overflow:ellipsis}.reading-label{font-family:inherit;width:100%;display:inline-block;position:absolute;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:400}.reading-affix{text-decoration:none;font-size:.6em;opacity:.8;font-weight:200;padding:0 .18em}.reading-affix:first-child{padding-left:0}.reading-affix:last-child{padding-right:0}\\n\"]\n    }]\n  }], () => [{\n    type: i0.ElementRef\n  }, {\n    type: i0.Renderer2\n  }], {\n    _canvas: [{\n      type: ViewChild,\n      args: ['canvas', {\n        static: true\n      }]\n    }],\n    _label: [{\n      type: ViewChild,\n      args: ['rLabel', {\n        static: true\n      }]\n    }],\n    _reading: [{\n      type: ViewChild,\n      args: ['reading', {\n        static: true\n      }]\n    }],\n    _labelChild: [{\n      type: ContentChild,\n      args: [NgxGaugeLabel]\n    }],\n    _prependChild: [{\n      type: ContentChild,\n      args: [NgxGaugePrepend]\n    }],\n    _appendChild: [{\n      type: ContentChild,\n      args: [NgxGaugeAppend]\n    }],\n    _valueDisplayChild: [{\n      type: ContentChild,\n      args: [NgxGaugeValue]\n    }],\n    ariaLabel: [{\n      type: Input,\n      args: ['aria-label']\n    }],\n    ariaLabelledby: [{\n      type: Input,\n      args: ['aria-labelledby']\n    }],\n    size: [{\n      type: Input\n    }],\n    margin: [{\n      type: Input\n    }],\n    min: [{\n      type: Input\n    }],\n    animate: [{\n      type: Input\n    }],\n    max: [{\n      type: Input\n    }],\n    type: [{\n      type: Input\n    }],\n    cap: [{\n      type: Input\n    }],\n    thick: [{\n      type: Input\n    }],\n    label: [{\n      type: Input\n    }],\n    append: [{\n      type: Input\n    }],\n    prepend: [{\n      type: Input\n    }],\n    foregroundColor: [{\n      type: Input\n    }],\n    backgroundColor: [{\n      type: Input\n    }],\n    thresholds: [{\n      type: Input\n    }],\n    markers: [{\n      type: Input\n    }],\n    value: [{\n      type: Input\n    }],\n    duration: [{\n      type: Input\n    }]\n  });\n})();\nclass NgxGaugeModule {\n  static #_ = this.ɵfac = function NgxGaugeModule_Factory(t) {\n    return new (t || NgxGaugeModule)();\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxGaugeModule\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxGaugeModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [NgxGauge, NgxGaugeAppend, NgxGaugePrepend, NgxGaugeValue, NgxGaugeLabel],\n      exports: [NgxGauge, NgxGaugeAppend, NgxGaugePrepend, NgxGaugeValue, NgxGaugeLabel]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public APIs of ngx-gauge\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxGauge, NgxGaugeAppend, NgxGaugeLabel, NgxGaugeModule, NgxGaugePrepend, NgxGaugeValue };\n//# sourceMappingURL=ngx-gauge.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}